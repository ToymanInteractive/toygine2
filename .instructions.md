# Repository AI Instructions

This file defines mandatory rules for AI-assisted code and documentation generation in this repository.

All AI tools (Cursor, Copilot, Continue, etc.) must follow these rules when generating or modifying code, tests, or documentation.

---

## Project Context

This repository contains a C++ game engine targeting:

- Desktop platforms
- Mobile platforms
- Embedded and constrained systems
- Retro consoles (fixed memory, no OS assumptions)

Key priorities:

- Deterministic behavior
- Minimal allocations
- Compile-time validation
- Long-term maintainability

---

## General Coding Principles

- Prefer **simplicity and clarity** over cleverness.
- Avoid unnecessary abstractions and indirection.
- Code must be understandable from reading the code itself, without relying on comments.
- Every construct must justify its existence in terms of correctness, performance, or clarity.

- Prefer **pure functions** and **functional-style composition** where practical.
- Minimize side effects and **isolate them at well-defined system boundaries**.
- Favor **value semantics** over shared mutable state.
- Functions should ideally depend only on their inputs and produce observable results explicitly.

- Optimize for **deterministic behavior** and reproducibility across platforms.
- Prefer designs that are **constexpr-friendly** and verifiable at compile time.
- Make invalid states **unrepresentable** where possible.

- Be explicit rather than implicit.
- Avoid hidden control flow, implicit ownership, and surprising lifetime semantics.
- Prefer compile-time errors over runtime failures.

- Design APIs for **correctness first**, then performance.
- Do not introduce performance optimizations without clear justification and measurement.
- Low-level or performance-critical code must document the reasoning behind non-obvious choices.

---

## Language and Standard

- C++20 is the baseline language standard.
- C++23 features may be used selectively where they are supported by the target toolchain.
- Prefer standard library facilities when feasible.
- Avoid compiler-specific extensions unless strictly required.

---

## Header / Source Organization

### Module Structure

- Each module exposes a single public *barrel header* that acts as the module entry point.
- Users of the library must include **only** the module header and must not depend on internal headers.
- Internal headers are considered implementation details and are not part of the public API.
- Barrel headers may be precompiled.

### Headers

- Public headers must be self-contained.
- Public headers must not rely on include order.
- Minimize includes; prefer forward declarations in public headers.
- Internal headers may include other internal headers freely.

### Inline and Template Code

- All inline and template implementations must be placed in `.inl` files.
- Public headers must include their corresponding `.inl` file explicitly, typically at the end of the header.
- Do not place non-trivial inline implementations directly in public headers.

### `.inl` Files

- `.inl` files are part of the module interface but not part of the public API.
- `.inl` files may contain:
  - Template implementations
  - `constexpr` and inline function definitions
  - Inline operator implementations
- `.inl` files must not be included directly by users.
- `.inl` files must not introduce new public symbols that are not declared in the corresponding header.
- Each `.inl` file must be included by exactly one public header.

---

## Memory and Allocation Rules

- Avoid dynamic allocation by default.
- Any heap allocation must be explicit and justified.
- Support both:
  - Fixed-capacity (stack or static storage)
  - Dynamic allocation (heap), when required

No hidden allocations.

---

## Constexpr-First Design

- Prefer `constexpr` whenever possible.
- APIs should be usable at compile time if logically feasible.
- Favor value semantics.

If something can be checked at compile time, it should be.

---

## Error Handling

- Prefer explicit error handling.
- Avoid exceptions unless explicitly allowed.
- Prefer:
  - Return values
  - `expected`-like patterns
  - Compile-time validation

---

## Naming Conventions

- Types (classes, structs, enums, concepts): `PascalCase`
- Functions and variables: `camelCase`
- Constants: `UPPER_SNAKE_CASE` (only for true, globally visible constants)
- Template parameters: descriptive names; avoid single-letter names unless the meaning is obvious and the scope is trivial

Names must describe **intent**, not implementation details.

### Private Members

- All private data members and private member functions **must** start with a leading underscore (`_`).
- This rule applies only to private members; protected and public members must **not** use a leading underscore.
- The leading underscore is part of the naming convention and must be preserved consistently.

---

## Comments and Documentation

- Do not comment obvious code.
- Comments must explain *why*, not *what*.
- Public APIs must be documented.

Documentation style:

- Concise
- Neutral
- Technical
- No marketing language

---

## Documentation Style Rules

- Use simple, direct language.
- Avoid verbosity.
- Prefer bullet points over prose where appropriate.
- Document:
  - Purpose
  - Constraints
  - Usage expectations
  - Compile-time vs runtime behavior

---

## Unit Test Style Rules

These rules define how unit tests must be written or generated by AI tools in this repository.

The goal is to keep tests:

- Short
- Deterministic
- Non-redundant
- Suitable for constrained and embedded platforms

---

## Test Framework Assumptions

- Catch2-style tests are assumed.
- `static_assert` and `STATIC_REQUIRE` are preferred when possible.

---

## General Test Principles

- Tests must be minimal and focused.
- One test = one behavioral aspect.
- Prefer clarity over coverage inflation.
- Avoid large, monolithic test cases.

---

## Test Length and Structure

- Tests must be readable without scrolling.
- Avoid excessive setup.
- Avoid deeply nested sections.

If setup becomes complex, refactor the API or extract helpers.

---

## Compile-Time vs Runtime Testing

### Compile-Time (`constexpr`) Tests

- Prefer compile-time verification whenever possible.
- Use:
  - `static_assert`
  - `STATIC_REQUIRE`
- Test:
  - Type traits
  - `constexpr` constructors
  - `constexpr` operators
  - Compile-time invariants

Compile-time tests are preferred for:

- Containers
- Math types
- Value semantics

---

### Runtime Tests

- Use runtime tests only when:
  - Behavior depends on runtime state
  - `constexpr` evaluation is not possible
- Runtime tests must be deterministic.

Avoid:

- Randomness
- Time-based behavior
- Platform-dependent assumptions

---

## Redundancy and Duplication

- Do not generate multiple tests for the same behavior.
- Avoid copy-paste test cases with minor variations.

Prefer:

- Parameterized tests
- Small helper functions
- Reusing a single test to cover multiple invariants

If two tests assert the same contract, keep only one.

---

## Value-Based Assertions

- Prefer value comparisons over implementation details.
- Do not test private or internal state unless explicitly intended.

Tests must survive refactoring without semantic changes.

---

## Constexpr + Runtime Parity

When applicable:

- Verify the same behavior at:
  - Compile time
  - Runtime

The observable result must be identical.

---

## Naming Tests

- Test names must describe behavior, not implementation.
- Avoid redundant prefixes.
- Avoid repeating the tested type name unless necessary.

---

## Floating Point Rules

- Avoid floating-point tests unless explicitly required.
- If unavoidable:
  - Account for platform limitations
  - Avoid fragile equality checks

---

## Test Independence

- Tests must not depend on:
  - Execution order
  - Global mutable state
- Each test must be independently executable.

---

## Final Rule

If a behavior can be verified at compile time,
it must be verified at compile time.

Runtime tests exist only to cover what compile-time tests cannot.
