<!-- HTML header for doxygen 1.14.0-->
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
  <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=11" />
  <meta name="generator" content="Doxygen 1.15.0" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ToyGine2: toy Namespace Reference</title>
  <link href="../../tabs.css" rel="stylesheet" type="text/css" />
  <script type="text/javascript" src="../../jquery.js"></script>
  <script type="text/javascript" src="../../dynsections.js"></script>
  <script type="text/javascript" src="../../clipboard.js"></script>
  <link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
  <link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
  <link href="../../doxygen.css" rel="stylesheet" type="text/css" />
  <link href="../../doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="../../custom.css" rel="stylesheet" type="text/css"/>
<link href="../../doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="../../doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
  <script type="text/javascript" src="../../doxygen-awesome-darkmode-toggle.js"></script>
  <script type="text/javascript" src="../../doxygen-awesome-paragraph-link.js"></script>
  <script type="text/javascript" src="../../doxygen-awesome-interactive-toc.js"></script>
  <script type="text/javascript" src="../../doxygen-awesome-tabs.js"></script>
  <script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
    DoxygenAwesomeParagraphLink.init()
    DoxygenAwesomeInteractiveToc.init()
    DoxygenAwesomeTabs.init()
  </script>
</head>
<body>
  <!-- https://tholman.com/github-corners/ -->
  <a href="https://github.com/ToymanInteractive/toygine2" class="github-corner" title="View source on GitHub" target="_blank" rel="noopener noreferrer"><svg viewBox="0 0 250 250" width="40" height="40" style="position: absolute; top: 0; border: 0; right: 0; z-index: 99;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>
  <style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
      <div id="titlearea">
        <table cellspacing="0" cellpadding="0">
          <tbody>
            <tr id="projectrow">
              <td id="projectlogo"><img alt="Logo" src="../../logo.webp"  height="52" /></td>
              <td id="projectalign">
                <div id="projectname">ToyGine2<span
                    id="projectnumber">&#160;25.10.0</span>
                </div>
                <div id="projectbrief">Game Engine for retro consoles</div>
              </td>
            </tr>
          </tbody>
        </table>
      </div>
      <!-- end header part -->
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('d4/da9/namespacetoy.html','../../',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">toy Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Root namespace containing all engine modules.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-namespaces" class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:app" id="r_app"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/df3/namespacetoy_1_1app.html">app</a></td></tr>
<tr class="memdesc:dc/df3/namespacetoy_1_1app"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains all public application-level types, utilities, and management functions of engine. <br /></td></tr>
<tr class="memitem:math" id="r_math"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d83/namespacetoy_1_1math.html">math</a></td></tr>
<tr class="memdesc:d2/d83/namespacetoy_1_1math"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains all public mathematical types, constants, and utility functions of engine. <br /></td></tr>
<tr class="memitem:assertion" id="r_assertion"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/da2/namespacetoy_1_1assertion.html">assertion</a></td></tr>
<tr class="memdesc:d2/da2/namespacetoy_1_1assertion"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assertion utilities for validating engine invariants and runtime conditions. <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:_5Fdivmod10" id="r__5Fdivmod10"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d10/structtoy_1_1__divmod10.html">_divmod10</a></td></tr>
<tr class="memitem:CStringView" id="r_CStringView"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html">CStringView</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-owning string view class for C-style strings.  <a href="../../d5/d03/classtoy_1_1_c_string_view.html#details">More...</a><br /></td></tr>
<tr class="memitem:CallbacksPool" id="r_CallbacksPool"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dc9/classtoy_1_1_callbacks_pool.html">CallbacksPool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template callback pool class with fixed-size callback storage.  <a href="../../d8/dc9/classtoy_1_1_callbacks_pool.html#details">More...</a><br /></td></tr>
<tr class="memitem:FixedString" id="r_FixedString"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html">FixedString</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template string class with fixed-size character buffer.  <a href="../../d3/d7a/classtoy_1_1_fixed_string.html#details">More...</a><br /></td></tr>
<tr class="memitem:FixedVector" id="r_FixedVector"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/dec/classtoy_1_1_fixed_vector.html">FixedVector</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-concepts" class="groupheader"><a id="concepts" name="concepts"></a>
Concepts</h2></td></tr>
<tr class="memitem:StringLike" id="r_StringLike"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d77/concepttoy_1_1_string_like.html">StringLike</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept defining the requirements for string-like types. <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a3a8c65476e352b7f64a0bf15ddc87747" id="r_a3a8c65476e352b7f64a0bf15ddc87747"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3a8c65476e352b7f64a0bf15ddc87747">operator==</a> (const <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html">CStringView</a> &amp;lhs, const <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html">CStringView</a> &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a3a8c65476e352b7f64a0bf15ddc87747"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison operator for two <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html" title="Non-owning string view class for C-style strings.">CStringView</a> objects.  <br /></td></tr>
<tr class="memitem:a3ae46d261b42cdcd0e59b395aebdc834" id="r_a3ae46d261b42cdcd0e59b395aebdc834"><td class="memTemplParams" colspan="2">template&lt;StringLike stringType&gt; </td></tr>
<tr class="memitem:a3ae46d261b42cdcd0e59b395aebdc834 template"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3ae46d261b42cdcd0e59b395aebdc834">operator==</a> (const <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html">CStringView</a> &amp;lhs, const stringType &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a3ae46d261b42cdcd0e59b395aebdc834"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison operator for <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html" title="Non-owning string view class for C-style strings.">CStringView</a> and <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> object.  <br /></td></tr>
<tr class="memitem:ac0c288d93fdbf4dba71c4309203d9047" id="r_ac0c288d93fdbf4dba71c4309203d9047"><td class="memTemplParams" colspan="2">template&lt;StringLike stringType&gt; </td></tr>
<tr class="memitem:ac0c288d93fdbf4dba71c4309203d9047 template"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac0c288d93fdbf4dba71c4309203d9047">operator==</a> (const stringType &amp;lhs, const <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html">CStringView</a> &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ac0c288d93fdbf4dba71c4309203d9047"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison operator for <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> object and <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html" title="Non-owning string view class for C-style strings.">CStringView</a>.  <br /></td></tr>
<tr class="memitem:a3761711b53e204a0f2871764d435fd35" id="r_a3761711b53e204a0f2871764d435fd35"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3761711b53e204a0f2871764d435fd35">operator==</a> (const <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html">CStringView</a> &amp;lhs, const char *rhs) noexcept</td></tr>
<tr class="memdesc:a3761711b53e204a0f2871764d435fd35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison operator for <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html" title="Non-owning string view class for C-style strings.">CStringView</a> and C string.  <br /></td></tr>
<tr class="memitem:a71f575fa58def2abe56c129ff51a3696" id="r_a71f575fa58def2abe56c129ff51a3696"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a71f575fa58def2abe56c129ff51a3696">operator==</a> (const char *lhs, const <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html">CStringView</a> &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a71f575fa58def2abe56c129ff51a3696"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison operator for C string and <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html" title="Non-owning string view class for C-style strings.">CStringView</a>.  <br /></td></tr>
<tr class="memitem:af959d0dc5fc118ec5c65f27143180021" id="r_af959d0dc5fc118ec5c65f27143180021"><td class="memItemLeft" align="right" valign="top">constexpr std::strong_ordering&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af959d0dc5fc118ec5c65f27143180021">operator&lt;=&gt;</a> (const <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html">CStringView</a> &amp;lhs, const <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html">CStringView</a> &amp;rhs) noexcept</td></tr>
<tr class="memdesc:af959d0dc5fc118ec5c65f27143180021"><td class="mdescLeft">&#160;</td><td class="mdescRight">Three-way comparison operator for <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html" title="Non-owning string view class for C-style strings.">CStringView</a> objects.  <br /></td></tr>
<tr class="memitem:a2571fe89aa51139ddbb04bc1fdd0585c" id="r_a2571fe89aa51139ddbb04bc1fdd0585c"><td class="memTemplParams" colspan="2">template&lt;StringLike stringType&gt; </td></tr>
<tr class="memitem:a2571fe89aa51139ddbb04bc1fdd0585c template"><td class="memItemLeft" align="right" valign="top">constexpr std::strong_ordering&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2571fe89aa51139ddbb04bc1fdd0585c">operator&lt;=&gt;</a> (const <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html">CStringView</a> &amp;lhs, const stringType &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a2571fe89aa51139ddbb04bc1fdd0585c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Three-way comparison operator for <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html" title="Non-owning string view class for C-style strings.">CStringView</a> and <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> object.  <br /></td></tr>
<tr class="memitem:ac327b00da21b55bf3cd1817280a52315" id="r_ac327b00da21b55bf3cd1817280a52315"><td class="memTemplParams" colspan="2">template&lt;StringLike stringType&gt; </td></tr>
<tr class="memitem:ac327b00da21b55bf3cd1817280a52315 template"><td class="memItemLeft" align="right" valign="top">constexpr std::strong_ordering&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac327b00da21b55bf3cd1817280a52315">operator&lt;=&gt;</a> (const stringType &amp;lhs, const <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html">CStringView</a> &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ac327b00da21b55bf3cd1817280a52315"><td class="mdescLeft">&#160;</td><td class="mdescRight">Three-way comparison operator for <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> object and <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html" title="Non-owning string view class for C-style strings.">CStringView</a>.  <br /></td></tr>
<tr class="memitem:ad9aa91580633549a095c7ba702bee9d9" id="r_ad9aa91580633549a095c7ba702bee9d9"><td class="memItemLeft" align="right" valign="top">constexpr std::strong_ordering&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad9aa91580633549a095c7ba702bee9d9">operator&lt;=&gt;</a> (const <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html">CStringView</a> &amp;lhs, const char *rhs) noexcept</td></tr>
<tr class="memdesc:ad9aa91580633549a095c7ba702bee9d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Three-way comparison operator for <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html" title="Non-owning string view class for C-style strings.">CStringView</a> and C string.  <br /></td></tr>
<tr class="memitem:ab856389c5db41137391343498eb280a2" id="r_ab856389c5db41137391343498eb280a2"><td class="memItemLeft" align="right" valign="top">constexpr std::strong_ordering&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab856389c5db41137391343498eb280a2">operator&lt;=&gt;</a> (const char *lhs, const <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html">CStringView</a> &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ab856389c5db41137391343498eb280a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Three-way comparison operator for C string and <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html" title="Non-owning string view class for C-style strings.">CStringView</a>.  <br /></td></tr>
<tr class="memitem:a28fad381ee4d8415699e790432777471" id="r_a28fad381ee4d8415699e790432777471"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a28fad381ee4d8415699e790432777471">cstrcmp</a> (const char *lhs, const char *rhs) noexcept</td></tr>
<tr class="memdesc:a28fad381ee4d8415699e790432777471"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two C strings lexicographically.  <br /></td></tr>
<tr class="memitem:a591ce52797bb53b8d8ce64a31cabba6b" id="r_a591ce52797bb53b8d8ce64a31cabba6b"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a591ce52797bb53b8d8ce64a31cabba6b">cstrchr</a> (const char *str, int ch) noexcept</td></tr>
<tr class="memdesc:a591ce52797bb53b8d8ce64a31cabba6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first occurrence of a character in a C string.  <br /></td></tr>
<tr class="memitem:adaa16f254dc6bc99679971d96bd87a66" id="r_adaa16f254dc6bc99679971d96bd87a66"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adaa16f254dc6bc99679971d96bd87a66">cstrpbrk</a> (const char *str, const char *accept) noexcept</td></tr>
<tr class="memdesc:adaa16f254dc6bc99679971d96bd87a66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first occurrence of any character from a set in a C string.  <br /></td></tr>
<tr class="memitem:a58d00a4a7bbd87ef48d346903b5a8c78" id="r_a58d00a4a7bbd87ef48d346903b5a8c78"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a58d00a4a7bbd87ef48d346903b5a8c78">cstrstr</a> (const char *haystack, const char *needle) noexcept</td></tr>
<tr class="memdesc:a58d00a4a7bbd87ef48d346903b5a8c78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first occurrence of a substring in a C string.  <br /></td></tr>
<tr class="memitem:ac789c531cca9ded2d4866edf6d7b9ed5" id="r_ac789c531cca9ded2d4866edf6d7b9ed5"><td class="memTemplParams" colspan="2">template&lt;size_t allocatedSize1, size_t allocatedSize2&gt; </td></tr>
<tr class="memitem:ac789c531cca9ded2d4866edf6d7b9ed5 template"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html">FixedString</a>&lt; allocatedSize1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac789c531cca9ded2d4866edf6d7b9ed5">operator+</a> (const <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html">FixedString</a>&lt; allocatedSize1 &gt; &amp;lhs, const <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html">FixedString</a>&lt; allocatedSize2 &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ac789c531cca9ded2d4866edf6d7b9ed5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenation operator for two <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> objects.  <br /></td></tr>
<tr class="memitem:a66eecb2acd9da94710c77b796f60cb21" id="r_a66eecb2acd9da94710c77b796f60cb21"><td class="memTemplParams" colspan="2">template&lt;size_t allocatedSize, StringLike stringType&gt; </td></tr>
<tr class="memitem:a66eecb2acd9da94710c77b796f60cb21 template"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html">FixedString</a>&lt; allocatedSize &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a66eecb2acd9da94710c77b796f60cb21">operator+</a> (const <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html">FixedString</a>&lt; allocatedSize &gt; &amp;lhs, const stringType &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a66eecb2acd9da94710c77b796f60cb21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenation operator for <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> and <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> object.  <br /></td></tr>
<tr class="memitem:a3e935013c7764b31202b25105a86cedd" id="r_a3e935013c7764b31202b25105a86cedd"><td class="memTemplParams" colspan="2">template&lt;StringLike stringType, size_t allocatedSize&gt; </td></tr>
<tr class="memitem:a3e935013c7764b31202b25105a86cedd template"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html">FixedString</a>&lt; allocatedSize &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3e935013c7764b31202b25105a86cedd">operator+</a> (const stringType &amp;lhs, const <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html">FixedString</a>&lt; allocatedSize &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a3e935013c7764b31202b25105a86cedd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenation operator for <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> object and <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a>.  <br /></td></tr>
<tr class="memitem:affd1da1d9c8f6ce96223f0321ca1efef" id="r_affd1da1d9c8f6ce96223f0321ca1efef"><td class="memTemplParams" colspan="2">template&lt;size_t allocatedSize&gt; </td></tr>
<tr class="memitem:affd1da1d9c8f6ce96223f0321ca1efef template"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html">FixedString</a>&lt; allocatedSize &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#affd1da1d9c8f6ce96223f0321ca1efef">operator+</a> (const <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html">FixedString</a>&lt; allocatedSize &gt; &amp;lhs, const char *rhs) noexcept</td></tr>
<tr class="memdesc:affd1da1d9c8f6ce96223f0321ca1efef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenation operator for <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> and C-string.  <br /></td></tr>
<tr class="memitem:a2fef40d514c1a38e96d004926fe183d6" id="r_a2fef40d514c1a38e96d004926fe183d6"><td class="memTemplParams" colspan="2">template&lt;size_t allocatedSize&gt; </td></tr>
<tr class="memitem:a2fef40d514c1a38e96d004926fe183d6 template"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html">FixedString</a>&lt; allocatedSize &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2fef40d514c1a38e96d004926fe183d6">operator+</a> (const char *lhs, const <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html">FixedString</a>&lt; allocatedSize &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a2fef40d514c1a38e96d004926fe183d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenation operator for C-string and <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a>.  <br /></td></tr>
<tr class="memitem:a326a560f0c3c0d12d9c7a8642d001e6d" id="r_a326a560f0c3c0d12d9c7a8642d001e6d"><td class="memTemplParams" colspan="2">template&lt;size_t allocatedSize&gt; </td></tr>
<tr class="memitem:a326a560f0c3c0d12d9c7a8642d001e6d template"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html">FixedString</a>&lt; allocatedSize &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a326a560f0c3c0d12d9c7a8642d001e6d">operator+</a> (const <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html">FixedString</a>&lt; allocatedSize &gt; &amp;lhs, char rhs) noexcept</td></tr>
<tr class="memdesc:a326a560f0c3c0d12d9c7a8642d001e6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenation operator for <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> and character.  <br /></td></tr>
<tr class="memitem:a356a3fceab84ce068ff702d19893708b" id="r_a356a3fceab84ce068ff702d19893708b"><td class="memTemplParams" colspan="2">template&lt;size_t allocatedSize&gt; </td></tr>
<tr class="memitem:a356a3fceab84ce068ff702d19893708b template"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html">FixedString</a>&lt; allocatedSize &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a356a3fceab84ce068ff702d19893708b">operator+</a> (char lhs, const <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html">FixedString</a>&lt; allocatedSize &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a356a3fceab84ce068ff702d19893708b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenation operator for character and <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a>.  <br /></td></tr>
<tr class="memitem:acf758a094d8de5ef108ef3e984c37cf1" id="r_acf758a094d8de5ef108ef3e984c37cf1"><td class="memTemplParams" colspan="2">template&lt;size_t allocatedSize1, size_t allocatedSize2&gt; </td></tr>
<tr class="memitem:acf758a094d8de5ef108ef3e984c37cf1 template"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acf758a094d8de5ef108ef3e984c37cf1">operator==</a> (const <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html">FixedString</a>&lt; allocatedSize1 &gt; &amp;lhs, const <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html">FixedString</a>&lt; allocatedSize2 &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:acf758a094d8de5ef108ef3e984c37cf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison operator for two <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> objects.  <br /></td></tr>
<tr class="memitem:a718df287209b3adb957de9de67f9d863" id="r_a718df287209b3adb957de9de67f9d863"><td class="memTemplParams" colspan="2">template&lt;size_t allocatedSize, StringLike stringType&gt; </td></tr>
<tr class="memitem:a718df287209b3adb957de9de67f9d863 template"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a718df287209b3adb957de9de67f9d863">operator==</a> (const <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html">FixedString</a>&lt; allocatedSize &gt; &amp;lhs, const stringType &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a718df287209b3adb957de9de67f9d863"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison operator for <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> and <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> object.  <br /></td></tr>
<tr class="memitem:a300e65bc1fbafecbcf63f47317198ec4" id="r_a300e65bc1fbafecbcf63f47317198ec4"><td class="memTemplParams" colspan="2">template&lt;StringLike stringType, size_t allocatedSize&gt; </td></tr>
<tr class="memitem:a300e65bc1fbafecbcf63f47317198ec4 template"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a300e65bc1fbafecbcf63f47317198ec4">operator==</a> (const stringType &amp;lhs, const <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html">FixedString</a>&lt; allocatedSize &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a300e65bc1fbafecbcf63f47317198ec4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison operator for <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> object and <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a>.  <br /></td></tr>
<tr class="memitem:a6e7299d83e4f5d41d4951f84a44abdf4" id="r_a6e7299d83e4f5d41d4951f84a44abdf4"><td class="memTemplParams" colspan="2">template&lt;size_t allocatedSize&gt; </td></tr>
<tr class="memitem:a6e7299d83e4f5d41d4951f84a44abdf4 template"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6e7299d83e4f5d41d4951f84a44abdf4">operator==</a> (const <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html">FixedString</a>&lt; allocatedSize &gt; &amp;lhs, const char *rhs) noexcept</td></tr>
<tr class="memdesc:a6e7299d83e4f5d41d4951f84a44abdf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison operator for <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> and C string.  <br /></td></tr>
<tr class="memitem:a5568d083a1e1f805d9a0b9e22d3ea00d" id="r_a5568d083a1e1f805d9a0b9e22d3ea00d"><td class="memTemplParams" colspan="2">template&lt;size_t allocatedSize&gt; </td></tr>
<tr class="memitem:a5568d083a1e1f805d9a0b9e22d3ea00d template"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5568d083a1e1f805d9a0b9e22d3ea00d">operator==</a> (const char *lhs, const <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html">FixedString</a>&lt; allocatedSize &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a5568d083a1e1f805d9a0b9e22d3ea00d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison operator for C string and <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a>.  <br /></td></tr>
<tr class="memitem:a3a3d16e98341489a2ba4e77d76e72e4f" id="r_a3a3d16e98341489a2ba4e77d76e72e4f"><td class="memTemplParams" colspan="2">template&lt;size_t allocatedSize1, size_t allocatedSize2&gt; </td></tr>
<tr class="memitem:a3a3d16e98341489a2ba4e77d76e72e4f template"><td class="memItemLeft" align="right" valign="top">constexpr std::strong_ordering&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3a3d16e98341489a2ba4e77d76e72e4f">operator&lt;=&gt;</a> (const <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html">FixedString</a>&lt; allocatedSize1 &gt; &amp;lhs, const <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html">FixedString</a>&lt; allocatedSize2 &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a3a3d16e98341489a2ba4e77d76e72e4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Three-way comparison operator for <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> objects.  <br /></td></tr>
<tr class="memitem:a600f056ee510aa623a7eec926077d0d2" id="r_a600f056ee510aa623a7eec926077d0d2"><td class="memTemplParams" colspan="2">template&lt;size_t allocatedSize, StringLike stringType&gt; </td></tr>
<tr class="memitem:a600f056ee510aa623a7eec926077d0d2 template"><td class="memItemLeft" align="right" valign="top">constexpr std::strong_ordering&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a600f056ee510aa623a7eec926077d0d2">operator&lt;=&gt;</a> (const <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html">FixedString</a>&lt; allocatedSize &gt; &amp;lhs, const stringType &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a600f056ee510aa623a7eec926077d0d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Three-way comparison operator for <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> and <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> object.  <br /></td></tr>
<tr class="memitem:a5d95d2f2437840de99f597f291f3d9f9" id="r_a5d95d2f2437840de99f597f291f3d9f9"><td class="memTemplParams" colspan="2">template&lt;StringLike stringType, size_t allocatedSize&gt; </td></tr>
<tr class="memitem:a5d95d2f2437840de99f597f291f3d9f9 template"><td class="memItemLeft" align="right" valign="top">constexpr std::strong_ordering&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5d95d2f2437840de99f597f291f3d9f9">operator&lt;=&gt;</a> (const stringType &amp;lhs, const <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html">FixedString</a>&lt; allocatedSize &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a5d95d2f2437840de99f597f291f3d9f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Three-way comparison operator for <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> object and <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a>.  <br /></td></tr>
<tr class="memitem:a46515295e8eafc3e748d0c02ad5ecd70" id="r_a46515295e8eafc3e748d0c02ad5ecd70"><td class="memTemplParams" colspan="2">template&lt;size_t allocatedSize&gt; </td></tr>
<tr class="memitem:a46515295e8eafc3e748d0c02ad5ecd70 template"><td class="memItemLeft" align="right" valign="top">constexpr std::strong_ordering&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a46515295e8eafc3e748d0c02ad5ecd70">operator&lt;=&gt;</a> (const <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html">FixedString</a>&lt; allocatedSize &gt; &amp;lhs, const char *rhs) noexcept</td></tr>
<tr class="memdesc:a46515295e8eafc3e748d0c02ad5ecd70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Three-way comparison operator for <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> and C string.  <br /></td></tr>
<tr class="memitem:a876dcc65c97b11b3e32289867cd11a56" id="r_a876dcc65c97b11b3e32289867cd11a56"><td class="memTemplParams" colspan="2">template&lt;size_t allocatedSize&gt; </td></tr>
<tr class="memitem:a876dcc65c97b11b3e32289867cd11a56 template"><td class="memItemLeft" align="right" valign="top">constexpr std::strong_ordering&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a876dcc65c97b11b3e32289867cd11a56">operator&lt;=&gt;</a> (const char *lhs, const <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html">FixedString</a>&lt; allocatedSize &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a876dcc65c97b11b3e32289867cd11a56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Three-way comparison operator for C string and <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a>.  <br /></td></tr>
<tr class="memitem:acf0d2ea5a12a30e6b7bdfaa9762b7ee3" id="r_acf0d2ea5a12a30e6b7bdfaa9762b7ee3"><td class="memItemLeft" align="right" valign="top">constexpr wchar_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acf0d2ea5a12a30e6b7bdfaa9762b7ee3">utf8toWChar</a> (wchar_t *dest, size_t destSize, const char *const src) noexcept</td></tr>
<tr class="memdesc:acf0d2ea5a12a30e6b7bdfaa9762b7ee3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a Unicode UTF-8 encoded C string to a wide character string.  <br /></td></tr>
<tr class="memitem:ad77806ddefe069afcd095c3d1ef37391" id="r_ad77806ddefe069afcd095c3d1ef37391"><td class="memTemplParams" colspan="2">template&lt;StringLike stringType&gt; </td></tr>
<tr class="memitem:ad77806ddefe069afcd095c3d1ef37391 template"><td class="memItemLeft" align="right" valign="top">constexpr wchar_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad77806ddefe069afcd095c3d1ef37391">utf8toWChar</a> (wchar_t *dest, size_t destSize, const stringType &amp;src) noexcept</td></tr>
<tr class="memdesc:ad77806ddefe069afcd095c3d1ef37391"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a Unicode UTF-8 encoded <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> object to a wide character string.  <br /></td></tr>
<tr class="memitem:a2ad56b53b8cdbb022ce8ce3b2aa32503" id="r_a2ad56b53b8cdbb022ce8ce3b2aa32503"><td class="memItemLeft" align="right" valign="top">constexpr char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2ad56b53b8cdbb022ce8ce3b2aa32503">reverseString</a> (char *str, size_t count=0) noexcept</td></tr>
<tr class="memdesc:a2ad56b53b8cdbb022ce8ce3b2aa32503"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses a given C string in-place.  <br /></td></tr>
<tr class="memitem:a00ce0b516e9a47a62227a9309afdb583" id="r_a00ce0b516e9a47a62227a9309afdb583"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a00ce0b516e9a47a62227a9309afdb583">crc8</a> (const void *src, size_t size, uint8_t crc=0x00) noexcept</td></tr>
<tr class="memdesc:a00ce0b516e9a47a62227a9309afdb583"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates CRC-8 checksum using Dallas/Maxim polynomial.  <br /></td></tr>
<tr class="memitem:aa63c971425cb6819414030806927a68a" id="r_aa63c971425cb6819414030806927a68a"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa63c971425cb6819414030806927a68a">crc16</a> (const void *src, size_t size, uint16_t crc=0x0000) noexcept</td></tr>
<tr class="memdesc:aa63c971425cb6819414030806927a68a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates CRC-16 checksum using IBM/ARC polynomial.  <br /></td></tr>
<tr class="memitem:a17983e173fb5e8cf5baaab61a78a402e" id="r_a17983e173fb5e8cf5baaab61a78a402e"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a17983e173fb5e8cf5baaab61a78a402e">crc32</a> (const void *src, size_t size, uint32_t crc=0x00000000) noexcept</td></tr>
<tr class="memdesc:a17983e173fb5e8cf5baaab61a78a402e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates CRC-32 checksum using IEEE 802.3 polynomial.  <br /></td></tr>
<tr class="memitem:a21509d35964c2e5617e654ff442146af" id="r_a21509d35964c2e5617e654ff442146af"><td class="memTemplParams" colspan="2">template&lt;typename T, size_t N&gt; </td></tr>
<tr class="memitem:a21509d35964c2e5617e654ff442146af template"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a21509d35964c2e5617e654ff442146af">ArraySize</a> (T(&amp;)[N])</td></tr>
<tr class="memdesc:a21509d35964c2e5617e654ff442146af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of an array at compile-time.  <br /></td></tr>
<tr class="memitem:ad95906de2f58b602b9ee9f16708f15b4" id="r_ad95906de2f58b602b9ee9f16708f15b4"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/d10/structtoy_1_1__divmod10.html">_divmod10</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad95906de2f58b602b9ee9f16708f15b4">_divModU10</a> (uint32_t value) noexcept</td></tr>
<tr class="memdesc:ad95906de2f58b602b9ee9f16708f15b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divides a given 32-bit unsigned integer by 10 and returns the quotient and remainder.  <br /></td></tr>
<tr class="memitem:a5c08dafb841b59caed6996f17b8baebc" id="r_a5c08dafb841b59caed6996f17b8baebc"><td class="memItemLeft" align="right" valign="top">constexpr int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5c08dafb841b59caed6996f17b8baebc">_ftoa32Engine</a> (char *buffer, float value, size_t precision) noexcept</td></tr>
<tr class="memdesc:a5c08dafb841b59caed6996f17b8baebc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a floating-point number to its string representation in a specified precision.  <br /></td></tr>
<tr class="memitem:a23cb859f41bbfdd0562927582baec660" id="r_a23cb859f41bbfdd0562927582baec660"><td class="memItemLeft" align="right" valign="top">constexpr int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a23cb859f41bbfdd0562927582baec660">_ftoa64Engine</a> (char *buffer, double value, size_t precision) noexcept</td></tr>
<tr class="memdesc:a23cb859f41bbfdd0562927582baec660"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a 64-bit floating-point number to its string representation with specified precision.  <br /></td></tr>
<tr class="memitem:a1398396b240f9a663cdedc2a077edfb3" id="r_a1398396b240f9a663cdedc2a077edfb3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1398396b240f9a663cdedc2a077edfb3">_floatPostProcess</a> (char *dest, char *srcBuffer, size_t bufferSize, int32_t exp10, size_t precision) noexcept</td></tr>
<tr class="memdesc:a1398396b240f9a663cdedc2a077edfb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Processes a string representation of a floating-point number, adjusting the exponent, and stripping trailing zeros.  <br /></td></tr>
<tr class="memitem:a5ee65428f52c52934cf358eec39c55aa" id="r_a5ee65428f52c52934cf358eec39c55aa"><td class="memItemLeft" align="right" valign="top">wchar_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5ee65428f52c52934cf358eec39c55aa">utf8toWChar</a> (wchar_t *dest, size_t destSize, const char *const src, size_t count) noexcept</td></tr>
<tr class="memdesc:a5ee65428f52c52934cf358eec39c55aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a Unicode UTF-8 encoded C string to a wide character string with character count limit.  <br /></td></tr>
<tr class="memitem:a008aa42596921d995b66340139fd3cfb" id="r_a008aa42596921d995b66340139fd3cfb"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a008aa42596921d995b66340139fd3cfb">wcharToUtf8</a> (char *dest, size_t destSize, const wchar_t *src) noexcept</td></tr>
<tr class="memdesc:a008aa42596921d995b66340139fd3cfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a Unicode wide character C string to a UTF-8 encoded string.  <br /></td></tr>
<tr class="memitem:a5ab02021f4ca34e0d5b6a1b0172ebe95" id="r_a5ab02021f4ca34e0d5b6a1b0172ebe95"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5ab02021f4ca34e0d5b6a1b0172ebe95">utf8Len</a> (const char *string) noexcept</td></tr>
<tr class="memdesc:a5ab02021f4ca34e0d5b6a1b0172ebe95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of Unicode characters in a UTF-8 encoded C <em class="arg">string</em>.  <br /></td></tr>
<tr class="memitem:ae8b2c5fe28a3bb8e21f377b9e8ef2bc9" id="r_ae8b2c5fe28a3bb8e21f377b9e8ef2bc9"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae8b2c5fe28a3bb8e21f377b9e8ef2bc9">itoa</a> (char *dest, size_t destSize, int8_t value) noexcept</td></tr>
<tr class="memdesc:ae8b2c5fe28a3bb8e21f377b9e8ef2bc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an 8-bit signed integer value to a C string representation.  <br /></td></tr>
<tr class="memitem:a4761bfce539cb0e61b65a3573e79177f" id="r_a4761bfce539cb0e61b65a3573e79177f"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4761bfce539cb0e61b65a3573e79177f">itoa</a> (char *dest, size_t destSize, int16_t value) noexcept</td></tr>
<tr class="memdesc:a4761bfce539cb0e61b65a3573e79177f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a 16-bit signed integer value to a C string representation.  <br /></td></tr>
<tr class="memitem:a0e120ac7533ff2ef21be74515b922843" id="r_a0e120ac7533ff2ef21be74515b922843"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0e120ac7533ff2ef21be74515b922843">itoa</a> (char *dest, size_t destSize, int32_t value) noexcept</td></tr>
<tr class="memdesc:a0e120ac7533ff2ef21be74515b922843"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a 32-bit signed integer value to a C string representation.  <br /></td></tr>
<tr class="memitem:a8940d6802bb6b139541f903cce67ee13" id="r_a8940d6802bb6b139541f903cce67ee13"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8940d6802bb6b139541f903cce67ee13">itoa</a> (char *dest, size_t destSize, int64_t value) noexcept</td></tr>
<tr class="memdesc:a8940d6802bb6b139541f903cce67ee13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a 64-bit signed integer value to a C string representation.  <br /></td></tr>
<tr class="memitem:ad88d5c5524309ced684464f509f48eb8" id="r_ad88d5c5524309ced684464f509f48eb8"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad88d5c5524309ced684464f509f48eb8">itoa</a> (char *dest, size_t destSize, uint8_t value, unsigned base) noexcept</td></tr>
<tr class="memdesc:ad88d5c5524309ced684464f509f48eb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an 8-bit unsigned integer to a C string representation in the specified base.  <br /></td></tr>
<tr class="memitem:a477ae7fff644ef6bbc2162f5b827c076" id="r_a477ae7fff644ef6bbc2162f5b827c076"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a477ae7fff644ef6bbc2162f5b827c076">itoa</a> (char *dest, size_t destSize, uint16_t value, unsigned base) noexcept</td></tr>
<tr class="memdesc:a477ae7fff644ef6bbc2162f5b827c076"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a 16-bit unsigned integer to a C string representation in the specified base.  <br /></td></tr>
<tr class="memitem:af7a429be258da6f4885ce12e4df67523" id="r_af7a429be258da6f4885ce12e4df67523"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af7a429be258da6f4885ce12e4df67523">itoa</a> (char *dest, size_t destSize, uint32_t value, unsigned base) noexcept</td></tr>
<tr class="memdesc:af7a429be258da6f4885ce12e4df67523"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a 32-bit unsigned integer to a C string representation in the specified base.  <br /></td></tr>
<tr class="memitem:afd44b7ead4fce62170589e95348fe0bf" id="r_afd44b7ead4fce62170589e95348fe0bf"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afd44b7ead4fce62170589e95348fe0bf">itoa</a> (char *dest, size_t destSize, uint64_t value, unsigned base) noexcept</td></tr>
<tr class="memdesc:afd44b7ead4fce62170589e95348fe0bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a 64-bit unsigned integer to a C string representation in the specified base.  <br /></td></tr>
<tr class="memitem:abd6a34c77550e2f8649d30d8ef1c1904" id="r_abd6a34c77550e2f8649d30d8ef1c1904"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abd6a34c77550e2f8649d30d8ef1c1904">ftoa</a> (char *dest, size_t destSize, float value, size_t precision=7) noexcept</td></tr>
<tr class="memdesc:abd6a34c77550e2f8649d30d8ef1c1904"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a 32-bit floating-point number to its C string representation with specified precision.  <br /></td></tr>
<tr class="memitem:a153b39b476aa91d0b98f6350eeae88a2" id="r_a153b39b476aa91d0b98f6350eeae88a2"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a153b39b476aa91d0b98f6350eeae88a2">ftoa</a> (char *dest, size_t destSize, double value, size_t precision=15) noexcept</td></tr>
<tr class="memdesc:a153b39b476aa91d0b98f6350eeae88a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a 64-bit floating-point number to its C string representation with specified precision.  <br /></td></tr>
<tr class="memitem:aeeb4febc194b23813d77b08ac4fea2d1" id="r_aeeb4febc194b23813d77b08ac4fea2d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeeb4febc194b23813d77b08ac4fea2d1">formatNumberString</a> (char *buffer, size_t bufferSize, const char *separator) noexcept</td></tr>
<tr class="memdesc:aeeb4febc194b23813d77b08ac4fea2d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Formats a number C string by inserting grouping separators.  <br /></td></tr>
<tr class="memitem:af111340cdbc50c7d6bd94225a55b32c7" id="r_af111340cdbc50c7d6bd94225a55b32c7"><td class="memTemplParams" colspan="2">template&lt;typename type&gt; </td></tr>
<tr class="memitem:af111340cdbc50c7d6bd94225a55b32c7 template"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af111340cdbc50c7d6bd94225a55b32c7">integerToSymbols</a> (char *dest, size_t destSize, type value, unsigned base)</td></tr>
<tr class="memdesc:af111340cdbc50c7d6bd94225a55b32c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an integer value to a string representation in a specified base.  <br /></td></tr>
<tr class="memitem:ac7e6ab0756e81280710cbab536e6a030" id="r_ac7e6ab0756e81280710cbab536e6a030"><td class="memTemplParams" colspan="2">template&lt;typename type&gt; </td></tr>
<tr class="memitem:ac7e6ab0756e81280710cbab536e6a030 template"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac7e6ab0756e81280710cbab536e6a030">itoaImplementation</a> (char *dest, size_t destSize, type value)</td></tr>
<tr class="memdesc:ac7e6ab0756e81280710cbab536e6a030"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an integer value to a string representation.  <br /></td></tr>
<tr class="memitem:a10d90a55c9c7b54190a445f8fabaa599" id="r_a10d90a55c9c7b54190a445f8fabaa599"><td class="memTemplParams" colspan="2">template&lt;typename type&gt; </td></tr>
<tr class="memitem:a10d90a55c9c7b54190a445f8fabaa599 template"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a10d90a55c9c7b54190a445f8fabaa599">utoaImplementation</a> (char *dest, size_t destSize, type value, unsigned base)</td></tr>
<tr class="memdesc:a10d90a55c9c7b54190a445f8fabaa599"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an unsigned integer value to a string representation in a specified base.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-var-members" class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a63a8d4228d33c90f9ef1684c10c07b37" id="r_a63a8d4228d33c90f9ef1684c10c07b37"><td class="memItemLeft" align="right" valign="top">static constexpr std::array&lt; uint8_t, 256 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a63a8d4228d33c90f9ef1684c10c07b37">_crc8Table</a></td></tr>
<tr class="memdesc:a63a8d4228d33c90f9ef1684c10c07b37"><td class="mdescLeft">&#160;</td><td class="mdescRight">CRC-8 lookup table using Dallas/Maxim polynomial (0x31).  <br /></td></tr>
<tr class="memitem:ad5a24715635e389733d2bd51420d0cce" id="r_ad5a24715635e389733d2bd51420d0cce"><td class="memItemLeft" align="right" valign="top">static constexpr std::array&lt; uint16_t, 256 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad5a24715635e389733d2bd51420d0cce">_crc16Table</a></td></tr>
<tr class="memdesc:ad5a24715635e389733d2bd51420d0cce"><td class="mdescLeft">&#160;</td><td class="mdescRight">CRC-16 lookup table using IBM/ARC polynomial (0x8005).  <br /></td></tr>
<tr class="memitem:adea4ce7523cb7c07e3df1712514c1298" id="r_adea4ce7523cb7c07e3df1712514c1298"><td class="memItemLeft" align="right" valign="top">static constexpr std::array&lt; uint32_t, 256 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adea4ce7523cb7c07e3df1712514c1298">_crc32Table</a></td></tr>
<tr class="memdesc:adea4ce7523cb7c07e3df1712514c1298"><td class="mdescLeft">&#160;</td><td class="mdescRight">CRC-32 lookup table using IEEE 802.3 polynomial (0x04C11DB7).  <br /></td></tr>
<tr class="memitem:a4a12924c5030e6b26a105cce437a95a9" id="r_a4a12924c5030e6b26a105cce437a95a9"><td class="memItemLeft" align="right" valign="top">static constexpr std::array&lt; uint8_t, 256 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4a12924c5030e6b26a105cce437a95a9">_utf8CharSizeTable</a></td></tr>
<tr class="memdesc:a4a12924c5030e6b26a105cce437a95a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">UTF-8 character size lookup table for efficient UTF-8 parsing.  <br /></td></tr>
<tr class="memitem:a6aa717a5991fe2ff2553833f1d626178" id="r_a6aa717a5991fe2ff2553833f1d626178"><td class="memItemLeft" align="right" valign="top">constexpr std::array&lt; uint32_t, 32 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6aa717a5991fe2ff2553833f1d626178">_exponentTable</a></td></tr>
<tr class="memdesc:a6aa717a5991fe2ff2553833f1d626178"><td class="mdescLeft">&#160;</td><td class="mdescRight">Precomputed exponent lookup table for efficient binary-to-decimal floating-point conversion.  <br /></td></tr>
<tr class="memitem:a15a8263a5364e1ff581cf08613b9647f" id="r_a15a8263a5364e1ff581cf08613b9647f"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a15a8263a5364e1ff581cf08613b9647f">wcharInUtf8MaxSize</a> = 3</td></tr>
<tr class="memdesc:a15a8263a5364e1ff581cf08613b9647f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum UTF-8 bytes required for BMP characters.  <br /></td></tr>
<tr class="memitem:ae9d26c716cca917004e820be15f483dd" id="r_ae9d26c716cca917004e820be15f483dd"><td class="memItemLeft" align="right" valign="top">static constexpr std::array&lt; char, 36 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae9d26c716cca917004e820be15f483dd">_ansiDigits</a></td></tr>
<tr class="memdesc:ae9d26c716cca917004e820be15f483dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">ANSI digit lookup table for base conversion.  <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Root namespace containing all engine modules. </p>
</div><a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="ad95906de2f58b602b9ee9f16708f15b4" name="ad95906de2f58b602b9ee9f16708f15b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad95906de2f58b602b9ee9f16708f15b4">&#9670;&#160;</a></span>_divModU10()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d10/structtoy_1_1__divmod10.html">_divmod10</a> toy::_divModU10 </td>
          <td>(</td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Divides a given 32-bit unsigned integer by 10 and returns the quotient and remainder. </p>
<p>The function approximates division by 10 using a sequence of shift-and-add operations to compute the quotient, then derives the remainder and corrects it if needed. It returns both quotient and remainder.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The 32-bit unsigned integer to divide by 10.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A struct containing the quotient and remainder of the division. </dd></dl>

<p class="reference">Referenced by <a class="el" href="#a1398396b240f9a663cdedc2a077edfb3">_floatPostProcess()</a>.</p>
<div id="dynsection-0" onclick="return dynsection.toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;"><span class="dynarrow"><span class="arrowhead closed"></span></span>Here is the caller graph for this function:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="../../d4/da9/namespacetoy_ad95906de2f58b602b9ee9f16708f15b4_icgraph.svg" width="476" height="86"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a1398396b240f9a663cdedc2a077edfb3" name="a1398396b240f9a663cdedc2a077edfb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1398396b240f9a663cdedc2a077edfb3">&#9670;&#160;</a></span>_floatPostProcess()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void toy::_floatPostProcess </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>srcBuffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>bufferSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>exp10</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>precision</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Processes a string representation of a floating-point number, adjusting the exponent, and stripping trailing zeros. </p>
<p>This function processes a string representation of a floating-point number, adjusting the exponent according to the given precision, and stripping trailing zeros. The function also handles the case of negative zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>The destination buffer where the processed string is stored. </td></tr>
    <tr><td class="paramname">srcBuffer</td><td>The source buffer containing the string representation of a floating-point number. </td></tr>
    <tr><td class="paramname">bufferSize</td><td>The size of the source buffer. </td></tr>
    <tr><td class="paramname">exp10</td><td>The exponent of the floating-point number in the given precision. </td></tr>
    <tr><td class="paramname">precision</td><td>The number of decimal places to include in the representation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The function assumes that the destination buffer is large enough to hold the processed string. The buffer will contain the string representation in the form "+d.dd...edd" for normalized numbers. </dd></dl>

<p class="reference">Referenced by <a class="el" href="#a153b39b476aa91d0b98f6350eeae88a2">ftoa()</a>, and <a class="el" href="#abd6a34c77550e2f8649d30d8ef1c1904">ftoa()</a>.</p>
<div id="dynsection-1" onclick="return dynsection.toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;"><span class="dynarrow"><span class="arrowhead closed"></span></span>Here is the call graph for this function:</div>
<div id="dynsection-1-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-1-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="../../d4/da9/namespacetoy_a1398396b240f9a663cdedc2a077edfb3_cgraph.svg" width="354" height="36"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
<div id="dynsection-2" onclick="return dynsection.toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;"><span class="dynarrow"><span class="arrowhead closed"></span></span>Here is the caller graph for this function:</div>
<div id="dynsection-2-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-2-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="../../d4/da9/namespacetoy_a1398396b240f9a663cdedc2a077edfb3_icgraph.svg" width="298" height="86"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a5c08dafb841b59caed6996f17b8baebc" name="a5c08dafb841b59caed6996f17b8baebc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c08dafb841b59caed6996f17b8baebc">&#9670;&#160;</a></span>_ftoa32Engine()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int32_t toy::_ftoa32Engine </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>precision</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a floating-point number to its string representation in a specified precision. </p>
<p>The output is always sign-prefixed ('+' or '-') and normalized as "+0.&lt;digits&gt;" or "-0.&lt;digits&gt;".</p>
<p>This function converts a given floating-point number into its string representation, storing the result in the provided destination buffer. The function rounds the result to the given precision and stores the exponent in the return value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The floating-point number to be converted. </td></tr>
    <tr><td class="paramname">buffer</td><td>The destination buffer where the converted string is stored. </td></tr>
    <tr><td class="paramname">precision</td><td>The precision (digits after the decimal point). For IEEE-754 f32, practical precision is ~79 digits.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The exponent of the converted number in the given precision. Returns 0xFF for zero, subnormals (unsupported), NaN, and INF.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The function assumes that the destination buffer is large enough to hold the converted string. The function does not support subnormals. </dd></dl>

<p class="reference">Referenced by <a class="el" href="#a23cb859f41bbfdd0562927582baec660">_ftoa64Engine()</a>, and <a class="el" href="#abd6a34c77550e2f8649d30d8ef1c1904">ftoa()</a>.</p>
<div id="dynsection-3" onclick="return dynsection.toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;"><span class="dynarrow"><span class="arrowhead closed"></span></span>Here is the caller graph for this function:</div>
<div id="dynsection-3-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-3-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="../../d4/da9/namespacetoy_a5c08dafb841b59caed6996f17b8baebc_icgraph.svg" width="467" height="86"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a23cb859f41bbfdd0562927582baec660" name="a23cb859f41bbfdd0562927582baec660"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23cb859f41bbfdd0562927582baec660">&#9670;&#160;</a></span>_ftoa64Engine()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int32_t toy::_ftoa64Engine </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>precision</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a 64-bit floating-point number to its string representation with specified precision. </p>
<p>The output is always sign-prefixed ('+' or '-') and normalized as "+0.&lt;digits&gt;" or "-0.&lt;digits&gt;".</p>
<p>This function converts a given 64-bit floating-point number into its string representation, storing the result in the provided buffer. The conversion includes handling special cases such as subnormals, NaN, and infinity. The output is formatted according to the specified precision.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The destination buffer where the converted string is stored. </td></tr>
    <tr><td class="paramname">value</td><td>The 64-bit floating-point number to be converted. </td></tr>
    <tr><td class="paramname">precision</td><td>The number of decimal places to include in the representation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The exponent of the converted number in the given precision. Returns 0x7FF for zero, subnormals (unsupported), NaN, and INF.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The function assumes that the buffer is large enough to hold the converted string. The buffer will contain the string representation in the form "+d.dd...edd" for normalized numbers. </dd></dl>

<p class="reference">Referenced by <a class="el" href="#a153b39b476aa91d0b98f6350eeae88a2">ftoa()</a>.</p>
<div id="dynsection-4" onclick="return dynsection.toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;"><span class="dynarrow"><span class="arrowhead closed"></span></span>Here is the call graph for this function:</div>
<div id="dynsection-4-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-4-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="../../d4/da9/namespacetoy_a23cb859f41bbfdd0562927582baec660_cgraph.svg" width="344" height="36"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
<div id="dynsection-5" onclick="return dynsection.toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;"><span class="dynarrow"><span class="arrowhead closed"></span></span>Here is the caller graph for this function:</div>
<div id="dynsection-5-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-5-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="../../d4/da9/namespacetoy_a23cb859f41bbfdd0562927582baec660_icgraph.svg" width="276" height="36"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a21509d35964c2e5617e654ff442146af" name="a21509d35964c2e5617e654ff442146af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21509d35964c2e5617e654ff442146af">&#9670;&#160;</a></span>ArraySize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t toy::ArraySize </td>
          <td>(</td>
          <td class="paramtype">T(&amp;)</td>          <td class="paramname"><span class="paramname"><em></em></span>[N]</td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the size of an array at compile-time. </p>
<p>This is a compile-time helper function that returns the size of an array. The size of the array is inferred from the parameter type, which is a reference to an array of length N. </p>

</div>
</div>
<a id="aa63c971425cb6819414030806927a68a" name="aa63c971425cb6819414030806927a68a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa63c971425cb6819414030806927a68a">&#9670;&#160;</a></span>crc16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t toy::crc16 </td>
          <td>(</td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>crc</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0x0000</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates CRC-16 checksum using IBM/ARC polynomial. </p>
<p>This function computes a CRC-16 checksum for the given data using the IBM/ARC polynomial (x + x + x + 1, 0x8005). The CRC-16 algorithm provides a reliable way to detect data corruption and is widely used in communication protocols, file systems, and data integrity verification systems.</p>
<p>The CRC-16-IBM/ARC algorithm is one of the most commonly used CRC-16 variants and is supported by many standards including:</p><ul>
<li>IBM SNA (Systems Network Architecture)</li>
<li>ARC (Archive) file format</li>
<li>LHA compression format</li>
<li>Modbus RTU protocol</li>
<li>USB data packets</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The source data to calculate CRC-16 for. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the data in bytes. </td></tr>
    <tr><td class="paramname">crc</td><td>The initial CRC value (default: <code>0x0000</code>).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The calculated CRC-16 checksum value.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The <em class="arg">src</em> pointer must not be null. </dd>
<dd>
The <em class="arg">size</em> must be valid for the data pointed to by <em class="arg">src</em>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function uses the IBM/ARC CRC-16 polynomial (0x8005), which is commonly used in communication protocols and file systems. </dd>
<dd>
The function is noexcept and does not throw exceptions. </dd>
<dd>
For empty data (size = <code>0</code>), the function returns the initial CRC value.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://en.wikipedia.org/wiki/Cyclic_redundancy_check">https://en.wikipedia.org/wiki/Cyclic_redundancy_check</a> </dd>
<dd>
<a href="https://reveng.sourceforge.io/crc-catalogue/16.htm#crc.cat.crc-16-arc">https://reveng.sourceforge.io/crc-catalogue/16.htm#crc.cat.crc-16-arc</a> </dd></dl>

</div>
</div>
<a id="a17983e173fb5e8cf5baaab61a78a402e" name="a17983e173fb5e8cf5baaab61a78a402e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17983e173fb5e8cf5baaab61a78a402e">&#9670;&#160;</a></span>crc32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t toy::crc32 </td>
          <td>(</td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>crc</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0x00000000</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates CRC-32 checksum using IEEE 802.3 polynomial. </p>
<p>This function computes a CRC-32 checksum for the given data using the IEEE 802.3 polynomial (x + x + x + x + x + x + x + x + x + x + x + x + x + x + 1, 0x04C11DB7). The CRC-32 algorithm provides excellent error detection capabilities and is widely used in networking protocols, file systems, and data integrity verification.</p>
<p>The CRC-32-IEEE 802.3 algorithm is the most commonly used CRC-32 variant and is supported by many standards including:</p><ul>
<li>IEEE 802.3 (Ethernet)</li>
<li>ZIP file format</li>
<li>PNG image format</li>
<li>MPEG-2 transport streams</li>
<li>SATA disk drives</li>
<li>IEEE 1394 (FireWire)</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The source data to calculate CRC-32 for. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the data in bytes. </td></tr>
    <tr><td class="paramname">crc</td><td>The initial CRC value (default: <code>0x00000000</code>).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The calculated CRC-32 checksum value.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The <em class="arg">src</em> pointer must not be null. </dd>
<dd>
The <em class="arg">size</em> must be valid for the data pointed to by <em class="arg">src</em>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function uses the IEEE 802.3 CRC-32 polynomial (0x04C11DB7), which is the most widely used CRC-32 variant. </dd>
<dd>
The function is noexcept and does not throw exceptions. </dd>
<dd>
For empty data (size = <code>0</code>), the function returns the initial CRC value.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://en.wikipedia.org/wiki/Cyclic_redundancy_check">https://en.wikipedia.org/wiki/Cyclic_redundancy_check</a> </dd>
<dd>
<a href="https://reveng.sourceforge.io/crc-catalogue/17plus.htm#crc.cat-bits.32">https://reveng.sourceforge.io/crc-catalogue/17plus.htm#crc.cat-bits.32</a> </dd></dl>

</div>
</div>
<a id="a00ce0b516e9a47a62227a9309afdb583" name="a00ce0b516e9a47a62227a9309afdb583"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00ce0b516e9a47a62227a9309afdb583">&#9670;&#160;</a></span>crc8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t toy::crc8 </td>
          <td>(</td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>crc</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0x00</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates CRC-8 checksum using Dallas/Maxim polynomial. </p>
<p>This function computes a CRC-8 checksum for the given data using the Dallas/Maxim polynomial (x + x + x + 1, 0x31). The CRC-8 algorithm provides a fast and efficient way to detect data corruption and is widely used in embedded systems, communication protocols, and data integrity verification.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The source data to calculate CRC-8 for. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the data in bytes. </td></tr>
    <tr><td class="paramname">crc</td><td>The initial CRC value (default: <code>0x00</code>).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The calculated CRC-8 checksum value.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The <em class="arg">src</em> pointer must not be null. </dd>
<dd>
The <em class="arg">size</em> must be valid for the data pointed to by <em class="arg">src</em>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function uses the Dallas/Maxim CRC-8 polynomial (0x31), which is commonly used in 1-Wire protocols and embedded systems. </dd>
<dd>
The function is noexcept and does not throw exceptions. </dd>
<dd>
For empty data (size = <code>0</code>), the function returns the initial CRC value.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://en.wikipedia.org/wiki/Cyclic_redundancy_check">https://en.wikipedia.org/wiki/Cyclic_redundancy_check</a> </dd>
<dd>
<a href="https://reveng.sourceforge.io/crc-catalogue/1-15.htm#crc.cat-bits.8">https://reveng.sourceforge.io/crc-catalogue/1-15.htm#crc.cat-bits.8</a> </dd></dl>

</div>
</div>
<a id="a591ce52797bb53b8d8ce64a31cabba6b" name="a591ce52797bb53b8d8ce64a31cabba6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a591ce52797bb53b8d8ce64a31cabba6b">&#9670;&#160;</a></span>cstrchr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * toy::cstrchr </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ch</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first occurrence of a character in a C string. </p>
<p>This function searches for the first occurrence of the character <em class="arg">ch</em> within the string <em class="arg">str</em>. The search is performed character by character from the beginning of the string and returns a pointer to the first occurrence, or nullptr if the character is not found. This function is designed to be constexpr-compatible and provides the same behavior as std::strchr but can be evaluated at compile time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The C string to search in. </td></tr>
    <tr><td class="paramname">ch</td><td>The character to search for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the first occurrence of <em class="arg">ch</em> in <em class="arg">str</em>, or nullptr if not found.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The <em class="arg">str</em> pointer must not be null.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The search is case-sensitive. </dd>
<dd>
The function searches from the beginning of <em class="arg">str</em> and returns the first match. </dd>
<dd>
This function is constexpr-compatible and can be used in compile-time contexts.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>std::strchr </dd></dl>

</div>
</div>
<a id="a28fad381ee4d8415699e790432777471" name="a28fad381ee4d8415699e790432777471"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28fad381ee4d8415699e790432777471">&#9670;&#160;</a></span>cstrcmp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int toy::cstrcmp </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two C strings lexicographically. </p>
<p>This function performs a lexicographic comparison between two C strings. The comparison is performed character by character using the character's numeric value. This function is designed to be constexpr-compatible and provides the same behavior as std::strcmp but can be evaluated at compile time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side C string to compare. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side C string to compare.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A negative value if <em class="arg">lhs</em> is lexicographically less than <em class="arg">rhs</em>, zero if they are equal, or a positive value if <em class="arg">lhs</em> is lexicographically greater than <em class="arg">rhs</em>.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The <em class="arg">lhs</em> pointer must not be null. </dd>
<dd>
The <em class="arg">rhs</em> pointer must not be null.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The comparison is case-sensitive. </dd>
<dd>
The comparison stops at the first character that differs between the strings. </dd>
<dd>
If one string is a prefix of another, the shorter string is considered lexicographically smaller. </dd>
<dd>
Return values are -1, 0, or 1 (differs from std::strcmp which returns arithmetic difference). </dd>
<dd>
This function is constexpr-compatible and can be used in compile-time contexts.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>std::strcmp </dd></dl>

</div>
</div>
<a id="adaa16f254dc6bc99679971d96bd87a66" name="adaa16f254dc6bc99679971d96bd87a66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaa16f254dc6bc99679971d96bd87a66">&#9670;&#160;</a></span>cstrpbrk()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * toy::cstrpbrk </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>accept</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first occurrence of any character from a set in a C string. </p>
<p>This function searches for the first occurrence of any character from the <em class="arg">accept</em> string within the <em class="arg">str</em> string. The search is performed character by character from the beginning and returns a pointer to the first character found that matches any character in the accept set, or nullptr if no character from the accept set is found. This function is designed to be constexpr-compatible and provides the same behavior as std::strpbrk but can be evaluated at compile time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The C string to search in. </td></tr>
    <tr><td class="paramname">accept</td><td>The C string containing the set of characters to search for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the first character in <em class="arg">str</em> that matches any character in <em class="arg">accept</em>, or nullptr if no character from the accept set is found.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The <em class="arg">str</em> pointer must not be null. </dd>
<dd>
The <em class="arg">accept</em> pointer must not be null. </dd>
<dd>
The <em class="arg">str</em> must be null-terminated. </dd>
<dd>
The <em class="arg">accept</em> must be null-terminated.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The search is case-sensitive. </dd>
<dd>
The function searches from the beginning of <em class="arg">str</em> and returns the first match. </dd>
<dd>
This function is constexpr-compatible and can be used in compile-time contexts.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>std::strpbrk </dd></dl>

</div>
</div>
<a id="a58d00a4a7bbd87ef48d346903b5a8c78" name="a58d00a4a7bbd87ef48d346903b5a8c78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58d00a4a7bbd87ef48d346903b5a8c78">&#9670;&#160;</a></span>cstrstr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * toy::cstrstr </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>haystack</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>needle</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first occurrence of a substring in a C string. </p>
<p>This function searches for the first occurrence of the <em class="arg">needle</em> string within the <em class="arg">haystack</em> string. The search is performed character by character from the beginning and returns a pointer to the beginning of the first occurrence, or nullptr if the substring is not found. This function is designed to be constexpr-compatible and provides the same behavior as std::strstr but can be evaluated at compile time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">haystack</td><td>The C string to search in. </td></tr>
    <tr><td class="paramname">needle</td><td>The C string to search for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the first occurrence of <em class="arg">needle</em> in <em class="arg">haystack</em>, or nullptr if not found. If <em class="arg">needle</em> is an empty string, returns <em class="arg">haystack</em>.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The <em class="arg">haystack</em> pointer must not be null. </dd>
<dd>
The <em class="arg">needle</em> pointer must not be null.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The search is case-sensitive. </dd>
<dd>
If <em class="arg">needle</em> is an empty string, the function returns <em class="arg">haystack</em> immediately. </dd>
<dd>
The function searches from the beginning of <em class="arg">haystack</em> and returns the first match. </dd>
<dd>
This function is constexpr-compatible and can be used in compile-time contexts.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>std::strstr </dd></dl>

</div>
</div>
<a id="aeeb4febc194b23813d77b08ac4fea2d1" name="aeeb4febc194b23813d77b08ac4fea2d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeeb4febc194b23813d77b08ac4fea2d1">&#9670;&#160;</a></span>formatNumberString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void toy::formatNumberString </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>bufferSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>separator</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Formats a number C string by inserting grouping separators. </p>
<p>This function inserts a grouping <em class="arg">separator</em> (e.g., comma, space, or dot) into a number C string every three digits, starting from the right. This is commonly used for formatting large numbers to improve readability (e.g., "1,234,567").</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>A pointer to the buffer where the formatted C string is stored. </td></tr>
    <tr><td class="paramname">bufferSize</td><td>The size of the buffer in characters. </td></tr>
    <tr><td class="paramname">separator</td><td>A pointer to the grouping separator C string to insert (e.g., ",", " ", ".").</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The function modifies the <em class="arg">buffer</em> in-place. </dd>
<dd>
Grouping separators are inserted every three digits from the right. </dd>
<dd>
The function handles edge cases gracefully (empty string, single digits, etc.). </dd>
<dd>
The function does not validate that the input is purely numeric. </dd></dl>

</div>
</div>
<a id="a153b39b476aa91d0b98f6350eeae88a2" name="a153b39b476aa91d0b98f6350eeae88a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a153b39b476aa91d0b98f6350eeae88a2">&#9670;&#160;</a></span>ftoa() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char * toy::ftoa </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>destSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>precision</em></span><span class="paramdefsep"> = </span><span class="paramdefval">15</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a 64-bit floating-point number to its C string representation with specified precision. </p>
<p>This function converts a given 64-bit floating-point number into its decimal C string representation, storing the result in the provided destination buffer. The conversion supports configurable precision and handles special values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>A pointer to the destination buffer where the converted C string is stored. </td></tr>
    <tr><td class="paramname">destSize</td><td>The size of the destination buffer in characters. </td></tr>
    <tr><td class="paramname">value</td><td>The 64-bit floating-point number to be converted. </td></tr>
    <tr><td class="paramname">precision</td><td>The precision (digits after the decimal point). Default is 15, practical limit is ~1517 digits.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the destination buffer containing the converted C string.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The function handles special IEEE-754 values (infinity, NaN). </dd>
<dd>
The function does not support subnormal numbers. </dd>
<dd>
Precision beyond ~1517 digits may not be meaningful for double. </dd>
<dd>
The function uses efficient bit manipulation for conversion. </dd></dl>
<div id="dynsection-6" onclick="return dynsection.toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;"><span class="dynarrow"><span class="arrowhead closed"></span></span>Here is the call graph for this function:</div>
<div id="dynsection-6-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-6-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="../../d4/da9/namespacetoy_a153b39b476aa91d0b98f6350eeae88a2_cgraph.svg" width="488" height="86"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="abd6a34c77550e2f8649d30d8ef1c1904" name="abd6a34c77550e2f8649d30d8ef1c1904"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd6a34c77550e2f8649d30d8ef1c1904">&#9670;&#160;</a></span>ftoa() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char * toy::ftoa </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>destSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>precision</em></span><span class="paramdefsep"> = </span><span class="paramdefval">7</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a 32-bit floating-point number to its C string representation with specified precision. </p>
<p>This function converts a given 32-bit floating-point number into its decimal C string representation, storing the result in the provided destination buffer. The conversion supports configurable precision and handles special values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>A pointer to the destination buffer where the converted C string is stored. </td></tr>
    <tr><td class="paramname">destSize</td><td>The size of the destination buffer in characters. </td></tr>
    <tr><td class="paramname">value</td><td>The 32-bit floating-point number to be converted. </td></tr>
    <tr><td class="paramname">precision</td><td>The precision (digits after the decimal point). Default is 7, practical limit is ~7-9 digits.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the destination buffer containing the converted C string.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The function handles special IEEE-754 values (infinity, NaN). </dd>
<dd>
The function does not support subnormal numbers. </dd>
<dd>
Precision beyond ~7-9 digits may not be meaningful for float. </dd>
<dd>
The function uses efficient bit manipulation for conversion. </dd></dl>
<div id="dynsection-7" onclick="return dynsection.toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;"><span class="dynarrow"><span class="arrowhead closed"></span></span>Here is the call graph for this function:</div>
<div id="dynsection-7-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-7-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="../../d4/da9/namespacetoy_abd6a34c77550e2f8649d30d8ef1c1904_cgraph.svg" width="476" height="86"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="af111340cdbc50c7d6bd94225a55b32c7" name="af111340cdbc50c7d6bd94225a55b32c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af111340cdbc50c7d6bd94225a55b32c7">&#9670;&#160;</a></span>integerToSymbols()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t toy::integerToSymbols </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>destSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>base</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts an integer value to a string representation in a specified base. </p>
<p>This function converts a given integer value into its string representation in the specified base, storing the result in the provided destination buffer.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">type</td><td>The type of the integer value to be converted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>The destination buffer where the converted string is stored. </td></tr>
    <tr><td class="paramname">destSize</td><td>The size of the destination buffer. </td></tr>
    <tr><td class="paramname">value</td><td>The integer value to be converted. </td></tr>
    <tr><td class="paramname">base</td><td>The numerical base for the conversion, e.g., 10 for decimal, 16 for hexadecimal.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of characters written to the destination buffer.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The function assumes that the destination buffer is large enough to hold the converted string. </dd>
<dd>
The function does not null-terminate the string. </dd>
<dd>
The base must be between 2 and 36 inclusive. </dd></dl>

</div>
</div>
<a id="a4761bfce539cb0e61b65a3573e79177f" name="a4761bfce539cb0e61b65a3573e79177f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4761bfce539cb0e61b65a3573e79177f">&#9670;&#160;</a></span>itoa() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char * toy::itoa </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>destSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a 16-bit signed integer value to a C string representation. </p>
<p>This function converts a given 16-bit signed integer value into its decimal C string representation, storing the result in the provided destination buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>A pointer to the destination buffer where the converted C string is stored. </td></tr>
    <tr><td class="paramname">destSize</td><td>The size of the destination buffer in characters. </td></tr>
    <tr><td class="paramname">value</td><td>The 16-bit signed integer value to be converted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the destination buffer containing the converted C string.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The function handles negative values correctly. </dd>
<dd>
The destination buffer must have sufficient capacity (at least 7 characters for worst case -32768). </dd></dl>

</div>
</div>
<a id="a0e120ac7533ff2ef21be74515b922843" name="a0e120ac7533ff2ef21be74515b922843"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e120ac7533ff2ef21be74515b922843">&#9670;&#160;</a></span>itoa() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char * toy::itoa </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>destSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a 32-bit signed integer value to a C string representation. </p>
<p>This function converts a given 32-bit signed integer value into its decimal C string representation, storing the result in the provided destination buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>A pointer to the destination buffer where the converted C string is stored. </td></tr>
    <tr><td class="paramname">destSize</td><td>The size of the destination buffer in characters. </td></tr>
    <tr><td class="paramname">value</td><td>The 32-bit signed integer value to be converted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the destination buffer containing the converted C string.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The function handles negative values correctly. </dd>
<dd>
The destination buffer must have sufficient capacity (at least 12 characters for worst case -2147483648). </dd></dl>

</div>
</div>
<a id="a8940d6802bb6b139541f903cce67ee13" name="a8940d6802bb6b139541f903cce67ee13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8940d6802bb6b139541f903cce67ee13">&#9670;&#160;</a></span>itoa() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char * toy::itoa </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>destSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a 64-bit signed integer value to a C string representation. </p>
<p>This function converts a given 64-bit signed integer value into its decimal C string representation, storing the result in the provided destination buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>A pointer to the destination buffer where the converted C string is stored. </td></tr>
    <tr><td class="paramname">destSize</td><td>The size of the destination buffer in characters. </td></tr>
    <tr><td class="paramname">value</td><td>The 64-bit signed integer value to be converted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the destination buffer containing the converted C string.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The function handles negative values correctly. </dd>
<dd>
The destination buffer must have sufficient capacity (at least 21 characters for worst case -9223372036854775808). </dd></dl>

</div>
</div>
<a id="ae8b2c5fe28a3bb8e21f377b9e8ef2bc9" name="ae8b2c5fe28a3bb8e21f377b9e8ef2bc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8b2c5fe28a3bb8e21f377b9e8ef2bc9">&#9670;&#160;</a></span>itoa() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char * toy::itoa </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>destSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts an 8-bit signed integer value to a C string representation. </p>
<p>This function converts a given 8-bit signed integer value into its decimal C string representation, storing the result in the provided destination buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>A pointer to the destination buffer where the converted C string is stored. </td></tr>
    <tr><td class="paramname">destSize</td><td>The size of the destination buffer in characters. </td></tr>
    <tr><td class="paramname">value</td><td>The 8-bit signed integer value to be converted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the destination buffer containing the converted C string.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The function handles negative values correctly. </dd>
<dd>
The destination buffer must have sufficient capacity (at least 5 characters for worst case -128). </dd></dl>

</div>
</div>
<a id="a477ae7fff644ef6bbc2162f5b827c076" name="a477ae7fff644ef6bbc2162f5b827c076"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a477ae7fff644ef6bbc2162f5b827c076">&#9670;&#160;</a></span>itoa() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char * toy::itoa </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>destSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>base</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a 16-bit unsigned integer to a C string representation in the specified base. </p>
<p>This function converts a given 16-bit unsigned integer value into its C string representation in the specified numerical base, storing the result in the provided destination buffer. Supports bases from 2 to 36.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>A pointer to the destination buffer where the converted C string is stored. </td></tr>
    <tr><td class="paramname">destSize</td><td>The size of the destination buffer in characters. </td></tr>
    <tr><td class="paramname">value</td><td>The 16-bit unsigned integer value to be converted. </td></tr>
    <tr><td class="paramname">base</td><td>The numerical base for the conversion (2-36). Common values: 2 (binary), 10 (decimal), 16 (hex).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the destination buffer containing the converted C string.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The function supports bases 2-36 with digits 0-9 and letters A-Z. </dd>
<dd>
Hexadecimal values use uppercase letters (A-F). </dd></dl>

</div>
</div>
<a id="af7a429be258da6f4885ce12e4df67523" name="af7a429be258da6f4885ce12e4df67523"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7a429be258da6f4885ce12e4df67523">&#9670;&#160;</a></span>itoa() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char * toy::itoa </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>destSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>base</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a 32-bit unsigned integer to a C string representation in the specified base. </p>
<p>This function converts a given 32-bit unsigned integer value into its C string representation in the specified numerical base, storing the result in the provided destination buffer. Supports bases from 2 to 36.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>A pointer to the destination buffer where the converted C string is stored. </td></tr>
    <tr><td class="paramname">destSize</td><td>The size of the destination buffer in characters. </td></tr>
    <tr><td class="paramname">value</td><td>The 32-bit unsigned integer value to be converted. </td></tr>
    <tr><td class="paramname">base</td><td>The numerical base for the conversion (2-36). Common values: 2 (binary), 10 (decimal), 16 (hex).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the destination buffer containing the converted C string.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The function supports bases 2-36 with digits 0-9 and letters A-Z. </dd>
<dd>
Hexadecimal values use uppercase letters (A-F). </dd></dl>

</div>
</div>
<a id="afd44b7ead4fce62170589e95348fe0bf" name="afd44b7ead4fce62170589e95348fe0bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd44b7ead4fce62170589e95348fe0bf">&#9670;&#160;</a></span>itoa() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char * toy::itoa </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>destSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>base</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a 64-bit unsigned integer to a C string representation in the specified base. </p>
<p>This function converts a given 64-bit unsigned integer value into its C string representation in the specified numerical base, storing the result in the provided destination buffer. Supports bases from 2 to 36.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>A pointer to the destination buffer where the converted C string is stored. </td></tr>
    <tr><td class="paramname">destSize</td><td>The size of the destination buffer in characters. </td></tr>
    <tr><td class="paramname">value</td><td>The 64-bit unsigned integer value to be converted. </td></tr>
    <tr><td class="paramname">base</td><td>The numerical base for the conversion (2-36). Common values: 2 (binary), 10 (decimal), 16 (hex).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the destination buffer containing the converted C string.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The function supports bases 2-36 with digits 0-9 and letters A-Z. </dd>
<dd>
Hexadecimal values use uppercase letters (A-F). </dd></dl>

</div>
</div>
<a id="ad88d5c5524309ced684464f509f48eb8" name="ad88d5c5524309ced684464f509f48eb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad88d5c5524309ced684464f509f48eb8">&#9670;&#160;</a></span>itoa() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char * toy::itoa </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>destSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>base</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts an 8-bit unsigned integer to a C string representation in the specified base. </p>
<p>This function converts a given 8-bit unsigned integer value into its C string representation in the specified numerical base, storing the result in the provided destination buffer. Supports bases from 2 to 36.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>A pointer to the destination buffer where the converted C string is stored. </td></tr>
    <tr><td class="paramname">destSize</td><td>The size of the destination buffer in characters. </td></tr>
    <tr><td class="paramname">value</td><td>The 8-bit unsigned integer value to be converted. </td></tr>
    <tr><td class="paramname">base</td><td>The numerical base for the conversion (2-36). Common values: 2 (binary), 10 (decimal), 16 (hex).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the destination buffer containing the converted C string.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The function supports bases 2-36 with digits 0-9 and letters A-Z. </dd>
<dd>
Hexadecimal values use uppercase letters (A-F). </dd></dl>

</div>
</div>
<a id="ac7e6ab0756e81280710cbab536e6a030" name="ac7e6ab0756e81280710cbab536e6a030"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7e6ab0756e81280710cbab536e6a030">&#9670;&#160;</a></span>itoaImplementation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char * toy::itoaImplementation </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>destSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts an integer value to a string representation. </p>
<p>This function converts a given integer value into its string representation, storing the result in the provided destination buffer.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">type</td><td>The type of the integer value to be converted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>The destination buffer where the converted string is stored. </td></tr>
    <tr><td class="paramname">destSize</td><td>The size of the destination buffer. </td></tr>
    <tr><td class="paramname">value</td><td>The integer value to be converted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the destination buffer containing the converted string.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The function assumes that the destination buffer is large enough to hold the converted string. </dd>
<dd>
If the destination buffer size is 1, only a null terminator is written. </dd>
<dd>
The function reverses the string in-place. </dd></dl>

</div>
</div>
<a id="a356a3fceab84ce068ff702d19893708b" name="a356a3fceab84ce068ff702d19893708b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a356a3fceab84ce068ff702d19893708b">&#9670;&#160;</a></span>operator+() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t allocatedSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html">FixedString</a>&lt; allocatedSize &gt; toy::operator+ </td>
          <td>(</td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html">FixedString</a>&lt; allocatedSize &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenation operator for character and <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a>. </p>
<p>This operator creates a new <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> object by concatenating a single character with a <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a>. The result will contain the character from the left-hand side followed by the characters from the right-hand side.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The character to prepend to the <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a>. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> object containing the concatenated result.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Result size is sum of both input sizes, must not exceed allocated size. </dd></dl>

</div>
</div>
<a id="a2fef40d514c1a38e96d004926fe183d6" name="a2fef40d514c1a38e96d004926fe183d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fef40d514c1a38e96d004926fe183d6">&#9670;&#160;</a></span>operator+() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t allocatedSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html">FixedString</a>&lt; allocatedSize &gt; toy::operator+ </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html">FixedString</a>&lt; allocatedSize &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenation operator for C-string and <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a>. </p>
<p>This operator creates a new <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> object by concatenating a C-string with a <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a>. The result will contain the characters from the left-hand side followed by the characters from the right-hand side.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">allocatedSize</td><td>The size of the <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a>'s internal buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side C-string. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The <em class="arg">lhs</em> C-string must not be null and must be null-terminated.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> object containing the concatenated result.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Result size is sum of both input sizes, must not exceed allocated size. </dd></dl>

</div>
</div>
<a id="a326a560f0c3c0d12d9c7a8642d001e6d" name="a326a560f0c3c0d12d9c7a8642d001e6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a326a560f0c3c0d12d9c7a8642d001e6d">&#9670;&#160;</a></span>operator+() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t allocatedSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html">FixedString</a>&lt; allocatedSize &gt; toy::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html">FixedString</a>&lt; allocatedSize &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenation operator for <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> and character. </p>
<p>This operator creates a new <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> object by concatenating a <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> with a single character. The result will contain the characters from the left-hand side followed by the character from the right-hand side.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> object. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side character.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> object containing the concatenated result.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Result size is sum of both input sizes, must not exceed allocated size. </dd></dl>

</div>
</div>
<a id="affd1da1d9c8f6ce96223f0321ca1efef" name="affd1da1d9c8f6ce96223f0321ca1efef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affd1da1d9c8f6ce96223f0321ca1efef">&#9670;&#160;</a></span>operator+() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t allocatedSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html">FixedString</a>&lt; allocatedSize &gt; toy::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html">FixedString</a>&lt; allocatedSize &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenation operator for <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> and C-string. </p>
<p>This operator creates a new <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> object by concatenating a <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> with a C-string. The result will contain the characters from the left-hand side followed by the characters from the right-hand side.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">allocatedSize</td><td>The size of the <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a>'s internal buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> object. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side C-string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> object containing the concatenated result.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The <em class="arg">rhs</em> C-string must not be null and must be null-terminated.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Result size is sum of both input sizes, must not exceed allocated size. </dd></dl>

</div>
</div>
<a id="a66eecb2acd9da94710c77b796f60cb21" name="a66eecb2acd9da94710c77b796f60cb21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66eecb2acd9da94710c77b796f60cb21">&#9670;&#160;</a></span>operator+() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t allocatedSize, StringLike stringType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html">FixedString</a>&lt; allocatedSize &gt; toy::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html">FixedString</a>&lt; allocatedSize &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const stringType &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenation operator for <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> and <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> object. </p>
<p>This operator creates a new <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> object by concatenating a <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> with any <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> object. The result will contain the characters from the left-hand side followed by the characters from the right-hand side.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">allocatedSize</td><td>The size of the <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a>'s internal buffer. </td></tr>
    <tr><td class="paramname">stringType</td><td>The type of the <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> object. Must satisfy the <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> concept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> object. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> object containing the concatenated result.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Result size is sum of both input sizes, must not exceed allocated size. </dd></dl>

</div>
</div>
<a id="ac789c531cca9ded2d4866edf6d7b9ed5" name="ac789c531cca9ded2d4866edf6d7b9ed5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac789c531cca9ded2d4866edf6d7b9ed5">&#9670;&#160;</a></span>operator+() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t allocatedSize1, size_t allocatedSize2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html">FixedString</a>&lt; allocatedSize1 &gt; toy::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html">FixedString</a>&lt; allocatedSize1 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html">FixedString</a>&lt; allocatedSize2 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenation operator for two <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> objects. </p>
<p>This operator creates a new <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> object by concatenating the contents of two <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> objects. The result will contain the characters from the left-hand side followed by the characters from the right-hand side.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">allocatedSize1</td><td>The size of the first <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a>'s internal buffer. </td></tr>
    <tr><td class="paramname">allocatedSize2</td><td>The size of the second <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a>'s internal buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> object. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> object containing the concatenated result.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Result size is sum of both input sizes, must not exceed allocated size. </dd></dl>

</div>
</div>
<a id="a3e935013c7764b31202b25105a86cedd" name="a3e935013c7764b31202b25105a86cedd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e935013c7764b31202b25105a86cedd">&#9670;&#160;</a></span>operator+() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;StringLike stringType, size_t allocatedSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html">FixedString</a>&lt; allocatedSize &gt; toy::operator+ </td>
          <td>(</td>
          <td class="paramtype">const stringType &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html">FixedString</a>&lt; allocatedSize &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenation operator for <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> object and <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a>. </p>
<p>This operator creates a new <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> object by concatenating any <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> object with a <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a>. The result will contain the characters from the left-hand side followed by the characters from the right-hand side.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">stringType</td><td>The type of the <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> object. Must satisfy the <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> concept. </td></tr>
    <tr><td class="paramname">allocatedSize</td><td>The size of the <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a>'s internal buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> object. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> object containing the concatenated result.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Result size is sum of both input sizes, must not exceed allocated size. </dd></dl>

</div>
</div>
<a id="ab856389c5db41137391343498eb280a2" name="ab856389c5db41137391343498eb280a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab856389c5db41137391343498eb280a2">&#9670;&#160;</a></span>operator&lt;=&gt;() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::strong_ordering toy::operator&lt;=&gt; </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html">CStringView</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Three-way comparison operator for C string and <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html" title="Non-owning string view class for C-style strings.">CStringView</a>. </p>
<p>This operator provides a three-way comparison between a C string and a <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html" title="Non-owning string view class for C-style strings.">CStringView</a> object. It returns a std::strong_ordering value that indicates the relationship between the strings.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The C string to compare. </td></tr>
    <tr><td class="paramname">rhs</td><td>The <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html" title="Non-owning string view class for C-style strings.">CStringView</a> object to compare.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::strong_ordering::less if <em class="arg">lhs</em> is lexicographically less than <em class="arg">rhs</em>, std::strong_ordering::equal if they are equal, or std::strong_ordering::greater if <em class="arg">lhs</em> is lexicographically greater than <em class="arg">rhs</em>.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The <em class="arg">lhs</em> pointer must not be null.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The comparison is case-sensitive. </dd>
<dd>
The comparison is performed lexicographically character by character. </dd>
<dd>
Empty strings are considered equal.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>std::strong_ordering </dd>
<dd>
<a class="el" href="#a71f575fa58def2abe56c129ff51a3696" title="Equality comparison operator for C string and CStringView.">operator==(const char *, const CStringView &amp;)</a> </dd></dl>

</div>
</div>
<a id="a876dcc65c97b11b3e32289867cd11a56" name="a876dcc65c97b11b3e32289867cd11a56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a876dcc65c97b11b3e32289867cd11a56">&#9670;&#160;</a></span>operator&lt;=&gt;() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t allocatedSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::strong_ordering toy::operator&lt;=&gt; </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html">FixedString</a>&lt; allocatedSize &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Three-way comparison operator for C string and <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a>. </p>
<p>This operator provides a three-way comparison between a C string and a <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> object. It returns a std::strong_ordering value that indicates the relationship between the strings.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">allocatedSize</td><td>The size of the <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a>'s internal buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The C string to compare. </td></tr>
    <tr><td class="paramname">rhs</td><td>The <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> object to compare.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::strong_ordering::less if <em class="arg">lhs</em> is lexicographically less than <em class="arg">rhs</em>, std::strong_ordering::equal if they are equal, or std::strong_ordering::greater if <em class="arg">lhs</em> is lexicographically greater than <em class="arg">rhs</em>.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The <em class="arg">lhs</em> pointer must not be null.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The comparison is case-sensitive. </dd>
<dd>
The comparison is performed lexicographically character by character. </dd>
<dd>
Empty strings are considered equal.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>std::strong_ordering </dd>
<dd>
<a class="el" href="#a5568d083a1e1f805d9a0b9e22d3ea00d" title="Equality comparison operator for C string and FixedString.">operator==(const char *, const FixedString&lt;allocatedSize&gt; &amp;)</a> </dd></dl>

</div>
</div>
<a id="ad9aa91580633549a095c7ba702bee9d9" name="ad9aa91580633549a095c7ba702bee9d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9aa91580633549a095c7ba702bee9d9">&#9670;&#160;</a></span>operator&lt;=&gt;() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::strong_ordering toy::operator&lt;=&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html">CStringView</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Three-way comparison operator for <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html" title="Non-owning string view class for C-style strings.">CStringView</a> and C string. </p>
<p>This operator provides a three-way comparison between a <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html" title="Non-owning string view class for C-style strings.">CStringView</a> object and a C string. It returns a std::strong_ordering value that indicates the relationship between the strings.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html" title="Non-owning string view class for C-style strings.">CStringView</a> object to compare. </td></tr>
    <tr><td class="paramname">rhs</td><td>The C string to compare.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::strong_ordering::less if <em class="arg">lhs</em> is lexicographically less than <em class="arg">rhs</em>, std::strong_ordering::equal if they are equal, or std::strong_ordering::greater if <em class="arg">lhs</em> is lexicographically greater than <em class="arg">rhs</em>.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The <em class="arg">rhs</em> pointer must not be null.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The comparison is case-sensitive. </dd>
<dd>
The comparison is performed lexicographically character by character. </dd>
<dd>
Empty strings are considered equal.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>std::strong_ordering </dd>
<dd>
<a class="el" href="#a3761711b53e204a0f2871764d435fd35" title="Equality comparison operator for CStringView and C string.">operator==(const CStringView &amp;, const char *)</a> </dd></dl>

</div>
</div>
<a id="af959d0dc5fc118ec5c65f27143180021" name="af959d0dc5fc118ec5c65f27143180021"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af959d0dc5fc118ec5c65f27143180021">&#9670;&#160;</a></span>operator&lt;=&gt;() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::strong_ordering toy::operator&lt;=&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html">CStringView</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html">CStringView</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Three-way comparison operator for <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html" title="Non-owning string view class for C-style strings.">CStringView</a> objects. </p>
<p>This operator provides a three-way comparison between two <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html" title="Non-owning string view class for C-style strings.">CStringView</a> objects. It returns a std::strong_ordering value that indicates the relationship between the string views.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html" title="Non-owning string view class for C-style strings.">CStringView</a> object to compare. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html" title="Non-owning string view class for C-style strings.">CStringView</a> object to compare.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::strong_ordering::less if <em class="arg">lhs</em> is lexicographically less than <em class="arg">rhs</em>, std::strong_ordering::equal if they are equal, or std::strong_ordering::greater if <em class="arg">lhs</em> is lexicographically greater than <em class="arg">rhs</em>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The comparison is case-sensitive. </dd>
<dd>
The comparison is performed lexicographically character by character. </dd>
<dd>
Empty string views are considered equal.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>std::strong_ordering </dd>
<dd>
<a class="el" href="#a3a8c65476e352b7f64a0bf15ddc87747" title="Equality comparison operator for two CStringView objects.">operator==(const CStringView &amp;, const CStringView &amp;)</a> </dd></dl>

</div>
</div>
<a id="a2571fe89aa51139ddbb04bc1fdd0585c" name="a2571fe89aa51139ddbb04bc1fdd0585c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2571fe89aa51139ddbb04bc1fdd0585c">&#9670;&#160;</a></span>operator&lt;=&gt;() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;StringLike stringType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::strong_ordering toy::operator&lt;=&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html">CStringView</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const stringType &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Three-way comparison operator for <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html" title="Non-owning string view class for C-style strings.">CStringView</a> and <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> object. </p>
<p>This operator provides a three-way comparison between a <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html" title="Non-owning string view class for C-style strings.">CStringView</a> object and a <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> object. It returns a std::strong_ordering value that indicates the relationship between the strings.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">stringType</td><td>The type of the <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> object. Must satisfy the <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> concept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html" title="Non-owning string view class for C-style strings.">CStringView</a> object to compare. </td></tr>
    <tr><td class="paramname">rhs</td><td>The <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> object to compare.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::strong_ordering::less if <em class="arg">lhs</em> is lexicographically less than <em class="arg">rhs</em>, std::strong_ordering::equal if they are equal, or std::strong_ordering::greater if <em class="arg">lhs</em> is lexicographically greater than <em class="arg">rhs</em>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The comparison is case-sensitive. </dd>
<dd>
The comparison is performed lexicographically character by character. </dd>
<dd>
Empty strings are considered equal.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>std::strong_ordering </dd>
<dd>
<a class="el" href="#a3ae46d261b42cdcd0e59b395aebdc834" title="Equality comparison operator for CStringView and StringLike object.">operator==(const CStringView &amp;, const stringType &amp;)</a> </dd></dl>

</div>
</div>
<a id="a46515295e8eafc3e748d0c02ad5ecd70" name="a46515295e8eafc3e748d0c02ad5ecd70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46515295e8eafc3e748d0c02ad5ecd70">&#9670;&#160;</a></span>operator&lt;=&gt;() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t allocatedSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::strong_ordering toy::operator&lt;=&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html">FixedString</a>&lt; allocatedSize &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Three-way comparison operator for <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> and C string. </p>
<p>This operator provides a three-way comparison between a <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> object and a C string. It returns a std::strong_ordering value that indicates the relationship between the strings.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">allocatedSize</td><td>The size of the <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a>'s internal buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> object to compare. </td></tr>
    <tr><td class="paramname">rhs</td><td>The C string to compare.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::strong_ordering::less if <em class="arg">lhs</em> is lexicographically less than <em class="arg">rhs</em>, std::strong_ordering::equal if they are equal, or std::strong_ordering::greater if <em class="arg">lhs</em> is lexicographically greater than <em class="arg">rhs</em>.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The <em class="arg">rhs</em> pointer must not be null.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The comparison is case-sensitive. </dd>
<dd>
The comparison is performed lexicographically character by character. </dd>
<dd>
Empty strings are considered equal.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>std::strong_ordering </dd>
<dd>
<a class="el" href="#a6e7299d83e4f5d41d4951f84a44abdf4" title="Equality comparison operator for FixedString and C string.">operator==(const FixedString&lt;allocatedSize&gt; &amp;, const char *)</a> </dd></dl>

</div>
</div>
<a id="a600f056ee510aa623a7eec926077d0d2" name="a600f056ee510aa623a7eec926077d0d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a600f056ee510aa623a7eec926077d0d2">&#9670;&#160;</a></span>operator&lt;=&gt;() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t allocatedSize, StringLike stringType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::strong_ordering toy::operator&lt;=&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html">FixedString</a>&lt; allocatedSize &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const stringType &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Three-way comparison operator for <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> and <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> object. </p>
<p>This operator provides a three-way comparison between a <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> object and a <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> object. It returns a std::strong_ordering value that indicates the relationship between the strings.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">allocatedSize</td><td>The size of the <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a>'s internal buffer. </td></tr>
    <tr><td class="paramname">stringType</td><td>The type of the <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> object. Must satisfy the <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> concept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> object to compare. </td></tr>
    <tr><td class="paramname">rhs</td><td>The <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> object to compare.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::strong_ordering::less if <em class="arg">lhs</em> is lexicographically less than <em class="arg">rhs</em>, std::strong_ordering::equal if they are equal, or std::strong_ordering::greater if <em class="arg">lhs</em> is lexicographically greater than <em class="arg">rhs</em>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The comparison is case-sensitive. </dd>
<dd>
The comparison is performed lexicographically character by character. </dd>
<dd>
Empty strings are considered equal.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>std::strong_ordering </dd>
<dd>
<a class="el" href="#a718df287209b3adb957de9de67f9d863" title="Equality comparison operator for FixedString and StringLike object.">operator==(const FixedString&lt;allocatedSize&gt; &amp;, const stringType &amp;)</a> </dd></dl>

</div>
</div>
<a id="a3a3d16e98341489a2ba4e77d76e72e4f" name="a3a3d16e98341489a2ba4e77d76e72e4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a3d16e98341489a2ba4e77d76e72e4f">&#9670;&#160;</a></span>operator&lt;=&gt;() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t allocatedSize1, size_t allocatedSize2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::strong_ordering toy::operator&lt;=&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html">FixedString</a>&lt; allocatedSize1 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html">FixedString</a>&lt; allocatedSize2 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Three-way comparison operator for <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> objects. </p>
<p>This operator provides a three-way comparison between two <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> objects. It returns a std::strong_ordering value that indicates the relationship between the strings.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">allocatedSize1</td><td>The size of the first <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a>'s internal buffer. </td></tr>
    <tr><td class="paramname">allocatedSize2</td><td>The size of the second <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a>'s internal buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> object to compare. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> object to compare.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::strong_ordering::less if <em class="arg">lhs</em> is lexicographically less than <em class="arg">rhs</em>, std::strong_ordering::equal if they are equal, or std::strong_ordering::greater if <em class="arg">lhs</em> is lexicographically greater than <em class="arg">rhs</em>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The comparison is case-sensitive. </dd>
<dd>
The comparison is performed lexicographically character by character. </dd>
<dd>
Empty strings are considered equal.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>std::strong_ordering </dd>
<dd>
<a class="el" href="#acf758a094d8de5ef108ef3e984c37cf1" title="Equality comparison operator for two FixedString objects.">operator==(const FixedString&lt;allocatedSize1&gt; &amp;, const FixedString&lt;allocatedSize2&gt; &amp;)</a> </dd></dl>

</div>
</div>
<a id="ac327b00da21b55bf3cd1817280a52315" name="ac327b00da21b55bf3cd1817280a52315"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac327b00da21b55bf3cd1817280a52315">&#9670;&#160;</a></span>operator&lt;=&gt;() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;StringLike stringType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::strong_ordering toy::operator&lt;=&gt; </td>
          <td>(</td>
          <td class="paramtype">const stringType &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html">CStringView</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Three-way comparison operator for <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> object and <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html" title="Non-owning string view class for C-style strings.">CStringView</a>. </p>
<p>This operator provides a three-way comparison between a <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> object and a <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html" title="Non-owning string view class for C-style strings.">CStringView</a> object. It returns a std::strong_ordering value that indicates the relationship between the strings.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">stringType</td><td>The type of the <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> object. Must satisfy the <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> concept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> object to compare. </td></tr>
    <tr><td class="paramname">rhs</td><td>The <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html" title="Non-owning string view class for C-style strings.">CStringView</a> object to compare.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::strong_ordering::less if <em class="arg">lhs</em> is lexicographically less than <em class="arg">rhs</em>, std::strong_ordering::equal if they are equal, or std::strong_ordering::greater if <em class="arg">lhs</em> is lexicographically greater than <em class="arg">rhs</em>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The comparison is case-sensitive. </dd>
<dd>
The comparison is performed lexicographically character by character. </dd>
<dd>
Empty strings are considered equal.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>std::strong_ordering </dd>
<dd>
<a class="el" href="#ac0c288d93fdbf4dba71c4309203d9047" title="Equality comparison operator for StringLike object and CStringView.">operator==(const stringType &amp;, const CStringView &amp;)</a> </dd></dl>

</div>
</div>
<a id="a5d95d2f2437840de99f597f291f3d9f9" name="a5d95d2f2437840de99f597f291f3d9f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d95d2f2437840de99f597f291f3d9f9">&#9670;&#160;</a></span>operator&lt;=&gt;() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;StringLike stringType, size_t allocatedSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::strong_ordering toy::operator&lt;=&gt; </td>
          <td>(</td>
          <td class="paramtype">const stringType &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html">FixedString</a>&lt; allocatedSize &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Three-way comparison operator for <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> object and <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a>. </p>
<p>This operator provides a three-way comparison between a <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> object and a <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> object. It returns a std::strong_ordering value that indicates the relationship between the strings.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">stringType</td><td>The type of the <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> object. Must satisfy the <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> concept. </td></tr>
    <tr><td class="paramname">allocatedSize</td><td>The size of the <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a>'s internal buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> object to compare. </td></tr>
    <tr><td class="paramname">rhs</td><td>The <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> object to compare.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::strong_ordering::less if <em class="arg">lhs</em> is lexicographically less than <em class="arg">rhs</em>, std::strong_ordering::equal if they are equal, or std::strong_ordering::greater if <em class="arg">lhs</em> is lexicographically greater than <em class="arg">rhs</em>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The comparison is case-sensitive. </dd>
<dd>
The comparison is performed lexicographically character by character. </dd>
<dd>
Empty strings are considered equal.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>std::strong_ordering </dd>
<dd>
<a class="el" href="#a300e65bc1fbafecbcf63f47317198ec4" title="Equality comparison operator for StringLike object and FixedString.">operator==(const stringType &amp;, const FixedString&lt;allocatedSize&gt; &amp;)</a> </dd></dl>

</div>
</div>
<a id="a71f575fa58def2abe56c129ff51a3696" name="a71f575fa58def2abe56c129ff51a3696"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71f575fa58def2abe56c129ff51a3696">&#9670;&#160;</a></span>operator==() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool toy::operator== </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html">CStringView</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison operator for C string and <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html" title="Non-owning string view class for C-style strings.">CStringView</a>. </p>
<p>This operator compares a C string with a <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html" title="Non-owning string view class for C-style strings.">CStringView</a> object for equality.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The C string. </td></tr>
    <tr><td class="paramname">rhs</td><td>The <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html" title="Non-owning string view class for C-style strings.">CStringView</a> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if both strings have the same content, <code>false</code> otherwise.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The <em class="arg">lhs</em> pointer must not be null.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The comparison is case-sensitive. </dd>
<dd>
Empty strings are considered equal.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ab856389c5db41137391343498eb280a2" title="Three-way comparison operator for C string and CStringView.">operator&lt;=&gt;(const char *, const CStringView &amp;)</a> </dd></dl>

</div>
</div>
<a id="a5568d083a1e1f805d9a0b9e22d3ea00d" name="a5568d083a1e1f805d9a0b9e22d3ea00d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5568d083a1e1f805d9a0b9e22d3ea00d">&#9670;&#160;</a></span>operator==() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t allocatedSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool toy::operator== </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html">FixedString</a>&lt; allocatedSize &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison operator for C string and <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a>. </p>
<p>This operator compares a C string with a <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> object for equality.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">allocatedSize</td><td>The size of the <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a>'s internal buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The C string. </td></tr>
    <tr><td class="paramname">rhs</td><td>The <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if both strings have the same content, <code>false</code> otherwise.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The <em class="arg">lhs</em> pointer must not be null.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The comparison is case-sensitive. </dd>
<dd>
Empty strings are considered equal.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a876dcc65c97b11b3e32289867cd11a56" title="Three-way comparison operator for C string and FixedString.">operator&lt;=&gt;(const char *, const FixedString&lt;allocatedSize&gt; &amp;)</a> </dd></dl>

</div>
</div>
<a id="a3761711b53e204a0f2871764d435fd35" name="a3761711b53e204a0f2871764d435fd35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3761711b53e204a0f2871764d435fd35">&#9670;&#160;</a></span>operator==() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool toy::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html">CStringView</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison operator for <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html" title="Non-owning string view class for C-style strings.">CStringView</a> and C string. </p>
<p>This operator compares a <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html" title="Non-owning string view class for C-style strings.">CStringView</a> object with a C string for equality.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html" title="Non-owning string view class for C-style strings.">CStringView</a> object. </td></tr>
    <tr><td class="paramname">rhs</td><td>The C string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if both strings have the same content, <code>false</code> otherwise.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The <em class="arg">rhs</em> pointer must not be null.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The comparison is case-sensitive. </dd>
<dd>
Empty strings are considered equal.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ad9aa91580633549a095c7ba702bee9d9" title="Three-way comparison operator for CStringView and C string.">operator&lt;=&gt;(const CStringView &amp;, const char *)</a> </dd></dl>

</div>
</div>
<a id="a3a8c65476e352b7f64a0bf15ddc87747" name="a3a8c65476e352b7f64a0bf15ddc87747"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a8c65476e352b7f64a0bf15ddc87747">&#9670;&#160;</a></span>operator==() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool toy::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html">CStringView</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html">CStringView</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison operator for two <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html" title="Non-owning string view class for C-style strings.">CStringView</a> objects. </p>
<p>This operator compares two <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html" title="Non-owning string view class for C-style strings.">CStringView</a> objects for equality. The comparison is performed character by character.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html" title="Non-owning string view class for C-style strings.">CStringView</a> object. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html" title="Non-owning string view class for C-style strings.">CStringView</a> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if both strings view have the same content, <code>false</code> otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The comparison is case-sensitive. </dd>
<dd>
Empty string views are considered equal.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#af959d0dc5fc118ec5c65f27143180021" title="Three-way comparison operator for CStringView objects.">operator&lt;=&gt;(const CStringView &amp;, const CStringView &amp;)</a> </dd></dl>

</div>
</div>
<a id="a3ae46d261b42cdcd0e59b395aebdc834" name="a3ae46d261b42cdcd0e59b395aebdc834"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ae46d261b42cdcd0e59b395aebdc834">&#9670;&#160;</a></span>operator==() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;StringLike stringType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool toy::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html">CStringView</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const stringType &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison operator for <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html" title="Non-owning string view class for C-style strings.">CStringView</a> and <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> object. </p>
<p>This operator compares a <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html" title="Non-owning string view class for C-style strings.">CStringView</a> object with a <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> object for equality.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">stringType</td><td>The type of the <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> object. Must satisfy the <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> concept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html" title="Non-owning string view class for C-style strings.">CStringView</a> object. </td></tr>
    <tr><td class="paramname">rhs</td><td>The <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if both strings have the same content, <code>false</code> otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The comparison is case-sensitive. </dd>
<dd>
Empty strings are considered equal.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a2571fe89aa51139ddbb04bc1fdd0585c" title="Three-way comparison operator for CStringView and StringLike object.">operator&lt;=&gt;(const CStringView &amp;, const stringType &amp;)</a> </dd></dl>

</div>
</div>
<a id="a6e7299d83e4f5d41d4951f84a44abdf4" name="a6e7299d83e4f5d41d4951f84a44abdf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e7299d83e4f5d41d4951f84a44abdf4">&#9670;&#160;</a></span>operator==() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t allocatedSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool toy::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html">FixedString</a>&lt; allocatedSize &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison operator for <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> and C string. </p>
<p>This operator compares a <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> object with a C string for equality.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">allocatedSize</td><td>The size of the <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a>'s internal buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> object. </td></tr>
    <tr><td class="paramname">rhs</td><td>The C string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if both strings have the same content, <code>false</code> otherwise.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The <em class="arg">rhs</em> pointer must not be null.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The comparison is case-sensitive. </dd>
<dd>
Empty strings are considered equal.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a46515295e8eafc3e748d0c02ad5ecd70" title="Three-way comparison operator for FixedString and C string.">operator&lt;=&gt;(const FixedString&lt;allocatedSize&gt; &amp;, const char *)</a> </dd></dl>

</div>
</div>
<a id="a718df287209b3adb957de9de67f9d863" name="a718df287209b3adb957de9de67f9d863"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a718df287209b3adb957de9de67f9d863">&#9670;&#160;</a></span>operator==() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t allocatedSize, StringLike stringType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool toy::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html">FixedString</a>&lt; allocatedSize &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const stringType &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison operator for <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> and <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> object. </p>
<p>This operator compares a <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> object with a <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> object for equality.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">allocatedSize</td><td>The size of the <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a>'s internal buffer. </td></tr>
    <tr><td class="paramname">stringType</td><td>The type of the <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> object. Must satisfy the <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> concept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> object. </td></tr>
    <tr><td class="paramname">rhs</td><td>The <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if both strings have the same content, <code>false</code> otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The comparison is case-sensitive. </dd>
<dd>
Empty strings are considered equal.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a600f056ee510aa623a7eec926077d0d2" title="Three-way comparison operator for FixedString and StringLike object.">operator&lt;=&gt;(const FixedString&lt;allocatedSize&gt; &amp;, const stringType &amp;)</a> </dd></dl>

</div>
</div>
<a id="acf758a094d8de5ef108ef3e984c37cf1" name="acf758a094d8de5ef108ef3e984c37cf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf758a094d8de5ef108ef3e984c37cf1">&#9670;&#160;</a></span>operator==() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t allocatedSize1, size_t allocatedSize2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool toy::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html">FixedString</a>&lt; allocatedSize1 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html">FixedString</a>&lt; allocatedSize2 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison operator for two <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> objects. </p>
<p>This operator compares two <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> objects for equality. The comparison is performed character by character.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">allocatedSize1</td><td>The size of the first <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a>'s internal buffer. </td></tr>
    <tr><td class="paramname">allocatedSize2</td><td>The size of the second <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a>'s internal buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> object. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if both strings have the same content, <code>false</code> otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The comparison is case-sensitive. </dd>
<dd>
Empty strings are considered equal.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a3a3d16e98341489a2ba4e77d76e72e4f" title="Three-way comparison operator for FixedString objects.">operator&lt;=&gt;(const FixedString&lt;allocatedSize1&gt; &amp;, const FixedString&lt;allocatedSize2&gt; &amp;)</a> </dd></dl>

</div>
</div>
<a id="ac0c288d93fdbf4dba71c4309203d9047" name="ac0c288d93fdbf4dba71c4309203d9047"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0c288d93fdbf4dba71c4309203d9047">&#9670;&#160;</a></span>operator==() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;StringLike stringType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool toy::operator== </td>
          <td>(</td>
          <td class="paramtype">const stringType &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html">CStringView</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison operator for <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> object and <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html" title="Non-owning string view class for C-style strings.">CStringView</a>. </p>
<p>This operator compares a <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> object with a <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html" title="Non-owning string view class for C-style strings.">CStringView</a> object for equality.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">stringType</td><td>The type of the <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> object. Must satisfy the <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> concept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> object. </td></tr>
    <tr><td class="paramname">rhs</td><td>The <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html" title="Non-owning string view class for C-style strings.">CStringView</a> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if both strings have the same content, <code>false</code> otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The comparison is case-sensitive. </dd>
<dd>
Empty strings are considered equal.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ac327b00da21b55bf3cd1817280a52315" title="Three-way comparison operator for StringLike object and CStringView.">operator&lt;=&gt;(const stringType &amp;, const CStringView &amp;)</a> </dd></dl>

</div>
</div>
<a id="a300e65bc1fbafecbcf63f47317198ec4" name="a300e65bc1fbafecbcf63f47317198ec4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a300e65bc1fbafecbcf63f47317198ec4">&#9670;&#160;</a></span>operator==() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;StringLike stringType, size_t allocatedSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool toy::operator== </td>
          <td>(</td>
          <td class="paramtype">const stringType &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html">FixedString</a>&lt; allocatedSize &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison operator for <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> object and <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a>. </p>
<p>This operator compares a <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> object with a <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> object for equality.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">stringType</td><td>The type of the <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> object. Must satisfy the <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> concept. </td></tr>
    <tr><td class="paramname">allocatedSize</td><td>The size of the <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a>'s internal buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> object. </td></tr>
    <tr><td class="paramname">rhs</td><td>The <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if both strings have the same content, <code>false</code> otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The comparison is case-sensitive. </dd>
<dd>
Empty strings are considered equal.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a5d95d2f2437840de99f597f291f3d9f9" title="Three-way comparison operator for StringLike object and FixedString.">operator&lt;=&gt;(const stringType &amp;, const FixedString&lt;allocatedSize&gt; &amp;)</a> </dd></dl>

</div>
</div>
<a id="a2ad56b53b8cdbb022ce8ce3b2aa32503" name="a2ad56b53b8cdbb022ce8ce3b2aa32503"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ad56b53b8cdbb022ce8ce3b2aa32503">&#9670;&#160;</a></span>reverseString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char * toy::reverseString </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>count</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reverses a given C string in-place. </p>
<p>This function reverses a given C string in-place by swapping characters from both ends towards the center. It can be used to reverse a string of a specified length, or to reverse a null-terminated string when count is <code>0</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>A pointer to the C string to reverse. </td></tr>
    <tr><td class="paramname">count</td><td>The length of the C string to reverse (default: <code>0</code>).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the reversed C string (same as input pointer).</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The function modifies the original string directly. </dd>
<dd>
When count = <code>0</code>, the function calls strlen() to determine the string length. </dd></dl>

</div>
</div>
<a id="a5ab02021f4ca34e0d5b6a1b0172ebe95" name="a5ab02021f4ca34e0d5b6a1b0172ebe95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ab02021f4ca34e0d5b6a1b0172ebe95">&#9670;&#160;</a></span>utf8Len()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t toy::utf8Len </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>string</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of Unicode characters in a UTF-8 encoded C <em class="arg">string</em>. </p>
<p>This function counts the number of Unicode characters in a UTF-8 encoded C <em class="arg">string</em> by parsing UTF-8 sequences. It stops counting when the null character is encountered.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">string</td><td>A pointer to the source UTF-8 encoded C string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of Unicode characters in the C <em class="arg">string</em>, or 0 if the <em class="arg">string</em> is invalid or null.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The function validates UTF-8 sequences during counting. </dd>
<dd>
Multi-byte sequences (2-3 bytes) are counted as single Unicode characters. </dd>
<dd>
Invalid UTF-8 sequences cause the function to return 0. </dd></dl>

</div>
</div>
<a id="acf0d2ea5a12a30e6b7bdfaa9762b7ee3" name="acf0d2ea5a12a30e6b7bdfaa9762b7ee3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf0d2ea5a12a30e6b7bdfaa9762b7ee3">&#9670;&#160;</a></span>utf8toWChar() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">wchar_t * toy::utf8toWChar </td>
          <td>(</td>
          <td class="paramtype">wchar_t *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>destSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const</td>          <td class="paramname"><span class="paramname"><em>src</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a Unicode UTF-8 encoded C string to a wide character string. </p>
<p>This function translates a UTF-8 encoded C string into a wide character string. The conversion stops when the source string ends or the destination buffer is filled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>A pointer to the destination buffer where the converted wide character string will be stored. </td></tr>
    <tr><td class="paramname">destSize</td><td>The size of the destination buffer in wide characters (not bytes). </td></tr>
    <tr><td class="paramname">src</td><td>A pointer to the source UTF-8 encoded C string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the destination wide character string, or nullptr if the destination buffer is invalid.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The destination buffer must be valid and have sufficient capacity. </dd>
<dd>
The source C string must be a valid UTF-8 encoded string.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The destination string is null-terminated. </dd>
<dd>
The function returns <code>nullptr</code> on buffer overflow or invalid input.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Only BMP ( 0xFFFF) characters are supported by design; 4-byte UTF-8 sequences are not produced. </dd>
<dd>
This is an inline wrapper around the main utf8toWChar function. </dd>
<dd>
The function automatically determines the source string length. </dd></dl>

</div>
</div>
<a id="a5ee65428f52c52934cf358eec39c55aa" name="a5ee65428f52c52934cf358eec39c55aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ee65428f52c52934cf358eec39c55aa">&#9670;&#160;</a></span>utf8toWChar() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">wchar_t * toy::utf8toWChar </td>
          <td>(</td>
          <td class="paramtype">wchar_t *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>destSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a Unicode UTF-8 encoded C string to a wide character string with character count limit. </p>
<p>This function translates a UTF-8 encoded C string into a wide character string stored in the destination buffer. The conversion stops when the specified number of characters have been converted, the destination buffer is filled, or the source string ends.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>A pointer to the destination buffer where the converted wide character string will be stored. </td></tr>
    <tr><td class="paramname">destSize</td><td>The size of the destination buffer in wide characters (not bytes). </td></tr>
    <tr><td class="paramname">src</td><td>A pointer to the source UTF-8 encoded C string. </td></tr>
    <tr><td class="paramname">count</td><td>The maximum number of characters to convert from the source string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the destination wide character string, or nullptr if the destination buffer is invalid.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The destination buffer must be valid and have sufficient capacity. </dd>
<dd>
The source C string must be a valid UTF-8 encoded string. </dd>
<dd>
The count parameter must be reasonable (typically  source string length).</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The destination string is null-terminated. </dd>
<dd>
The function returns <code>nullptr</code> on buffer overflow or invalid input.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Only BMP ( 0xFFFF) characters are supported by design; 4-byte UTF-8 sequences are not produced. </dd>
<dd>
The function handles UTF-8 validation and skips invalid sequences. </dd>
<dd>
If count exceeds the available characters, conversion stops at the end of the source string. </dd></dl>

</div>
</div>
<a id="ad77806ddefe069afcd095c3d1ef37391" name="ad77806ddefe069afcd095c3d1ef37391"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad77806ddefe069afcd095c3d1ef37391">&#9670;&#160;</a></span>utf8toWChar() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;StringLike stringType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">wchar_t * toy::utf8toWChar </td>
          <td>(</td>
          <td class="paramtype">wchar_t *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>destSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const stringType &amp;</td>          <td class="paramname"><span class="paramname"><em>src</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a Unicode UTF-8 encoded <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> object to a wide character string. </p>
<p>This template function translates a UTF-8 encoded <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> object into a wide character string. The conversion stops when the source string ends or the destination buffer is filled.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">stringType</td><td>The type of the source string. Must satisfy the <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> concept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>A pointer to the destination buffer where the converted wide character string will be stored. </td></tr>
    <tr><td class="paramname">destSize</td><td>The size of the destination buffer in wide characters (not bytes). </td></tr>
    <tr><td class="paramname">src</td><td>A reference to a <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> object with UTF-8 encoded content.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the destination wide character string, or nullptr if the destination buffer is invalid.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The destination buffer must be valid and have sufficient capacity. </dd>
<dd>
The source <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> object must provide UTF-8 encoded string data via c_str().</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The destination string is null-terminated. </dd>
<dd>
The function returns <code>nullptr</code> on buffer overflow or invalid input.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Only BMP ( 0xFFFF) characters are supported by design; 4-byte UTF-8 sequences are not produced. </dd>
<dd>
This template works with std::string, <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a>, and other string-like types. </dd></dl>

</div>
</div>
<a id="a10d90a55c9c7b54190a445f8fabaa599" name="a10d90a55c9c7b54190a445f8fabaa599"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10d90a55c9c7b54190a445f8fabaa599">&#9670;&#160;</a></span>utoaImplementation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char * toy::utoaImplementation </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>destSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>base</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts an unsigned integer value to a string representation in a specified base. </p>
<p>This function converts a given unsigned integer value into its string representation in the specified numerical base, storing the result in the provided destination buffer. The resulting string is reversed in place and null-terminated.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">type</td><td>The type of the unsigned integer value to be converted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>The destination buffer where the converted string is stored. </td></tr>
    <tr><td class="paramname">destSize</td><td>The size of the destination buffer. </td></tr>
    <tr><td class="paramname">value</td><td>The unsigned integer value to be converted. </td></tr>
    <tr><td class="paramname">base</td><td>The numerical base for the conversion, e.g., 10 for decimal, 16 for hexadecimal.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the destination buffer containing the converted string.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The function assumes that the destination buffer is large enough to hold the converted string. </dd>
<dd>
If the destination buffer size is 1, only a null terminator is written. </dd>
<dd>
The base must be between 2 and 36 inclusive. </dd></dl>

</div>
</div>
<a id="a008aa42596921d995b66340139fd3cfb" name="a008aa42596921d995b66340139fd3cfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a008aa42596921d995b66340139fd3cfb">&#9670;&#160;</a></span>wcharToUtf8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char * toy::wcharToUtf8 </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>destSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wchar_t *</td>          <td class="paramname"><span class="paramname"><em>src</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a Unicode wide character C string to a UTF-8 encoded string. </p>
<p>This function translates a wide character C string into a UTF-8 encoded string stored in the destination buffer. The conversion stops when the source string ends or the destination buffer is filled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>A pointer to the destination buffer where the converted UTF-8 encoded string will be stored. </td></tr>
    <tr><td class="paramname">destSize</td><td>The size of the destination buffer in bytes (not wide characters). </td></tr>
    <tr><td class="paramname">src</td><td>A pointer to the source wide character C string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the destination UTF-8 encoded string, or nullptr if the destination buffer is invalid.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The destination buffer must be valid and have sufficient capacity. </dd>
<dd>
The source C string must be a valid wide character string. </dd>
<dd>
The destination buffer size should account for potential UTF-8 expansion.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The destination string is null-terminated. </dd>
<dd>
The function returns <code>nullptr</code> on buffer overflow or invalid input.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The function handles wide character to UTF-8 conversion efficiently. </dd>
<dd>
UTF-8 sequences may require 1-3 bytes per wide character. </dd></dl>

</div>
</div>
<a name="doc-var-members" id="doc-var-members"></a><h2 id="header-doc-var-members" class="groupheader">Variable Documentation</h2>
<a id="ae9d26c716cca917004e820be15f483dd" name="ae9d26c716cca917004e820be15f483dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9d26c716cca917004e820be15f483dd">&#9670;&#160;</a></span>_ansiDigits</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::array&lt; char, 36 &gt; toy::_ansiDigits</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{{</div>
<div class="line">  <span class="charliteral">&#39;0&#39;</span>, <span class="charliteral">&#39;1&#39;</span>, <span class="charliteral">&#39;2&#39;</span>, <span class="charliteral">&#39;3&#39;</span>, <span class="charliteral">&#39;4&#39;</span>, <span class="charliteral">&#39;5&#39;</span>, <span class="charliteral">&#39;6&#39;</span>, <span class="charliteral">&#39;7&#39;</span>, <span class="charliteral">&#39;8&#39;</span>, <span class="charliteral">&#39;9&#39;</span>, <span class="charliteral">&#39;A&#39;</span>, <span class="charliteral">&#39;B&#39;</span>, <span class="charliteral">&#39;C&#39;</span>, <span class="charliteral">&#39;D&#39;</span>, <span class="charliteral">&#39;E&#39;</span>, <span class="charliteral">&#39;F&#39;</span>, <span class="charliteral">&#39;G&#39;</span>, <span class="charliteral">&#39;H&#39;</span>,</div>
<div class="line">  <span class="charliteral">&#39;I&#39;</span>, <span class="charliteral">&#39;J&#39;</span>, <span class="charliteral">&#39;K&#39;</span>, <span class="charliteral">&#39;L&#39;</span>, <span class="charliteral">&#39;M&#39;</span>, <span class="charliteral">&#39;N&#39;</span>, <span class="charliteral">&#39;O&#39;</span>, <span class="charliteral">&#39;P&#39;</span>, <span class="charliteral">&#39;Q&#39;</span>, <span class="charliteral">&#39;R&#39;</span>, <span class="charliteral">&#39;S&#39;</span>, <span class="charliteral">&#39;T&#39;</span>, <span class="charliteral">&#39;U&#39;</span>, <span class="charliteral">&#39;V&#39;</span>, <span class="charliteral">&#39;W&#39;</span>, <span class="charliteral">&#39;X&#39;</span>, <span class="charliteral">&#39;Y&#39;</span>, <span class="charliteral">&#39;Z&#39;</span>,</div>
<div class="line">}}</div>
</div><!-- fragment -->
<p>ANSI digit lookup table for base conversion. </p>
<p>This lookup table contains the characters used for representing digits in different numerical bases. It supports bases from 2 to 36, using digits '0'-'9' and 'A'-'Z'.</p>
<dl class="section note"><dt>Note</dt><dd>The table contains 36 characters: '0'-'9' and 'A'-'Z'. </dd></dl>

</div>
</div>
<a id="ad5a24715635e389733d2bd51420d0cce" name="ad5a24715635e389733d2bd51420d0cce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5a24715635e389733d2bd51420d0cce">&#9670;&#160;</a></span>_crc16Table</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;uint16_t, 256&gt; toy::_crc16Table</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{{</div>
<div class="line">  0x0000, 0xC0C1, 0xC181, 0x0140, 0xC301, 0x03C0, 0x0280, 0xC241, 0xC601, 0x06C0, 0x0780, 0xC741, 0x0500, 0xC5C1,</div>
<div class="line">  0xC481, 0x0440, 0xCC01, 0x0CC0, 0x0D80, 0xCD41, 0x0F00, 0xCFC1, 0xCE81, 0x0E40, 0x0A00, 0xCAC1, 0xCB81, 0x0B40,</div>
<div class="line">  0xC901, 0x09C0, 0x0880, 0xC841, 0xD801, 0x18C0, 0x1980, 0xD941, 0x1B00, 0xDBC1, 0xDA81, 0x1A40, 0x1E00, 0xDEC1,</div>
<div class="line">  0xDF81, 0x1F40, 0xDD01, 0x1DC0, 0x1C80, 0xDC41, 0x1400, 0xD4C1, 0xD581, 0x1540, 0xD701, 0x17C0, 0x1680, 0xD641,</div>
<div class="line">  0xD201, 0x12C0, 0x1380, 0xD341, 0x1100, 0xD1C1, 0xD081, 0x1040, 0xF001, 0x30C0, 0x3180, 0xF141, 0x3300, 0xF3C1,</div>
<div class="line">  0xF281, 0x3240, 0x3600, 0xF6C1, 0xF781, 0x3740, 0xF501, 0x35C0, 0x3480, 0xF441, 0x3C00, 0xFCC1, 0xFD81, 0x3D40,</div>
<div class="line">  0xFF01, 0x3FC0, 0x3E80, 0xFE41, 0xFA01, 0x3AC0, 0x3B80, 0xFB41, 0x3900, 0xF9C1, 0xF881, 0x3840, 0x2800, 0xE8C1,</div>
<div class="line">  0xE981, 0x2940, 0xEB01, 0x2BC0, 0x2A80, 0xEA41, 0xEE01, 0x2EC0, 0x2F80, 0xEF41, 0x2D00, 0xEDC1, 0xEC81, 0x2C40,</div>
<div class="line">  0xE401, 0x24C0, 0x2580, 0xE541, 0x2700, 0xE7C1, 0xE681, 0x2640, 0x2200, 0xE2C1, 0xE381, 0x2340, 0xE101, 0x21C0,</div>
<div class="line">  0x2080, 0xE041, 0xA001, 0x60C0, 0x6180, 0xA141, 0x6300, 0xA3C1, 0xA281, 0x6240, 0x6600, 0xA6C1, 0xA781, 0x6740,</div>
<div class="line">  0xA501, 0x65C0, 0x6480, 0xA441, 0x6C00, 0xACC1, 0xAD81, 0x6D40, 0xAF01, 0x6FC0, 0x6E80, 0xAE41, 0xAA01, 0x6AC0,</div>
<div class="line">  0x6B80, 0xAB41, 0x6900, 0xA9C1, 0xA881, 0x6840, 0x7800, 0xB8C1, 0xB981, 0x7940, 0xBB01, 0x7BC0, 0x7A80, 0xBA41,</div>
<div class="line">  0xBE01, 0x7EC0, 0x7F80, 0xBF41, 0x7D00, 0xBDC1, 0xBC81, 0x7C40, 0xB401, 0x74C0, 0x7580, 0xB541, 0x7700, 0xB7C1,</div>
<div class="line">  0xB681, 0x7640, 0x7200, 0xB2C1, 0xB381, 0x7340, 0xB101, 0x71C0, 0x7080, 0xB041, 0x5000, 0x90C1, 0x9181, 0x5140,</div>
<div class="line">  0x9301, 0x53C0, 0x5280, 0x9241, 0x9601, 0x56C0, 0x5780, 0x9741, 0x5500, 0x95C1, 0x9481, 0x5440, 0x9C01, 0x5CC0,</div>
<div class="line">  0x5D80, 0x9D41, 0x5F00, 0x9FC1, 0x9E81, 0x5E40, 0x5A00, 0x9AC1, 0x9B81, 0x5B40, 0x9901, 0x59C0, 0x5880, 0x9841,</div>
<div class="line">  0x8801, 0x48C0, 0x4980, 0x8941, 0x4B00, 0x8BC1, 0x8A81, 0x4A40, 0x4E00, 0x8EC1, 0x8F81, 0x4F40, 0x8D01, 0x4DC0,</div>
<div class="line">  0x4C80, 0x8C41, 0x4400, 0x84C1, 0x8581, 0x4540, 0x8701, 0x47C0, 0x4680, 0x8641, 0x8201, 0x42C0, 0x4380, 0x8341,</div>
<div class="line">  0x4100, 0x81C1, 0x8081, 0x4040,</div>
<div class="line">}}</div>
</div><!-- fragment -->
<p>CRC-16 lookup table using IBM/ARC polynomial (0x8005). </p>
<p>This lookup table contains precomputed CRC-16 values for all possible byte values (0-255). The table is generated using the IBM/ARC polynomial (x + x + x + 1, 0x8005). Using this table allows for O(1) CRC calculation per byte instead of O(16) bit-by-bit calculation. </p>

</div>
</div>
<a id="adea4ce7523cb7c07e3df1712514c1298" name="adea4ce7523cb7c07e3df1712514c1298"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adea4ce7523cb7c07e3df1712514c1298">&#9670;&#160;</a></span>_crc32Table</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;uint32_t, 256&gt; toy::_crc32Table</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>CRC-32 lookup table using IEEE 802.3 polynomial (0x04C11DB7). </p>
<p>This lookup table contains precomputed CRC-32 values for all possible byte values (0-255). The table is generated using the IEEE 802.3 polynomial (x + x + x + x + x + x + x + x + x + x + x + x + x + x + 1, 0x04C11DB7). Using this table allows for O(1) CRC calculation per byte instead of O(32) bit-by-bit calculation. </p>

</div>
</div>
<a id="a63a8d4228d33c90f9ef1684c10c07b37" name="a63a8d4228d33c90f9ef1684c10c07b37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63a8d4228d33c90f9ef1684c10c07b37">&#9670;&#160;</a></span>_crc8Table</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;uint8_t, 256&gt; toy::_crc8Table</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{{</div>
<div class="line">  0x00, 0x5E, 0xBC, 0xE2, 0x61, 0x3F, 0xDD, 0x83, 0xC2, 0x9C, 0x7E, 0x20, 0xA3, 0xFD, 0x1F, 0x41, 0x9D, 0xC3, 0x21,</div>
<div class="line">  0x7F, 0xFC, 0xA2, 0x40, 0x1E, 0x5F, 0x01, 0xE3, 0xBD, 0x3E, 0x60, 0x82, 0xDC, 0x23, 0x7D, 0x9F, 0xC1, 0x42, 0x1C,</div>
<div class="line">  0xFE, 0xA0, 0xE1, 0xBF, 0x5D, 0x03, 0x80, 0xDE, 0x3C, 0x62, 0xBE, 0xE0, 0x02, 0x5C, 0xDF, 0x81, 0x63, 0x3D, 0x7C,</div>
<div class="line">  0x22, 0xC0, 0x9E, 0x1D, 0x43, 0xA1, 0xFF, 0x46, 0x18, 0xFA, 0xA4, 0x27, 0x79, 0x9B, 0xC5, 0x84, 0xDA, 0x38, 0x66,</div>
<div class="line">  0xE5, 0xBB, 0x59, 0x07, 0xDB, 0x85, 0x67, 0x39, 0xBA, 0xE4, 0x06, 0x58, 0x19, 0x47, 0xA5, 0xFB, 0x78, 0x26, 0xC4,</div>
<div class="line">  0x9A, 0x65, 0x3B, 0xD9, 0x87, 0x04, 0x5A, 0xB8, 0xE6, 0xA7, 0xF9, 0x1B, 0x45, 0xC6, 0x98, 0x7A, 0x24, 0xF8, 0xA6,</div>
<div class="line">  0x44, 0x1A, 0x99, 0xC7, 0x25, 0x7B, 0x3A, 0x64, 0x86, 0xD8, 0x5B, 0x05, 0xE7, 0xB9, 0x8C, 0xD2, 0x30, 0x6E, 0xED,</div>
<div class="line">  0xB3, 0x51, 0x0F, 0x4E, 0x10, 0xF2, 0xAC, 0x2F, 0x71, 0x93, 0xCD, 0x11, 0x4F, 0xAD, 0xF3, 0x70, 0x2E, 0xCC, 0x92,</div>
<div class="line">  0xD3, 0x8D, 0x6F, 0x31, 0xB2, 0xEC, 0x0E, 0x50, 0xAF, 0xF1, 0x13, 0x4D, 0xCE, 0x90, 0x72, 0x2C, 0x6D, 0x33, 0xD1,</div>
<div class="line">  0x8F, 0x0C, 0x52, 0xB0, 0xEE, 0x32, 0x6C, 0x8E, 0xD0, 0x53, 0x0D, 0xEF, 0xB1, 0xF0, 0xAE, 0x4C, 0x12, 0x91, 0xCF,</div>
<div class="line">  0x2D, 0x73, 0xCA, 0x94, 0x76, 0x28, 0xAB, 0xF5, 0x17, 0x49, 0x08, 0x56, 0xB4, 0xEA, 0x69, 0x37, 0xD5, 0x8B, 0x57,</div>
<div class="line">  0x09, 0xEB, 0xB5, 0x36, 0x68, 0x8A, 0xD4, 0x95, 0xCB, 0x29, 0x77, 0xF4, 0xAA, 0x48, 0x16, 0xE9, 0xB7, 0x55, 0x0B,</div>
<div class="line">  0x88, 0xD6, 0x34, 0x6A, 0x2B, 0x75, 0x97, 0xC9, 0x4A, 0x14, 0xF6, 0xA8, 0x74, 0x2A, 0xC8, 0x96, 0x15, 0x4B, 0xA9,</div>
<div class="line">  0xF7, 0xB6, 0xE8, 0x0A, 0x54, 0xD7, 0x89, 0x6B, 0x35,</div>
<div class="line">}}</div>
</div><!-- fragment -->
<p>CRC-8 lookup table using Dallas/Maxim polynomial (0x31). </p>
<p>This lookup table contains precomputed CRC-8 values for all possible byte values (0-255). The table is generated using the Dallas/Maxim polynomial (x + x + x + 1, 0x31). Using this table allows for O(1) CRC calculation per byte instead of O(8) bit-by-bit calculation. </p>

</div>
</div>
<a id="a6aa717a5991fe2ff2553833f1d626178" name="a6aa717a5991fe2ff2553833f1d626178"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6aa717a5991fe2ff2553833f1d626178">&#9670;&#160;</a></span>_exponentTable</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;uint32_t, 32&gt; toy::_exponentTable</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{{</div>
<div class="line">  0xF0BDC21A, 0x3DA137D5, 0x9DC5ADA8, 0x2863C1F5, 0x6765C793, 0x1A784379, 0x43C33C19, 0xAD78EBC5,</div>
<div class="line">  0x2C68AF0B, 0x71AFD498, 0x1D1A94A2, 0x4A817C80, 0xBEBC2000, 0x30D40000, 0x7D000000, 0x20000000,</div>
<div class="line">  0x51EB851E, 0xD1B71758, 0x35AFE535, 0x89705F41, 0x232F3302, 0x5A126E1A, 0xE69594BE, 0x3B07929F,</div>
<div class="line">  0x971DA050, 0x26AF8533, 0x63090312, 0xFD87B5F2, 0x40E75996, 0xA6274BBD, 0x2A890926, 0x6CE3EE76,</div>
<div class="line">}}</div>
</div><!-- fragment -->
<p>Precomputed exponent lookup table for efficient binary-to-decimal floating-point conversion. </p>
<p>This lookup table contains 32 precomputed values used to convert IEEE-754 binary floating-point exponents to decimal exponents during float-to-string conversion. The table maps groups of 8 binary exponent values to precomputed multipliers that approximate the conversion from binary to decimal representation.</p>
<dl class="section note"><dt>Note</dt><dd>The table is indexed by exponent / 8, where exponent is the 8-bit IEEE-754 exponent field (0-255). Each entry is a 32-bit fixed-point multiplier used to compute the decimal mantissa efficiently. </dd>
<dd>
This table enables O(1) lookup instead of expensive runtime power-of-10 calculations, significantly improving the performance of floating-point number formatting. </dd></dl>

</div>
</div>
<a id="a4a12924c5030e6b26a105cce437a95a9" name="a4a12924c5030e6b26a105cce437a95a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a12924c5030e6b26a105cce437a95a9">&#9670;&#160;</a></span>_utf8CharSizeTable</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;uint8_t, 256&gt; toy::_utf8CharSizeTable</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{{</div>
<div class="line">  0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,</div>
<div class="line">  0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,</div>
<div class="line">  0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,</div>
<div class="line">  0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,</div>
<div class="line">  0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,</div>
<div class="line">  0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,</div>
<div class="line">  0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,</div>
<div class="line"> </div>
<div class="line">  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,</div>
<div class="line">  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,</div>
<div class="line">  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,</div>
<div class="line">  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,</div>
<div class="line"> </div>
<div class="line">  0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,</div>
<div class="line">  0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,</div>
<div class="line"> </div>
<div class="line">  0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,</div>
<div class="line"> </div>
<div class="line">  0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x05, 0x05, 0x05, 0x05, 0x06, 0x06, 0x07, 0x08,</div>
<div class="line">}}</div>
</div><!-- fragment -->
<p>UTF-8 character size lookup table for efficient UTF-8 parsing. </p>
<p>This lookup table contains precomputed UTF-8 character sizes for all possible byte values (0-255). The table maps each byte to the number of bytes required to represent a complete UTF-8 character sequence. Using this table allows for O(1) UTF-8 character size determination instead of O(n) bit-by-bit analysis.</p>
<dl class="section note"><dt>Note</dt><dd>Values: 0x01 = 1-byte ASCII character, 0x02-0x04 = multi-byte UTF-8 sequence, 0x00 = invalid/incomplete. </dd></dl>

</div>
</div>
<a id="a15a8263a5364e1ff581cf08613b9647f" name="a15a8263a5364e1ff581cf08613b9647f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15a8263a5364e1ff581cf08613b9647f">&#9670;&#160;</a></span>wcharInUtf8MaxSize</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t toy::wcharInUtf8MaxSize = 3</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maximum UTF-8 bytes required for BMP characters. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="../../d4/da9/namespacetoy.html">toy</a></li>
    <li class="footer">Generated on <span class="timestamp"></span> for ToyGine2 by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.15.0 </li>
  </ul>
</div>
</body>
</html>
