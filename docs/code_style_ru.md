# Руководство по стилю кода

Этот документ описывает соглашения о стиле кодирования, используемые во всем проекте ToyGine2. Весь код должен соответствовать этим руководящим принципам для обеспечения единообразия, читаемости и поддерживаемости.

## Содержание

1. [Стандарт C++](#стандарт-c)
2. [Форматирование](#форматирование)
3. [Соглашения об именовании](#соглашения-об-именовании)
4. [Организация кода](#организация-кода)
5. [Современные возможности C++](#современные-возможности-c)
6. [Безопасность исключений](#безопасность-исключений)
7. [Документация](#документация)
8. [Подключения и заголовки](#подключения-и-заголовки)
9. [Лучшие практики](#лучшие-практики)

---

## Стандарт C++

- **Минимум**: C++23 или новее
- Используйте современные возможности C++ там, где это уместно
- Предпочитайте стандартные библиотечные средства пользовательским реализациям
- Используйте концепты C++20 для ограничений шаблонов

```cpp
template <StringLike stringType>
constexpr FixedString(const stringType & string) noexcept;

template <typename InputIterator>
  requires(!std::is_integral_v<InputIterator>)
FixedVector(InputIterator first, InputIterator last);
```

---

## Форматирование

### Отступы и пробелы

- Используйте **2 пробела** для отступов (не табуляции)
- Максимальная ширина строки: **120 символов**
- Используйте пробелы, а не табуляции
- Замыкающие пробелы не допускаются

### Скобки

- Используйте **присоединенный стиль скобок** (открывающая скобка на той же строке)
- Размещайте закрывающую скобку на отдельной строке, выровненную с открывающим утверждением

```cpp
// Хорошо
class FixedString {
public:
  constexpr FixedString() noexcept;
};

// Плохо
class FixedString
{
public:
  constexpr FixedString() noexcept
  {
  }
};
```

### Выравнивание указателей и ссылок

- Используйте **среднее выравнивание** для указателей и ссылок

```cpp
// Хорошо
type * pointer;
type & reference;
const type * const_pointer;

// Плохо
type* pointer;
type &reference;
```

### Бинарные операторы

- Разрывайте строку **перед** бинарными операторами, когда строка превышает ограничение по ширине

```cpp
// Хорошо
result = value1
  + value2
  + value3;

// Плохо
result = value1 +
  value2 +
  value3;
```

### Пустые строки

- Максимум **1 пустая строка** между разделами кода
- Нет пустых строк в начале блоков

---

## Соглашения об именовании

### Классы и структуры

- Используйте **PascalCase** для имен классов и структур

```cpp
class FixedString;
class Vector2D;
struct Version;
```

### Параметры шаблонов

- Используйте **camelCase** для имен параметров шаблонов

```cpp
template <std::size_t allocatedSize>
template <typename type>
template <StringLike stringType>
```

### Переменные-члены

- Используйте **префикс подчеркивания** для приватных переменных-членов

```cpp
class FixedString {
private:
  char _data[allocatedSize];
  std::size_t _size;
};
```

### Функции и методы

- Используйте **camelCase** для имен функций и методов
- Следуйте соглашениям об именовании STL, где это применимо (например, `push_back`, `find_first_of`)

```cpp
constexpr void push_back(char character) noexcept;
constexpr std::size_t find_first_of(char character, std::size_t position = 0) const noexcept;
```

### Псевдонимы типов

- Используйте **snake_case** с суффиксом `_type` для псевдонимов типов

```cpp
using value_type = type;
using size_type = std::size_t;
using difference_type = std::ptrdiff_t;
using reference = value_type &;
using const_reference = const value_type &;
```

### Константы и перечисления

- Используйте **UPPER_SNAKE_CASE** для констант и значений перечислений

```cpp
static constexpr std::size_t npos = std::size_t(-1);
enum class Color { RED, GREEN, BLUE };
```

### Пространства имен

- Используйте **нижний регистр** для имен пространств имен
- Используйте вложенные пространства имен для логической организации

```cpp
namespace toy {
  namespace math {
    class Vector2D;
  }
  namespace app {
    struct Version;
  }
}
```

---

## Организация кода

### Защита подключений

- Используйте **верхний регистр** для защитных макросов с полным путем

```cpp
#ifndef INCLUDE_CORE_FIXED_STRING_HPP_
#define INCLUDE_CORE_FIXED_STRING_HPP_
// ... код ...
#endif  // INCLUDE_CORE_FIXED_STRING_HPP_
```

### Структура файлов

- Файлы заголовков: `.hpp`
- Файлы реализации: `.cpp` или `.inl` (для реализаций шаблонов)
- Организуйте подключения в следующем порядке:
  1. Соответствующий заголовок (для файлов `.cpp`)
  2. Заголовки стандартной библиотеки (`<...>`)
  3. Заголовки сторонних библиотек
  4. Заголовки проекта (`"..."`)

### Модификаторы доступа

- Используйте смещение модификатора доступа **-2** (согласовано с clang-format)
- Порядок: `public`, `protected`, `private`

```cpp
class FixedString {
public:
  // Публичный интерфейс

private:
  // Приватная реализация
};
```

---

## Современные возможности C++

### constexpr

- Используйте `constexpr` широко для вычислений во время компиляции
- Предпочитайте конструкторы и методы `constexpr`, когда это возможно

```cpp
constexpr FixedString() noexcept;
constexpr std::size_t size() const noexcept;
constexpr bool empty() const noexcept;
```

### noexcept

- Помечайте все функции, которые не выбрасывают исключения, как `noexcept`
- Этот проект не использует исключения - все операции помечены как `noexcept`

```cpp
constexpr FixedString(const FixedString & string) noexcept;
constexpr FixedString & operator=(const FixedString & string) noexcept;
```

### Атрибуты

- Используйте `[[nodiscard]]` для функций, возвращаемые значения которых не должны игнорироваться

```cpp
[[nodiscard]] constexpr std::size_t size() const noexcept;
[[nodiscard]] constexpr bool empty() const noexcept;
[[nodiscard]] constexpr const char * data() const noexcept;
```

### Концепты (C++20)

- Используйте концепты для ограничения параметров шаблонов
- Определяйте переиспользуемые концепты для общих паттернов

```cpp
template <typename T>
concept StringLike = requires(T t) {
  { t.size() } -> std::convertible_to<std::size_t>;
  { t.data() } -> std::convertible_to<const char *>;
};
```

### Псевдонимы типов

- Предпочитайте объявления `using` вместо `typedef`

```cpp
// Хорошо
using size_type = std::size_t;
using value_type = type;

// Избегайте
typedef std::size_t size_type;
```

---

## Безопасность исключений

- **Без исключений**: Все операции помечены как `noexcept`
- Используйте утверждения для проверки предусловий в отладочных сборках
- Нарушение предусловий в релизных сборках приводит к неопределенному поведению
- Документируйте предусловия с помощью тегов `\pre` в комментариях Doxygen

```cpp
constexpr char & at(std::size_t offset) noexcept {
  assert(offset < _size);
  return _data[offset];
}
```

---

## Документация

### Комментарии Doxygen

- Используйте `/*! ... */` для многострочных блоков документации
- Используйте `///` для однострочных комментариев к переменным-членам
- Всегда документируйте публичные API
- Следуйте [Руководству по стилю Doxygen](codestyle/DOXYGEN_STYLE_GUIDE_RU.md)
- Используйте [Шаблоны классов Doxygen](codestyle/DOXYGEN_CLASS_TEMPLATE_RU.md) при документировании классов

```cpp
/*!
  \brief Возвращает размер строки.

  Этот метод возвращает текущее количество символов в строке,
  исключая завершающий нулевой символ.

  \return Количество символов в строке.

  \see length()
*/
[[nodiscard]] constexpr std::size_t size() const noexcept;
```

### Шаблоны документации

Проект предоставляет шаблоны и руководства по стилю для документации Doxygen:

- **[Руководство по стилю Doxygen](codestyle/DOXYGEN_STYLE_GUIDE_RU.md)**: Полное руководство, охватывающее все аспекты документации Doxygen, включая правила форматирования, использование тегов, документацию параметров и лучшие практики.
- **[Шаблон класса Doxygen](codestyle/DOXYGEN_CLASS_TEMPLATE_RU.md)**: Готовые к использованию шаблоны для документирования классов, включая обычные классы, шаблонные классы, структуры и упрощенные версии. Включает примеры для всех общих разделов документации.

При создании новой документации:

1. Обращайтесь к [Руководству по стилю Doxygen](codestyle/DOXYGEN_STYLE_GUIDE_RU.md) для правил форматирования и соглашений
2. Используйте шаблоны из [Шаблона класса Doxygen](codestyle/DOXYGEN_CLASS_TEMPLATE_RU.md) в качестве отправной точки для документации классов
3. Следуйте чеклисту в Руководстве по стилю для обеспечения полноты

### Документация переменных-членов

- Используйте встроенные комментарии `//!<` для псевдонимов типов и простых переменных-членов

```cpp
using value_type = type;  //!< Тип элементов, хранящихся в векторе.
using size_type = std::size_t;  //!< Тип, используемый для размера и вместимости вектора.
```

---

## Подключения и заголовки

### Документация файла заголовка

- Каждый файл заголовка должен начинаться с блока документации файла

```cpp
/*!
  \file   fixed_string.hpp
  \brief  Класс строки-шаблона с буфером символов фиксированного размера.
*/
```

### Порядок подключений

1. Системные заголовки (`<iostream>`, `<vector>`, и т.д.)
2. Заголовки сторонних библиотек (`<SDL.h>`, и т.д.)
3. Заголовки проекта (`"core/fixed_string.hpp"`)

### Предварительные объявления

- Предпочитайте предварительные объявления, когда это возможно, для уменьшения зависимостей компиляции

---

## Лучшие практики

### Константная корректность

- Помечайте методы как `const`, когда они не изменяют состояние объекта
- Используйте константные ссылки для параметров, которые не должны изменяться

```cpp
constexpr std::size_t size() const noexcept;
constexpr const char * data() const noexcept;
constexpr bool operator==(const FixedString & other) const noexcept;
```

### Инициализация членов по умолчанию

- Используйте инициализацию членов по умолчанию, когда это уместно
- Предпочитайте списки инициализации конструкторов

```cpp
template <std::size_t allocatedSize>
constexpr FixedString() noexcept
  : _data{'\0'}
  , _size(0) {}
```

### Статические утверждения

- Используйте `static_assert` для проверок во время компиляции

```cpp
template <std::size_t allocatedSize>
class FixedString {
  static_assert(allocatedSize > 0, "FixedString capacity must be greater than zero.");
};
```

### Явные конструкторы

- Помечайте конструкторы с одним параметром как `explicit` для предотвращения неявных преобразований

```cpp
explicit FixedString(const char * string) noexcept;
explicit FixedVector(size_type count);
```

### По умолчанию и удаление

- Используйте `= default` для конструкторов и деструкторов по умолчанию, когда это уместно
- Используйте `= delete` для предотвращения нежелательных операций

```cpp
constexpr ~FixedString() noexcept = default;
FixedString(FixedString &&) = delete;
FixedString & operator=(FixedString &&) = delete;
```

### Циклы на основе диапазонов

- Предпочитайте циклы на основе диапазонов при итерации по контейнерам

```cpp
for (const auto & element : vector) {
  // Обработка элемента
}
```

### Автоматический вывод типа

- Используйте `auto`, когда тип очевиден или многословен
- Избегайте `auto`, когда это снижает читаемость

```cpp
// Хорошо
auto size = string.size();
const auto & element = vector[0];

// Менее понятно - предпочтите явный тип
auto result = complexFunction();  // Какой тип у result?
```

---

## Инструменты и автоматизация

### Clang-Format

- Проект использует `.clang-format` для автоматического форматирования кода
- Запускайте `clang-format` перед коммитом кода
- Конфигурация основана на стандарте C++20 с отступами в 2 пробела

### Чеклист перед коммитом

Перед коммитом кода убедитесь:

- [ ] Код отформатирован с помощью `clang-format`
- [ ] Все публичные API документированы с помощью Doxygen
- [ ] Все функции помечены как `constexpr`, где это уместно
- [ ] Все функции помечены как `noexcept`, где это уместно
- [ ] `[[nodiscard]]` используется для функций, возвращаемые значения которых не должны игнорироваться
- [ ] Соглашения об именовании соблюдены
- [ ] Нет предупреждений компилятора
- [ ] Код следует рекомендациям по организации

---

## Резюме

Ключевые принципы:

- **Единообразие**: Следуйте установленным соглашениям во всем кодовом базисе
- **Современный C++**: Используйте возможности C++23 там, где это уместно
- **Безопасность**: Помечайте функции как `constexpr` и `noexcept`, где это применимо
- **Ясность**: Пишите самодокументируемый код с осмысленными именами
- **Документация**: Документируйте все публичные API с помощью Doxygen

Это руководство по стилю должно соблюдаться для всего нового кода и использоваться в качестве справочника при обновлении существующего кода. По вопросам или предложениям обращайтесь к сопровождающим проекта.
