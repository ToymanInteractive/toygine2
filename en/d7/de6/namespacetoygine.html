<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ToyGine2: toygine Namespace Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ToyGine2
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('d7/de6/namespacetoygine.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">toygine Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:dd/d55/namespacetoygine_1_1assertion" id="r_dd/d55/namespacetoygine_1_1assertion"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d55/namespacetoygine_1_1assertion.html">assertion</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/db8/classtoygine_1_1FixString.html">FixString</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aa91ac406f0e472aee86388b14a415e6a" id="r_aa91ac406f0e472aee86388b14a415e6a"><td class="memItemLeft" align="right" valign="top">wchar_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/de6/namespacetoygine.html#aa91ac406f0e472aee86388b14a415e6a">utf8toWChar</a> (wchar_t *dest, std::size_t destSize, char const *src)</td></tr>
<tr class="memdesc:aa91ac406f0e472aee86388b14a415e6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a Unicode UTF-8 encoded string to a wide character string.  <br /></td></tr>
<tr class="separator:aa91ac406f0e472aee86388b14a415e6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a811e04b05bc9831faa0a74301d2a9e27" id="r_a811e04b05bc9831faa0a74301d2a9e27"><td class="memTemplParams" colspan="2">template&lt;typename stringType &gt; </td></tr>
<tr class="memitem:a811e04b05bc9831faa0a74301d2a9e27"><td class="memTemplItemLeft" align="right" valign="top">wchar_t *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d7/de6/namespacetoygine.html#a811e04b05bc9831faa0a74301d2a9e27">utf8toWChar</a> (wchar_t *dest, std::size_t destSize, stringType const &amp;src)</td></tr>
<tr class="memdesc:a811e04b05bc9831faa0a74301d2a9e27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a Unicode UTF-8 encoded string to a wide character string.  <br /></td></tr>
<tr class="separator:a811e04b05bc9831faa0a74301d2a9e27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55968ac28a4437ca63b6dbc6f216b4a4" id="r_a55968ac28a4437ca63b6dbc6f216b4a4"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/de6/namespacetoygine.html#a55968ac28a4437ca63b6dbc6f216b4a4">reverseString</a> (char *str, std::size_t count=0)</td></tr>
<tr class="memdesc:a55968ac28a4437ca63b6dbc6f216b4a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses a given string in-place.  <br /></td></tr>
<tr class="separator:a55968ac28a4437ca63b6dbc6f216b4a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48637673e063354265967ce84b7031a1" id="r_a48637673e063354265967ce84b7031a1"><td class="memItemLeft" align="right" valign="top">wchar_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/de6/namespacetoygine.html#a48637673e063354265967ce84b7031a1">utf8toWChar</a> (wchar_t *dest, std::size_t destSize, char const *src, std::size_t count)</td></tr>
<tr class="memdesc:a48637673e063354265967ce84b7031a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a Unicode UTF-8 encoded string to a wide character string.  <br /></td></tr>
<tr class="separator:a48637673e063354265967ce84b7031a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6173680fd5b35f1df4f1e8a818adc3e9" id="r_a6173680fd5b35f1df4f1e8a818adc3e9"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/de6/namespacetoygine.html#a6173680fd5b35f1df4f1e8a818adc3e9">wcharToUtf8</a> (char *dest, std::size_t destSize, wchar_t const *src)</td></tr>
<tr class="memdesc:a6173680fd5b35f1df4f1e8a818adc3e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a Unicode wide character string to a UTF-8 encoded string.  <br /></td></tr>
<tr class="separator:a6173680fd5b35f1df4f1e8a818adc3e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eddb55e8f5eb1c4035cfd8a2de1896f" id="r_a5eddb55e8f5eb1c4035cfd8a2de1896f"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/de6/namespacetoygine.html#a5eddb55e8f5eb1c4035cfd8a2de1896f">utf8len</a> (const char *str)</td></tr>
<tr class="memdesc:a5eddb55e8f5eb1c4035cfd8a2de1896f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of Unicode characters in a UTF-8 encoded string.  <br /></td></tr>
<tr class="separator:a5eddb55e8f5eb1c4035cfd8a2de1896f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4de05ddfe7a0c7944b525afd5a8bd7a6" id="r_a4de05ddfe7a0c7944b525afd5a8bd7a6"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/de6/namespacetoygine.html#a4de05ddfe7a0c7944b525afd5a8bd7a6">itoa</a> (char *dest, std::size_t destSize, std::int8_t value)</td></tr>
<tr class="memdesc:a4de05ddfe7a0c7944b525afd5a8bd7a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an integer value to a string representation.  <br /></td></tr>
<tr class="separator:a4de05ddfe7a0c7944b525afd5a8bd7a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3d3283bae4c448a285a24612546c757" id="r_af3d3283bae4c448a285a24612546c757"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/de6/namespacetoygine.html#af3d3283bae4c448a285a24612546c757">itoa</a> (char *dest, std::size_t destSize, std::int16_t value)</td></tr>
<tr class="memdesc:af3d3283bae4c448a285a24612546c757"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an integer value to a string representation.  <br /></td></tr>
<tr class="separator:af3d3283bae4c448a285a24612546c757"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff7862134d3413778cda2e84ca0f51ea" id="r_aff7862134d3413778cda2e84ca0f51ea"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/de6/namespacetoygine.html#aff7862134d3413778cda2e84ca0f51ea">itoa</a> (char *dest, std::size_t destSize, std::int32_t value)</td></tr>
<tr class="memdesc:aff7862134d3413778cda2e84ca0f51ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an integer value to a string representation.  <br /></td></tr>
<tr class="separator:aff7862134d3413778cda2e84ca0f51ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5daba732dac1d55a5d62dd6c9094acce" id="r_a5daba732dac1d55a5d62dd6c9094acce"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/de6/namespacetoygine.html#a5daba732dac1d55a5d62dd6c9094acce">itoa</a> (char *dest, std::size_t destSize, std::int64_t value)</td></tr>
<tr class="memdesc:a5daba732dac1d55a5d62dd6c9094acce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an integer value to a string representation.  <br /></td></tr>
<tr class="separator:a5daba732dac1d55a5d62dd6c9094acce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11c6df1cb36b16151cfbdf33778146f4" id="r_a11c6df1cb36b16151cfbdf33778146f4"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/de6/namespacetoygine.html#a11c6df1cb36b16151cfbdf33778146f4">itoa</a> (char *dest, std::size_t destSize, std::uint8_t value, unsigned base)</td></tr>
<tr class="memdesc:a11c6df1cb36b16151cfbdf33778146f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an unsigned integer to a string representation in the specified base.  <br /></td></tr>
<tr class="separator:a11c6df1cb36b16151cfbdf33778146f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62367f074b5177b48bfd418eff5633b3" id="r_a62367f074b5177b48bfd418eff5633b3"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/de6/namespacetoygine.html#a62367f074b5177b48bfd418eff5633b3">itoa</a> (char *dest, std::size_t destSize, std::uint16_t value, unsigned base)</td></tr>
<tr class="memdesc:a62367f074b5177b48bfd418eff5633b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an unsigned integer to a string representation in the specified base.  <br /></td></tr>
<tr class="separator:a62367f074b5177b48bfd418eff5633b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83414059f4d06a2cbf91449b61f529eb" id="r_a83414059f4d06a2cbf91449b61f529eb"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/de6/namespacetoygine.html#a83414059f4d06a2cbf91449b61f529eb">itoa</a> (char *dest, std::size_t destSize, std::uint32_t value, unsigned base)</td></tr>
<tr class="memdesc:a83414059f4d06a2cbf91449b61f529eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an unsigned integer to a string representation in the specified base.  <br /></td></tr>
<tr class="separator:a83414059f4d06a2cbf91449b61f529eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7ba2bb019bcd4337d37b5842bdf6c7b" id="r_aa7ba2bb019bcd4337d37b5842bdf6c7b"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/de6/namespacetoygine.html#aa7ba2bb019bcd4337d37b5842bdf6c7b">itoa</a> (char *dest, std::size_t destSize, std::uint64_t value, unsigned base)</td></tr>
<tr class="memdesc:aa7ba2bb019bcd4337d37b5842bdf6c7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an unsigned integer to a string representation in the specified base.  <br /></td></tr>
<tr class="separator:aa7ba2bb019bcd4337d37b5842bdf6c7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aeee65facd5e81d83259a89b18e9c7c" id="r_a4aeee65facd5e81d83259a89b18e9c7c"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/de6/namespacetoygine.html#a4aeee65facd5e81d83259a89b18e9c7c">ftoa</a> (char *dest, std::size_t destSize, float value, std::size_t precision=7)</td></tr>
<tr class="memdesc:a4aeee65facd5e81d83259a89b18e9c7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a floating-point number to its string representation in a specified precision.  <br /></td></tr>
<tr class="separator:a4aeee65facd5e81d83259a89b18e9c7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f65fa6e46f8a594b805986e41d4b344" id="r_a2f65fa6e46f8a594b805986e41d4b344"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/de6/namespacetoygine.html#a2f65fa6e46f8a594b805986e41d4b344">ftoa</a> (char *dest, std::size_t destSize, double value, std::size_t precision=15)</td></tr>
<tr class="memdesc:a2f65fa6e46f8a594b805986e41d4b344"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a floating-point number to its string representation in a specified precision.  <br /></td></tr>
<tr class="separator:a2f65fa6e46f8a594b805986e41d4b344"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af36eec789fd0f6ea91b7d1ec48b25b48" id="r_af36eec789fd0f6ea91b7d1ec48b25b48"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/de6/namespacetoygine.html#af36eec789fd0f6ea91b7d1ec48b25b48">formatNumberString</a> (char *buffer, std::size_t bufferSize, char const *groupingSeparator)</td></tr>
<tr class="memdesc:af36eec789fd0f6ea91b7d1ec48b25b48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format number string.  <br /></td></tr>
<tr class="separator:af36eec789fd0f6ea91b7d1ec48b25b48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aece45bc773865fbc01013939bcfaeeb2" id="r_aece45bc773865fbc01013939bcfaeeb2"><td class="memTemplParams" colspan="2">template&lt;typename type &gt; </td></tr>
<tr class="memitem:aece45bc773865fbc01013939bcfaeeb2"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d7/de6/namespacetoygine.html#aece45bc773865fbc01013939bcfaeeb2">integerToSymbols</a> (char *dest, std::size_t destSize, type value, unsigned base)</td></tr>
<tr class="memdesc:aece45bc773865fbc01013939bcfaeeb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an integer value to a string representation in a specified base.  <br /></td></tr>
<tr class="separator:aece45bc773865fbc01013939bcfaeeb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8a75c65ac8550ff63ac340e1f2572ef" id="r_af8a75c65ac8550ff63ac340e1f2572ef"><td class="memTemplParams" colspan="2">template&lt;typename type &gt; </td></tr>
<tr class="memitem:af8a75c65ac8550ff63ac340e1f2572ef"><td class="memTemplItemLeft" align="right" valign="top">char *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d7/de6/namespacetoygine.html#af8a75c65ac8550ff63ac340e1f2572ef">itoaImplementation</a> (char *dest, std::size_t destSize, type value)</td></tr>
<tr class="memdesc:af8a75c65ac8550ff63ac340e1f2572ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an integer value to a string representation.  <br /></td></tr>
<tr class="separator:af8a75c65ac8550ff63ac340e1f2572ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f7769364a3fa922049ef7ca0b749e12" id="r_a0f7769364a3fa922049ef7ca0b749e12"><td class="memTemplParams" colspan="2">template&lt;typename type &gt; </td></tr>
<tr class="memitem:a0f7769364a3fa922049ef7ca0b749e12"><td class="memTemplItemLeft" align="right" valign="top">char *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d7/de6/namespacetoygine.html#a0f7769364a3fa922049ef7ca0b749e12">utoaImplementation</a> (char *dest, std::size_t destSize, type value, unsigned base)</td></tr>
<tr class="memdesc:a0f7769364a3fa922049ef7ca0b749e12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an unsigned integer value to a string representation in a specified base.  <br /></td></tr>
<tr class="separator:a0f7769364a3fa922049ef7ca0b749e12"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a33eb5fc4e7682e297375d2ee2fbb7742" id="r_a33eb5fc4e7682e297375d2ee2fbb7742"><td class="memItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/de6/namespacetoygine.html#a33eb5fc4e7682e297375d2ee2fbb7742">wcharInUtf8MaxSize</a> = 3</td></tr>
<tr class="memdesc:a33eb5fc4e7682e297375d2ee2fbb7742"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum UTF-8 bytes for BMP characters (only BMP supported by design)  <br /></td></tr>
<tr class="separator:a33eb5fc4e7682e297375d2ee2fbb7742"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="af36eec789fd0f6ea91b7d1ec48b25b48" name="af36eec789fd0f6ea91b7d1ec48b25b48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af36eec789fd0f6ea91b7d1ec48b25b48">&#9670;&#160;</a></span>formatNumberString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void toygine::formatNumberString </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>bufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>groupingSeparator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Format number string. </p>
<p>This function inserts a grouping separator (e.g., a comma or a space) into a number string. The separator is inserted every three digits, starting from the right. The function assumes that the destination buffer is large enough to hold the modified string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The destination buffer where the modified string is stored. </td></tr>
    <tr><td class="paramname">bufferSize</td><td>The size of the destination buffer. </td></tr>
    <tr><td class="paramname">groupingSeparator</td><td>The grouping separator to be inserted into the string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The function validates available capacity and returns early without modification if the buffer is too small. The groupingSeparator must not be null and should not exceed 8 characters. </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">  514</span>                                                                                             {</div>
<div class="line"><span class="lineno">  515</span>  <a class="code hl_define" href="../../dd/d9e/linux_2platform__config_8hpp.html#ae03d9a55f6cbc55ebd9d6b25c2e8889c">assert_message</a>(buffer != <span class="keyword">nullptr</span> &amp;&amp; bufferSize &gt; 0, <span class="stringliteral">&quot;The destination buffer must not be null.&quot;</span>);</div>
<div class="line"><span class="lineno">  516</span>  <a class="code hl_define" href="../../dd/d9e/linux_2platform__config_8hpp.html#ae03d9a55f6cbc55ebd9d6b25c2e8889c">assert_message</a>(groupingSeparator != <span class="keyword">nullptr</span> &amp;&amp; std::strlen(groupingSeparator) &lt;= 8,</div>
<div class="line"><span class="lineno">  517</span>                 <span class="stringliteral">&quot;The grouping separator must not be null and must not exceed 8 characters.&quot;</span>);</div>
<div class="line"><span class="lineno">  518</span> </div>
<div class="line"><span class="lineno">  519</span>  <span class="keywordflow">if</span> (*buffer == <span class="charliteral">&#39;-&#39;</span> || *buffer == <span class="charliteral">&#39;+&#39;</span>) {</div>
<div class="line"><span class="lineno">  520</span>    ++buffer;</div>
<div class="line"><span class="lineno">  521</span>    --bufferSize;</div>
<div class="line"><span class="lineno">  522</span>  }</div>
<div class="line"><span class="lineno">  523</span> </div>
<div class="line"><span class="lineno">  524</span>  <span class="keyword">const</span> <span class="keyword">auto</span> groupSeparatorLen = std::strlen(groupingSeparator);</div>
<div class="line"><span class="lineno">  525</span>  <span class="keyword">const</span> <span class="keyword">auto</span> ansiStringLen = std::strlen(buffer);</div>
<div class="line"><span class="lineno">  526</span>  std::size_t digitsCount = 0;</div>
<div class="line"><span class="lineno">  527</span>  <span class="keywordflow">while</span> (buffer[digitsCount] &gt;= <span class="charliteral">&#39;0&#39;</span> &amp;&amp; buffer[digitsCount] &lt;= <span class="charliteral">&#39;9&#39;</span>)</div>
<div class="line"><span class="lineno">  528</span>    ++digitsCount;</div>
<div class="line"><span class="lineno">  529</span> </div>
<div class="line"><span class="lineno">  530</span>  <span class="keyword">auto</span> groupSeparatorsCount = (digitsCount - 1U) / 3U;</div>
<div class="line"><span class="lineno">  531</span>  <span class="keyword">const</span> <span class="keyword">auto</span> requiredSize = ansiStringLen + groupSeparatorsCount * groupSeparatorLen;</div>
<div class="line"><span class="lineno">  532</span>  <a class="code hl_define" href="../../dd/d9e/linux_2platform__config_8hpp.html#ae03d9a55f6cbc55ebd9d6b25c2e8889c">assert_message</a>(requiredSize &lt; bufferSize, <span class="stringliteral">&quot;Buffer size is to low.&quot;</span>);</div>
<div class="line"><span class="lineno">  533</span>  <span class="keywordflow">if</span> (requiredSize &gt;= bufferSize)</div>
<div class="line"><span class="lineno">  534</span>    <span class="keywordflow">return</span>;</div>
<div class="line"><span class="lineno">  535</span> </div>
<div class="line"><span class="lineno">  536</span>  buffer[ansiStringLen + groupSeparatorsCount * groupSeparatorLen] = <span class="charliteral">&#39;\0&#39;</span>;</div>
<div class="line"><span class="lineno">  537</span> </div>
<div class="line"><span class="lineno">  538</span>  <span class="keywordflow">if</span> (digitsCount != (ansiStringLen - 1))</div>
<div class="line"><span class="lineno">  539</span>    std::memmove(buffer + (digitsCount + groupSeparatorsCount * groupSeparatorLen), buffer + digitsCount,</div>
<div class="line"><span class="lineno">  540</span>                 ansiStringLen - digitsCount);</div>
<div class="line"><span class="lineno">  541</span> </div>
<div class="line"><span class="lineno">  542</span>  <span class="keyword">auto</span> scanChars = digitsCount;</div>
<div class="line"><span class="lineno">  543</span>  <span class="keywordflow">while</span> (groupSeparatorsCount &gt; 0) {</div>
<div class="line"><span class="lineno">  544</span>    std::memmove(buffer + (scanChars + groupSeparatorsCount * groupSeparatorLen - 3), buffer + (scanChars - 3), 3);</div>
<div class="line"><span class="lineno">  545</span>    <span class="keyword">const</span> <span class="keyword">auto</span> destBufferShift = scanChars + (groupSeparatorsCount - 1) * groupSeparatorLen - 3;</div>
<div class="line"><span class="lineno">  546</span>    std::memcpy(buffer + destBufferShift, groupingSeparator, groupSeparatorLen);</div>
<div class="line"><span class="lineno">  547</span>    scanChars -= 3;</div>
<div class="line"><span class="lineno">  548</span>    --groupSeparatorsCount;</div>
<div class="line"><span class="lineno">  549</span>  }</div>
<div class="line"><span class="lineno">  550</span>}</div>
<div class="ttc" id="alinux_2platform__config_8hpp_html_ae03d9a55f6cbc55ebd9d6b25c2e8889c"><div class="ttname"><a href="../../dd/d9e/linux_2platform__config_8hpp.html#ae03d9a55f6cbc55ebd9d6b25c2e8889c">assert_message</a></div><div class="ttdeci">#define assert_message(x, message)</div><div class="ttdef"><b>Definition</b> platform_config.hpp:63</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a2f65fa6e46f8a594b805986e41d4b344" name="a2f65fa6e46f8a594b805986e41d4b344"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f65fa6e46f8a594b805986e41d4b344">&#9670;&#160;</a></span>ftoa() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * toygine::ftoa </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>destSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>precision</em> = <code>15</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a floating-point number to its string representation in a specified precision. </p>
<p>This function converts a given floating-point number into its string representation, storing the result in the provided destination buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>The destination buffer where the converted string is stored. </td></tr>
    <tr><td class="paramname">destSize</td><td>The size of the destination buffer. </td></tr>
    <tr><td class="paramname">value</td><td>The floating-point number to be converted. </td></tr>
    <tr><td class="paramname">precision</td><td>The precision (digits after the decimal point). For IEEE-754 f64, practical precision is ~15–17 digits.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the destination buffer containing the converted string.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The function assumes that the destination buffer is large enough to hold the converted string. If the destination buffer size is 1, only a null terminator is written. The function does not support subnormals. </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">  488</span>                                                                                {</div>
<div class="line"><span class="lineno">  489</span>  <a class="code hl_define" href="../../dd/d9e/linux_2platform__config_8hpp.html#ae03d9a55f6cbc55ebd9d6b25c2e8889c">assert_message</a>(dest != <span class="keyword">nullptr</span> &amp;&amp; destSize &gt; 0, <span class="stringliteral">&quot;The destination buffer must not be null.&quot;</span>);</div>
<div class="line"><span class="lineno">  490</span>  <span class="keywordflow">if</span> (dest == <span class="keyword">nullptr</span> || destSize == 0)</div>
<div class="line"><span class="lineno">  491</span>    <span class="keywordflow">return</span> dest;</div>
<div class="line"><span class="lineno">  492</span> </div>
<div class="line"><span class="lineno">  493</span>  *dest = <span class="charliteral">&#39;\0&#39;</span>;</div>
<div class="line"><span class="lineno">  494</span>  <span class="keywordflow">if</span> (destSize == 1)</div>
<div class="line"><span class="lineno">  495</span>    <span class="keywordflow">return</span> dest;</div>
<div class="line"><span class="lineno">  496</span> </div>
<div class="line"><span class="lineno">  497</span>  <span class="keyword">const</span> std::size_t bufferSize = 128;</div>
<div class="line"><span class="lineno">  498</span>  <span class="keywordtype">char</span> buffer[bufferSize + 1];</div>
<div class="line"><span class="lineno">  499</span> </div>
<div class="line"><span class="lineno">  500</span>  <span class="keyword">auto</span> exp10 = ftoa64Engine(buffer, value, precision);</div>
<div class="line"><span class="lineno">  501</span>  <span class="keywordflow">if</span> (exp10 == 0x7FF) {</div>
<div class="line"><span class="lineno">  502</span><span class="preprocessor">#if defined(_CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES)</span></div>
<div class="line"><span class="lineno">  503</span>    strcpy_s(dest, destSize, buffer);</div>
<div class="line"><span class="lineno">  504</span><span class="preprocessor">#else </span><span class="comment">// defined(_CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES)</span></div>
<div class="line"><span class="lineno">  505</span>    strncpy(dest, buffer, destSize - 1);</div>
<div class="line"><span class="lineno">  506</span><span class="preprocessor">#endif </span><span class="comment">// defined(_CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES)</span></div>
<div class="line"><span class="lineno">  507</span>  } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno">  508</span>    floatPostProcess(dest, buffer, bufferSize, exp10, precision);</div>
<div class="line"><span class="lineno">  509</span>  }</div>
<div class="line"><span class="lineno">  510</span> </div>
<div class="line"><span class="lineno">  511</span>  <span class="keywordflow">return</span> dest;</div>
<div class="line"><span class="lineno">  512</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a4aeee65facd5e81d83259a89b18e9c7c" name="a4aeee65facd5e81d83259a89b18e9c7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4aeee65facd5e81d83259a89b18e9c7c">&#9670;&#160;</a></span>ftoa() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * toygine::ftoa </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>destSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>precision</em> = <code>7</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a floating-point number to its string representation in a specified precision. </p>
<p>This function converts a given floating-point number into its string representation, storing the result in the provided destination buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>The destination buffer where the converted string is stored. </td></tr>
    <tr><td class="paramname">destSize</td><td>The size of the destination buffer. </td></tr>
    <tr><td class="paramname">value</td><td>The floating-point number to be converted. </td></tr>
    <tr><td class="paramname">precision</td><td>The precision (digits after the decimal point). For IEEE-754 f32, practical precision is ~7–9 digits.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the destination buffer containing the converted string.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The function assumes that the destination buffer is large enough to hold the converted string. If the destination buffer size is 1, only a null terminator is written. The function does not support subnormals. </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">  462</span>                                                                               {</div>
<div class="line"><span class="lineno">  463</span>  <a class="code hl_define" href="../../dd/d9e/linux_2platform__config_8hpp.html#ae03d9a55f6cbc55ebd9d6b25c2e8889c">assert_message</a>(dest != <span class="keyword">nullptr</span> &amp;&amp; destSize &gt; 0, <span class="stringliteral">&quot;The destination buffer must not be null.&quot;</span>);</div>
<div class="line"><span class="lineno">  464</span>  <span class="keywordflow">if</span> (dest == <span class="keyword">nullptr</span> || destSize == 0)</div>
<div class="line"><span class="lineno">  465</span>    <span class="keywordflow">return</span> dest;</div>
<div class="line"><span class="lineno">  466</span> </div>
<div class="line"><span class="lineno">  467</span>  *dest = <span class="charliteral">&#39;\0&#39;</span>;</div>
<div class="line"><span class="lineno">  468</span>  <span class="keywordflow">if</span> (destSize == 1)</div>
<div class="line"><span class="lineno">  469</span>    <span class="keywordflow">return</span> dest;</div>
<div class="line"><span class="lineno">  470</span> </div>
<div class="line"><span class="lineno">  471</span>  <span class="keyword">const</span> std::size_t bufferSize = 128;</div>
<div class="line"><span class="lineno">  472</span>  <span class="keywordtype">char</span> buffer[bufferSize + 1];</div>
<div class="line"><span class="lineno">  473</span> </div>
<div class="line"><span class="lineno">  474</span>  <span class="keyword">auto</span> exp10 = ftoa32Engine(buffer, value, precision);</div>
<div class="line"><span class="lineno">  475</span>  <span class="keywordflow">if</span> (exp10 == 0xFF) {</div>
<div class="line"><span class="lineno">  476</span><span class="preprocessor">#if defined(_CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES)</span></div>
<div class="line"><span class="lineno">  477</span>    strcpy_s(dest, destSize, buffer);</div>
<div class="line"><span class="lineno">  478</span><span class="preprocessor">#else </span><span class="comment">// defined(_CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES)</span></div>
<div class="line"><span class="lineno">  479</span>    strncpy(dest, buffer, destSize - 1);</div>
<div class="line"><span class="lineno">  480</span><span class="preprocessor">#endif </span><span class="comment">// defined(_CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES)</span></div>
<div class="line"><span class="lineno">  481</span>  } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno">  482</span>    floatPostProcess(dest, buffer, bufferSize, exp10, precision);</div>
<div class="line"><span class="lineno">  483</span>  }</div>
<div class="line"><span class="lineno">  484</span> </div>
<div class="line"><span class="lineno">  485</span>  <span class="keywordflow">return</span> dest;</div>
<div class="line"><span class="lineno">  486</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="aece45bc773865fbc01013939bcfaeeb2" name="aece45bc773865fbc01013939bcfaeeb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aece45bc773865fbc01013939bcfaeeb2">&#9670;&#160;</a></span>integerToSymbols()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t toygine::integerToSymbols </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>destSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>base</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts an integer value to a string representation in a specified base. </p>
<p>This function converts a given integer value into its string representation in the specified base, storing the result in the provided destination buffer.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">type</td><td>The type of the integer value to be converted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>The destination buffer where the converted string is stored. </td></tr>
    <tr><td class="paramname">destSize</td><td>The size of the destination buffer. </td></tr>
    <tr><td class="paramname">value</td><td>The integer value to be converted. </td></tr>
    <tr><td class="paramname">base</td><td>The numerical base for the conversion, e.g., 10 for decimal, 16 for hexadecimal.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of characters written to the destination buffer.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The function assumes that the destination buffer is large enough to hold the converted string. The function does not null-terminate the string. The base must be between 2 and 36 inclusive. </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">   55</span>                                                                                                        {</div>
<div class="line"><span class="lineno">   56</span>  <span class="keyword">static_assert</span>(std::is_integral_v&lt;type&gt;, <span class="stringliteral">&quot;integerToSymbols requires an integral type&quot;</span>);</div>
<div class="line"><span class="lineno">   57</span>  <a class="code hl_define" href="../../dd/d9e/linux_2platform__config_8hpp.html#ae03d9a55f6cbc55ebd9d6b25c2e8889c">assert_message</a>(dest != <span class="keyword">nullptr</span> &amp;&amp; destSize &gt; 0, <span class="stringliteral">&quot;The destination buffer must not be null.&quot;</span>);</div>
<div class="line"><span class="lineno">   58</span>  <a class="code hl_define" href="../../dd/d9e/linux_2platform__config_8hpp.html#ae03d9a55f6cbc55ebd9d6b25c2e8889c">assert_message</a>(base &gt;= 2 &amp;&amp; base &lt;= sc_ansiDigits.size(), <span class="stringliteral">&quot;The base must be between 2 and 36 inclusive.&quot;</span>);</div>
<div class="line"><span class="lineno">   59</span> </div>
<div class="line"><span class="lineno">   60</span>  std::size_t index = 0;</div>
<div class="line"><span class="lineno">   61</span> </div>
<div class="line"><span class="lineno">   62</span>  <span class="keywordflow">do</span> {</div>
<div class="line"><span class="lineno">   63</span>    dest[index++] = sc_ansiDigits[value % base];</div>
<div class="line"><span class="lineno">   64</span>  } <span class="keywordflow">while</span> ((value /= <span class="keyword">static_cast&lt;</span>type<span class="keyword">&gt;</span>(base)) &gt; 0 &amp;&amp; index &lt; destSize);</div>
<div class="line"><span class="lineno">   65</span> </div>
<div class="line"><span class="lineno">   66</span>  <span class="keywordflow">return</span> index;</div>
<div class="line"><span class="lineno">   67</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="af3d3283bae4c448a285a24612546c757" name="af3d3283bae4c448a285a24612546c757"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3d3283bae4c448a285a24612546c757">&#9670;&#160;</a></span>itoa() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * toygine::itoa </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>destSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int16_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts an integer value to a string representation. </p>
<p>This function converts a given integer value into its string representation, storing the result in the provided destination buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>The destination buffer where the converted string is stored. </td></tr>
    <tr><td class="paramname">destSize</td><td>The size of the destination buffer. </td></tr>
    <tr><td class="paramname">value</td><td>The integer value to be converted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the destination buffer containing the converted string.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The function assumes that the destination buffer is large enough to hold the converted string. If the destination buffer size is 1, only a null terminator is written. The function reverses the string in-place. </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">  434</span>                                                               {</div>
<div class="line"><span class="lineno">  435</span>  <span class="keywordflow">return</span> <a class="code hl_function" href="../../d7/de6/namespacetoygine.html#af8a75c65ac8550ff63ac340e1f2572ef">itoaImplementation</a>(dest, destSize, value);</div>
<div class="line"><span class="lineno">  436</span>}</div>
<div class="ttc" id="anamespacetoygine_html_af8a75c65ac8550ff63ac340e1f2572ef"><div class="ttname"><a href="../../d7/de6/namespacetoygine.html#af8a75c65ac8550ff63ac340e1f2572ef">toygine::itoaImplementation</a></div><div class="ttdeci">char * itoaImplementation(char *dest, std::size_t destSize, type value)</div><div class="ttdoc">Converts an integer value to a string representation.</div><div class="ttdef"><b>Definition</b> utils_internal.inl:87</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aff7862134d3413778cda2e84ca0f51ea" name="aff7862134d3413778cda2e84ca0f51ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff7862134d3413778cda2e84ca0f51ea">&#9670;&#160;</a></span>itoa() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * toygine::itoa </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>destSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int32_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts an integer value to a string representation. </p>
<p>This function converts a given integer value into its string representation, storing the result in the provided destination buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>The destination buffer where the converted string is stored. </td></tr>
    <tr><td class="paramname">destSize</td><td>The size of the destination buffer. </td></tr>
    <tr><td class="paramname">value</td><td>The integer value to be converted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the destination buffer containing the converted string.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The function assumes that the destination buffer is large enough to hold the converted string. If the destination buffer size is 1, only a null terminator is written. The function reverses the string in-place. </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">  438</span>                                                               {</div>
<div class="line"><span class="lineno">  439</span>  <span class="keywordflow">return</span> <a class="code hl_function" href="../../d7/de6/namespacetoygine.html#af8a75c65ac8550ff63ac340e1f2572ef">itoaImplementation</a>(dest, destSize, value);</div>
<div class="line"><span class="lineno">  440</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a5daba732dac1d55a5d62dd6c9094acce" name="a5daba732dac1d55a5d62dd6c9094acce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5daba732dac1d55a5d62dd6c9094acce">&#9670;&#160;</a></span>itoa() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * toygine::itoa </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>destSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int64_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts an integer value to a string representation. </p>
<p>This function converts a given integer value into its string representation, storing the result in the provided destination buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>The destination buffer where the converted string is stored. </td></tr>
    <tr><td class="paramname">destSize</td><td>The size of the destination buffer. </td></tr>
    <tr><td class="paramname">value</td><td>The integer value to be converted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the destination buffer containing the converted string.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The function assumes that the destination buffer is large enough to hold the converted string. If the destination buffer size is 1, only a null terminator is written. The function reverses the string in-place. </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">  442</span>                                                               {</div>
<div class="line"><span class="lineno">  443</span>  <span class="keywordflow">return</span> <a class="code hl_function" href="../../d7/de6/namespacetoygine.html#af8a75c65ac8550ff63ac340e1f2572ef">itoaImplementation</a>(dest, destSize, value);</div>
<div class="line"><span class="lineno">  444</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a4de05ddfe7a0c7944b525afd5a8bd7a6" name="a4de05ddfe7a0c7944b525afd5a8bd7a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4de05ddfe7a0c7944b525afd5a8bd7a6">&#9670;&#160;</a></span>itoa() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * toygine::itoa </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>destSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int8_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts an integer value to a string representation. </p>
<p>This function converts a given integer value into its string representation, storing the result in the provided destination buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>The destination buffer where the converted string is stored. </td></tr>
    <tr><td class="paramname">destSize</td><td>The size of the destination buffer. </td></tr>
    <tr><td class="paramname">value</td><td>The integer value to be converted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the destination buffer containing the converted string.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The function assumes that the destination buffer is large enough to hold the converted string. If the destination buffer size is 1, only a null terminator is written. The function reverses the string in-place. </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">  430</span>                                                              {</div>
<div class="line"><span class="lineno">  431</span>  <span class="keywordflow">return</span> <a class="code hl_function" href="../../d7/de6/namespacetoygine.html#af8a75c65ac8550ff63ac340e1f2572ef">itoaImplementation</a>(dest, destSize, value);</div>
<div class="line"><span class="lineno">  432</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a62367f074b5177b48bfd418eff5633b3" name="a62367f074b5177b48bfd418eff5633b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62367f074b5177b48bfd418eff5633b3">&#9670;&#160;</a></span>itoa() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * toygine::itoa </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>destSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>base</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts an unsigned integer to a string representation in the specified base. </p>
<p>This function converts a given unsigned integer value into its string representation in the specified base, storing the result in the provided destination buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>The destination buffer where the converted string is stored. </td></tr>
    <tr><td class="paramname">destSize</td><td>The size of the destination buffer. </td></tr>
    <tr><td class="paramname">value</td><td>The unsigned integer value to be converted. </td></tr>
    <tr><td class="paramname">base</td><td>The numerical base for the conversion, e.g., 10 for decimal, 16 for hexadecimal.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the destination buffer containing the converted string.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The function assumes that the destination buffer is large enough to hold the converted string. If the destination buffer size is 1, only a null terminator is written. The base must be between 2 and 36 inclusive. </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">  450</span>                                                                               {</div>
<div class="line"><span class="lineno">  451</span>  <span class="keywordflow">return</span> <a class="code hl_function" href="../../d7/de6/namespacetoygine.html#a0f7769364a3fa922049ef7ca0b749e12">utoaImplementation</a>(dest, destSize, value, base);</div>
<div class="line"><span class="lineno">  452</span>}</div>
<div class="ttc" id="anamespacetoygine_html_a0f7769364a3fa922049ef7ca0b749e12"><div class="ttname"><a href="../../d7/de6/namespacetoygine.html#a0f7769364a3fa922049ef7ca0b749e12">toygine::utoaImplementation</a></div><div class="ttdeci">char * utoaImplementation(char *dest, std::size_t destSize, type value, unsigned base)</div><div class="ttdoc">Converts an unsigned integer value to a string representation in a specified base.</div><div class="ttdef"><b>Definition</b> utils_internal.inl:137</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a83414059f4d06a2cbf91449b61f529eb" name="a83414059f4d06a2cbf91449b61f529eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83414059f4d06a2cbf91449b61f529eb">&#9670;&#160;</a></span>itoa() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * toygine::itoa </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>destSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>base</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts an unsigned integer to a string representation in the specified base. </p>
<p>This function converts a given unsigned integer value into its string representation in the specified base, storing the result in the provided destination buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>The destination buffer where the converted string is stored. </td></tr>
    <tr><td class="paramname">destSize</td><td>The size of the destination buffer. </td></tr>
    <tr><td class="paramname">value</td><td>The unsigned integer value to be converted. </td></tr>
    <tr><td class="paramname">base</td><td>The numerical base for the conversion, e.g., 10 for decimal, 16 for hexadecimal.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the destination buffer containing the converted string.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The function assumes that the destination buffer is large enough to hold the converted string. If the destination buffer size is 1, only a null terminator is written. The base must be between 2 and 36 inclusive. </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">  454</span>                                                                               {</div>
<div class="line"><span class="lineno">  455</span>  <span class="keywordflow">return</span> <a class="code hl_function" href="../../d7/de6/namespacetoygine.html#a0f7769364a3fa922049ef7ca0b749e12">utoaImplementation</a>(dest, destSize, value, base);</div>
<div class="line"><span class="lineno">  456</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="aa7ba2bb019bcd4337d37b5842bdf6c7b" name="aa7ba2bb019bcd4337d37b5842bdf6c7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7ba2bb019bcd4337d37b5842bdf6c7b">&#9670;&#160;</a></span>itoa() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * toygine::itoa </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>destSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint64_t&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>base</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts an unsigned integer to a string representation in the specified base. </p>
<p>This function converts a given unsigned integer value into its string representation in the specified base, storing the result in the provided destination buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>The destination buffer where the converted string is stored. </td></tr>
    <tr><td class="paramname">destSize</td><td>The size of the destination buffer. </td></tr>
    <tr><td class="paramname">value</td><td>The unsigned integer value to be converted. </td></tr>
    <tr><td class="paramname">base</td><td>The numerical base for the conversion, e.g., 10 for decimal, 16 for hexadecimal.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the destination buffer containing the converted string.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The function assumes that the destination buffer is large enough to hold the converted string. If the destination buffer size is 1, only a null terminator is written. The base must be between 2 and 36 inclusive. </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">  458</span>                                                                               {</div>
<div class="line"><span class="lineno">  459</span>  <span class="keywordflow">return</span> <a class="code hl_function" href="../../d7/de6/namespacetoygine.html#a0f7769364a3fa922049ef7ca0b749e12">utoaImplementation</a>(dest, destSize, value, base);</div>
<div class="line"><span class="lineno">  460</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a11c6df1cb36b16151cfbdf33778146f4" name="a11c6df1cb36b16151cfbdf33778146f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11c6df1cb36b16151cfbdf33778146f4">&#9670;&#160;</a></span>itoa() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * toygine::itoa </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>destSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>base</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts an unsigned integer to a string representation in the specified base. </p>
<p>This function converts a given unsigned integer value into its string representation in the specified base, storing the result in the provided destination buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>The destination buffer where the converted string is stored. </td></tr>
    <tr><td class="paramname">destSize</td><td>The size of the destination buffer. </td></tr>
    <tr><td class="paramname">value</td><td>The unsigned integer value to be converted. </td></tr>
    <tr><td class="paramname">base</td><td>The numerical base for the conversion, e.g., 10 for decimal, 16 for hexadecimal.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the destination buffer containing the converted string.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The function assumes that the destination buffer is large enough to hold the converted string. If the destination buffer size is 1, only a null terminator is written. The base must be between 2 and 36 inclusive. </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">  446</span>                                                                              {</div>
<div class="line"><span class="lineno">  447</span>  <span class="keywordflow">return</span> <a class="code hl_function" href="../../d7/de6/namespacetoygine.html#a0f7769364a3fa922049ef7ca0b749e12">utoaImplementation</a>(dest, destSize, value, base);</div>
<div class="line"><span class="lineno">  448</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="af8a75c65ac8550ff63ac340e1f2572ef" name="af8a75c65ac8550ff63ac340e1f2572ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8a75c65ac8550ff63ac340e1f2572ef">&#9670;&#160;</a></span>itoaImplementation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char * toygine::itoaImplementation </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>destSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts an integer value to a string representation. </p>
<p>This function converts a given integer value into its string representation, storing the result in the provided destination buffer.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">type</td><td>The type of the integer value to be converted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>The destination buffer where the converted string is stored. </td></tr>
    <tr><td class="paramname">destSize</td><td>The size of the destination buffer. </td></tr>
    <tr><td class="paramname">value</td><td>The integer value to be converted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the destination buffer containing the converted string.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The function assumes that the destination buffer is large enough to hold the converted string. If the destination buffer size is 1, only a null terminator is written. The function reverses the string in-place. </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">   87</span>                                                                              {</div>
<div class="line"><span class="lineno">   88</span>  <span class="keyword">static_assert</span>(std::is_integral_v&lt;type&gt; &amp;&amp; std::is_signed_v&lt;type&gt;,</div>
<div class="line"><span class="lineno">   89</span>                <span class="stringliteral">&quot;itoaImplementation requires a signed integral type&quot;</span>);</div>
<div class="line"><span class="lineno">   90</span>  <a class="code hl_define" href="../../dd/d9e/linux_2platform__config_8hpp.html#ae03d9a55f6cbc55ebd9d6b25c2e8889c">assert_message</a>(dest != <span class="keyword">nullptr</span> &amp;&amp; destSize &gt; 0, <span class="stringliteral">&quot;The destination buffer must not be null.&quot;</span>);</div>
<div class="line"><span class="lineno">   91</span>  <span class="keywordflow">if</span> (destSize == 1) {</div>
<div class="line"><span class="lineno">   92</span>    *dest = <span class="charliteral">&#39;\0&#39;</span>;</div>
<div class="line"><span class="lineno">   93</span> </div>
<div class="line"><span class="lineno">   94</span>    <span class="keywordflow">return</span> dest;</div>
<div class="line"><span class="lineno">   95</span>  }</div>
<div class="line"><span class="lineno">   96</span> </div>
<div class="line"><span class="lineno">   97</span>  <span class="comment">// decrease dest size for &#39;\0&#39; symbol</span></div>
<div class="line"><span class="lineno">   98</span>  --destSize;</div>
<div class="line"><span class="lineno">   99</span> </div>
<div class="line"><span class="lineno">  100</span>  std::size_t symbols = 0;</div>
<div class="line"><span class="lineno">  101</span>  <span class="keyword">const</span> <span class="keywordtype">bool</span> valueNegative = (value &lt; 0);</div>
<div class="line"><span class="lineno">  102</span>  <span class="keyword">using </span>unsigned_type = std::make_unsigned_t&lt;type&gt;;</div>
<div class="line"><span class="lineno">  103</span>  <span class="keywordflow">if</span> (valueNegative) {</div>
<div class="line"><span class="lineno">  104</span>    symbols = integerToSymbols(dest, destSize, <span class="keyword">static_cast&lt;</span>unsigned_type<span class="keyword">&gt;</span>(-(value + 1)) + 1U, 10);</div>
<div class="line"><span class="lineno">  105</span>  } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno">  106</span>    symbols = <a class="code hl_function" href="../../d7/de6/namespacetoygine.html#aece45bc773865fbc01013939bcfaeeb2">integerToSymbols</a>(dest, destSize, <span class="keyword">static_cast&lt;</span>unsigned_type<span class="keyword">&gt;</span>(value), 10);</div>
<div class="line"><span class="lineno">  107</span>  }</div>
<div class="line"><span class="lineno">  108</span> </div>
<div class="line"><span class="lineno">  109</span>  <span class="keywordflow">if</span> (valueNegative &amp;&amp; symbols &lt; destSize)</div>
<div class="line"><span class="lineno">  110</span>    dest[symbols++] = <span class="charliteral">&#39;-&#39;</span>;</div>
<div class="line"><span class="lineno">  111</span> </div>
<div class="line"><span class="lineno">  112</span>  dest[symbols] = <span class="charliteral">&#39;\0&#39;</span>;</div>
<div class="line"><span class="lineno">  113</span>  <a class="code hl_function" href="../../d7/de6/namespacetoygine.html#a55968ac28a4437ca63b6dbc6f216b4a4">reverseString</a>(dest, symbols);</div>
<div class="line"><span class="lineno">  114</span> </div>
<div class="line"><span class="lineno">  115</span>  <span class="keywordflow">return</span> dest;</div>
<div class="line"><span class="lineno">  116</span>}</div>
<div class="ttc" id="anamespacetoygine_html_a55968ac28a4437ca63b6dbc6f216b4a4"><div class="ttname"><a href="../../d7/de6/namespacetoygine.html#a55968ac28a4437ca63b6dbc6f216b4a4">toygine::reverseString</a></div><div class="ttdeci">char * reverseString(char *string, std::size_t stringLength)</div><div class="ttdoc">Reverses a given string in-place.</div><div class="ttdef"><b>Definition</b> utils.inl:41</div></div>
<div class="ttc" id="anamespacetoygine_html_aece45bc773865fbc01013939bcfaeeb2"><div class="ttname"><a href="../../d7/de6/namespacetoygine.html#aece45bc773865fbc01013939bcfaeeb2">toygine::integerToSymbols</a></div><div class="ttdeci">constexpr std::size_t integerToSymbols(char *dest, std::size_t destSize, type value, unsigned base)</div><div class="ttdoc">Converts an integer value to a string representation in a specified base.</div><div class="ttdef"><b>Definition</b> utils_internal.inl:55</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a55968ac28a4437ca63b6dbc6f216b4a4" name="a55968ac28a4437ca63b6dbc6f216b4a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55968ac28a4437ca63b6dbc6f216b4a4">&#9670;&#160;</a></span>reverseString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char * toygine::reverseString </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>count</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reverses a given string in-place. </p>
<p>This function will reverse a given string in-place. It can be used to reverse a string of a given length, or to reverse a null-terminated string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to reverse. </td></tr>
    <tr><td class="paramname">count</td><td>The length of the string to reverse.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the reversed string. </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">   41</span>                                                                   {</div>
<div class="line"><span class="lineno">   42</span>  <a class="code hl_define" href="../../dd/d9e/linux_2platform__config_8hpp.html#ae03d9a55f6cbc55ebd9d6b25c2e8889c">assert_message</a>(<span class="keywordtype">string</span> != <span class="keyword">nullptr</span>, <span class="stringliteral">&quot;The source string must not be null.&quot;</span>);</div>
<div class="line"><span class="lineno">   43</span>  <span class="keywordflow">if</span> (<span class="keywordtype">string</span> == <span class="keyword">nullptr</span>)</div>
<div class="line"><span class="lineno">   44</span>    <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div>
<div class="line"><span class="lineno">   45</span> </div>
<div class="line"><span class="lineno">   46</span>  <span class="keywordflow">if</span> (stringLength == 0)</div>
<div class="line"><span class="lineno">   47</span>    stringLength = std::strlen(<span class="keywordtype">string</span>);</div>
<div class="line"><span class="lineno">   48</span> </div>
<div class="line"><span class="lineno">   49</span>  <span class="keywordflow">if</span> (stringLength != 0) {</div>
<div class="line"><span class="lineno">   50</span>    <span class="keywordflow">for</span> (std::size_t i = 0, j = stringLength - 1; i &lt; j; ++i, --j) {</div>
<div class="line"><span class="lineno">   51</span>      std::swap(<span class="keywordtype">string</span>[i], <span class="keywordtype">string</span>[j]);</div>
<div class="line"><span class="lineno">   52</span>    }</div>
<div class="line"><span class="lineno">   53</span>  }</div>
<div class="line"><span class="lineno">   54</span> </div>
<div class="line"><span class="lineno">   55</span>  <span class="keywordflow">return</span> string;</div>
<div class="line"><span class="lineno">   56</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a5eddb55e8f5eb1c4035cfd8a2de1896f" name="a5eddb55e8f5eb1c4035cfd8a2de1896f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5eddb55e8f5eb1c4035cfd8a2de1896f">&#9670;&#160;</a></span>utf8len()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t toygine::utf8len </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of Unicode characters in a UTF-8 encoded string. </p>
<p>This function counts the number of Unicode characters in a UTF-8 encoded string. It stops counting when the null character is encountered or the end of the string is reached.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>A pointer to the UTF-8 encoded string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of Unicode characters in the string, or 0 if the string is invalid. </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">  414</span>                                    {</div>
<div class="line"><span class="lineno">  415</span>  <a class="code hl_define" href="../../dd/d9e/linux_2platform__config_8hpp.html#af576bf8ffa22a44e53018c67095ffbf0">assert</a>(str != <span class="keyword">nullptr</span>);</div>
<div class="line"><span class="lineno">  416</span>  <span class="keywordflow">if</span> (str == <span class="keyword">nullptr</span>)</div>
<div class="line"><span class="lineno">  417</span>    <span class="keywordflow">return</span> 0;</div>
<div class="line"><span class="lineno">  418</span> </div>
<div class="line"><span class="lineno">  419</span>  std::size_t size = 0;</div>
<div class="line"><span class="lineno">  420</span>  <span class="keywordflow">while</span> (*str != <span class="charliteral">&#39;\0&#39;</span>) {</div>
<div class="line"><span class="lineno">  421</span>    <span class="keyword">const</span> <span class="keyword">auto</span> symbolLength = sc_utf8CharSizeTable[<span class="keyword">static_cast&lt;</span>std::uint8_t<span class="keyword">&gt;</span>(*str)];</div>
<div class="line"><span class="lineno">  422</span>    <a class="code hl_define" href="../../dd/d9e/linux_2platform__config_8hpp.html#ae03d9a55f6cbc55ebd9d6b25c2e8889c">assert_message</a>(symbolLength != 0, <span class="stringliteral">&quot;Invalid UTF-8 symbol&quot;</span>);</div>
<div class="line"><span class="lineno">  423</span>    str += symbolLength;</div>
<div class="line"><span class="lineno">  424</span>    ++size;</div>
<div class="line"><span class="lineno">  425</span>  }</div>
<div class="line"><span class="lineno">  426</span> </div>
<div class="line"><span class="lineno">  427</span>  <span class="keywordflow">return</span> size;</div>
<div class="line"><span class="lineno">  428</span>}</div>
<div class="ttc" id="alinux_2platform__config_8hpp_html_af576bf8ffa22a44e53018c67095ffbf0"><div class="ttname"><a href="../../dd/d9e/linux_2platform__config_8hpp.html#af576bf8ffa22a44e53018c67095ffbf0">assert</a></div><div class="ttdeci">#define assert(x)</div><div class="ttdef"><b>Definition</b> platform_config.hpp:62</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aa91ac406f0e472aee86388b14a415e6a" name="aa91ac406f0e472aee86388b14a415e6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa91ac406f0e472aee86388b14a415e6a">&#9670;&#160;</a></span>utf8toWChar() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">wchar_t * toygine::utf8toWChar </td>
          <td>(</td>
          <td class="paramtype">wchar_t *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>destSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a Unicode UTF-8 encoded string to a wide character string. </p>
<p>This function translates a UTF-8 encoded source string into a wide character string stored in the destination buffer. The conversion stops when the specified number of characters have been converted or the destination buffer is filled. The destination string is null-terminated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>A pointer to the destination buffer where the converted wide character string will be stored. </td></tr>
    <tr><td class="paramname">destSize</td><td>The size of the destination buffer. </td></tr>
    <tr><td class="paramname">src</td><td>A pointer to the source UTF-8 encoded string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Only BMP (≤ 0xFFFF) characters are supported by design; 4-byte UTF-8 sequences are not produced.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the destination wide character string, or nullptr if the destination buffer is invalid. </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">   30</span>                                                                                   {</div>
<div class="line"><span class="lineno">   31</span>  <a class="code hl_define" href="../../dd/d9e/linux_2platform__config_8hpp.html#ae03d9a55f6cbc55ebd9d6b25c2e8889c">assert_message</a>(src != <span class="keyword">nullptr</span>, <span class="stringliteral">&quot;The source must not be null.&quot;</span>);</div>
<div class="line"><span class="lineno">   32</span> </div>
<div class="line"><span class="lineno">   33</span>  <span class="keywordflow">return</span> src != <span class="keyword">nullptr</span> ? <a class="code hl_function" href="../../d7/de6/namespacetoygine.html#aa91ac406f0e472aee86388b14a415e6a">utf8toWChar</a>(dest, destSize, src, std::strlen(src)) : nullptr;</div>
<div class="line"><span class="lineno">   34</span>}</div>
<div class="ttc" id="anamespacetoygine_html_aa91ac406f0e472aee86388b14a415e6a"><div class="ttname"><a href="../../d7/de6/namespacetoygine.html#aa91ac406f0e472aee86388b14a415e6a">toygine::utf8toWChar</a></div><div class="ttdeci">wchar_t * utf8toWChar(wchar_t *dest, std::size_t destSize, char const *src)</div><div class="ttdoc">Converts a Unicode UTF-8 encoded string to a wide character string.</div><div class="ttdef"><b>Definition</b> utils.inl:30</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a48637673e063354265967ce84b7031a1" name="a48637673e063354265967ce84b7031a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48637673e063354265967ce84b7031a1">&#9670;&#160;</a></span>utf8toWChar() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">wchar_t * toygine::utf8toWChar </td>
          <td>(</td>
          <td class="paramtype">wchar_t *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>destSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a Unicode UTF-8 encoded string to a wide character string. </p>
<p>This function translates a UTF-8 encoded source string into a wide character string stored in the destination buffer. The conversion stops when the specified number of characters have been converted or the destination buffer is filled. The destination string is null-terminated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>A pointer to the destination buffer where the converted wide character string will be stored. </td></tr>
    <tr><td class="paramname">destSize</td><td>The size of the destination buffer. </td></tr>
    <tr><td class="paramname">src</td><td>A pointer to the source UTF-8 encoded string. </td></tr>
    <tr><td class="paramname">count</td><td>The number of characters to convert from the source string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Only BMP (≤ 0xFFFF) characters are supported by design; 4-byte UTF-8 sequences are not produced.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the destination wide character string, or nullptr if the destination buffer is invalid. </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">  343</span>                                                                                             {</div>
<div class="line"><span class="lineno">  344</span>  <span class="keywordflow">if</span> (dest == <span class="keyword">nullptr</span> || destSize == 0)</div>
<div class="line"><span class="lineno">  345</span>    <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div>
<div class="line"><span class="lineno">  346</span> </div>
<div class="line"><span class="lineno">  347</span>  <span class="keywordtype">wchar_t</span> * destPointer = dest;</div>
<div class="line"><span class="lineno">  348</span>  <span class="keywordflow">if</span> (count &gt; 0 &amp;&amp; src != <span class="keyword">nullptr</span>) {</div>
<div class="line"><span class="lineno">  349</span>    <span class="keywordtype">wchar_t</span> <span class="keyword">const</span> * unicodeEndPos = dest + (destSize - 1);</div>
<div class="line"><span class="lineno">  350</span>    std::size_t srcIterator = 0;</div>
<div class="line"><span class="lineno">  351</span> </div>
<div class="line"><span class="lineno">  352</span>    <span class="keywordflow">while</span> (srcIterator &lt; count &amp;&amp; destPointer &lt; unicodeEndPos) {</div>
<div class="line"><span class="lineno">  353</span>      std::uint8_t symbol = <span class="keyword">static_cast&lt;</span>std::uint8_t<span class="keyword">&gt;</span>(src[srcIterator++]);</div>
<div class="line"><span class="lineno">  354</span>      <span class="keywordflow">if</span> (symbol &lt;= 0x7F) {</div>
<div class="line"><span class="lineno">  355</span>        *destPointer = symbol;</div>
<div class="line"><span class="lineno">  356</span>      } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno">  357</span>        std::size_t charBytes = 0;</div>
<div class="line"><span class="lineno">  358</span>        <span class="keywordflow">while</span> (symbol &amp; 0x80) {</div>
<div class="line"><span class="lineno">  359</span>          ++charBytes;</div>
<div class="line"><span class="lineno">  360</span>          symbol &lt;&lt;= 1;</div>
<div class="line"><span class="lineno">  361</span>        }</div>
<div class="line"><span class="lineno">  362</span> </div>
<div class="line"><span class="lineno">  363</span>        <span class="keywordtype">wchar_t</span> unicodeChar = <span class="keyword">static_cast&lt;</span><span class="keywordtype">wchar_t</span><span class="keyword">&gt;</span>(symbol &gt;&gt; charBytes);</div>
<div class="line"><span class="lineno">  364</span>        <span class="keywordflow">while</span> (charBytes-- &gt; 1) {</div>
<div class="line"><span class="lineno">  365</span>          unicodeChar &lt;&lt;= 6;</div>
<div class="line"><span class="lineno">  366</span>          unicodeChar |= src[srcIterator++] &amp; 0x3F;</div>
<div class="line"><span class="lineno">  367</span>        }</div>
<div class="line"><span class="lineno">  368</span> </div>
<div class="line"><span class="lineno">  369</span>        *destPointer = unicodeChar;</div>
<div class="line"><span class="lineno">  370</span>      }</div>
<div class="line"><span class="lineno">  371</span> </div>
<div class="line"><span class="lineno">  372</span>      ++destPointer;</div>
<div class="line"><span class="lineno">  373</span>    }</div>
<div class="line"><span class="lineno">  374</span>  }</div>
<div class="line"><span class="lineno">  375</span> </div>
<div class="line"><span class="lineno">  376</span>  *destPointer = L<span class="charliteral">&#39;\0&#39;</span>;</div>
<div class="line"><span class="lineno">  377</span> </div>
<div class="line"><span class="lineno">  378</span>  <span class="keywordflow">return</span> dest;</div>
<div class="line"><span class="lineno">  379</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a811e04b05bc9831faa0a74301d2a9e27" name="a811e04b05bc9831faa0a74301d2a9e27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a811e04b05bc9831faa0a74301d2a9e27">&#9670;&#160;</a></span>utf8toWChar() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename stringType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">wchar_t * toygine::utf8toWChar </td>
          <td>(</td>
          <td class="paramtype">wchar_t *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>destSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">stringType const &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a Unicode UTF-8 encoded string to a wide character string. </p>
<p>This function translates a UTF-8 encoded source string into a wide character string stored in the destination buffer. The conversion stops when the specified number of characters have been converted or the destination buffer is filled. The destination string is null-terminated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>A pointer to the destination buffer where the converted wide character string will be stored. </td></tr>
    <tr><td class="paramname">destSize</td><td>The size of the destination buffer. </td></tr>
    <tr><td class="paramname">src</td><td>A reference to a class with null-terminated UTF-8 encoded string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Only BMP (≤ 0xFFFF) characters are supported by design; 4-byte UTF-8 sequences are not produced.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the destination wide character string, or nullptr if the destination buffer is invalid. </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">   37</span>                                                                                         {</div>
<div class="line"><span class="lineno">   38</span>  <span class="keywordflow">return</span> <a class="code hl_function" href="../../d7/de6/namespacetoygine.html#aa91ac406f0e472aee86388b14a415e6a">utf8toWChar</a>(dest, destSize, src.c_str(), src.size());</div>
<div class="line"><span class="lineno">   39</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a0f7769364a3fa922049ef7ca0b749e12" name="a0f7769364a3fa922049ef7ca0b749e12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f7769364a3fa922049ef7ca0b749e12">&#9670;&#160;</a></span>utoaImplementation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char * toygine::utoaImplementation </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>destSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>base</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts an unsigned integer value to a string representation in a specified base. </p>
<p>This function converts a given unsigned integer value into its string representation in the specified numerical base, storing the result in the provided destination buffer. The resulting string is reversed in place and null-terminated.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">type</td><td>The type of the unsigned integer value to be converted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>The destination buffer where the converted string is stored. </td></tr>
    <tr><td class="paramname">destSize</td><td>The size of the destination buffer. </td></tr>
    <tr><td class="paramname">value</td><td>The unsigned integer value to be converted. </td></tr>
    <tr><td class="paramname">base</td><td>The numerical base for the conversion, e.g., 10 for decimal, 16 for hexadecimal.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the destination buffer containing the converted string.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The function assumes that the destination buffer is large enough to hold the converted string. If the destination buffer size is 1, only a null terminator is written. The base must be between 2 and 36 inclusive. </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">  137</span>                                                                                             {</div>
<div class="line"><span class="lineno">  138</span>  <span class="keyword">static_assert</span>(std::is_unsigned_v&lt;type&gt;, <span class="stringliteral">&quot;utoaImplementation requires an unsigned integer type&quot;</span>);</div>
<div class="line"><span class="lineno">  139</span>  <a class="code hl_define" href="../../dd/d9e/linux_2platform__config_8hpp.html#ae03d9a55f6cbc55ebd9d6b25c2e8889c">assert_message</a>(dest != <span class="keyword">nullptr</span> &amp;&amp; destSize &gt; 0, <span class="stringliteral">&quot;The destination buffer must not be null.&quot;</span>);</div>
<div class="line"><span class="lineno">  140</span>  <span class="keywordflow">if</span> (destSize == 1) {</div>
<div class="line"><span class="lineno">  141</span>    *dest = <span class="charliteral">&#39;\0&#39;</span>;</div>
<div class="line"><span class="lineno">  142</span> </div>
<div class="line"><span class="lineno">  143</span>    <span class="keywordflow">return</span> dest;</div>
<div class="line"><span class="lineno">  144</span>  }</div>
<div class="line"><span class="lineno">  145</span> </div>
<div class="line"><span class="lineno">  146</span>  <span class="comment">// decrease dest size for &#39;\0&#39; symbol</span></div>
<div class="line"><span class="lineno">  147</span>  --destSize;</div>
<div class="line"><span class="lineno">  148</span> </div>
<div class="line"><span class="lineno">  149</span>  <span class="keyword">auto</span> symbols = integerToSymbols(dest, destSize, value, base);</div>
<div class="line"><span class="lineno">  150</span> </div>
<div class="line"><span class="lineno">  151</span>  dest[symbols] = <span class="charliteral">&#39;\0&#39;</span>;</div>
<div class="line"><span class="lineno">  152</span>  reverseString(dest, symbols);</div>
<div class="line"><span class="lineno">  153</span> </div>
<div class="line"><span class="lineno">  154</span>  <span class="keywordflow">return</span> dest;</div>
<div class="line"><span class="lineno">  155</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a6173680fd5b35f1df4f1e8a818adc3e9" name="a6173680fd5b35f1df4f1e8a818adc3e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6173680fd5b35f1df4f1e8a818adc3e9">&#9670;&#160;</a></span>wcharToUtf8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * toygine::wcharToUtf8 </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>destSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">wchar_t const *&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a Unicode wide character string to a UTF-8 encoded string. </p>
<p>This function translates a source wide character string into a UTF-8 encoded string stored in the destination buffer. The conversion stops when the source string is fully converted, or the destination buffer is filled. The destination string is null-terminated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>A pointer to the destination buffer where the converted UTF-8 encoded string will be stored. </td></tr>
    <tr><td class="paramname">destSize</td><td>The size of the destination buffer. </td></tr>
    <tr><td class="paramname">src</td><td>A pointer to the source wide character string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the destination UTF-8 encoded string, or nullptr if the destination buffer is invalid. </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">  381</span>                                                                         {</div>
<div class="line"><span class="lineno">  382</span>  <span class="keywordflow">if</span> (dest == <span class="keyword">nullptr</span> || destSize == 0)</div>
<div class="line"><span class="lineno">  383</span>    <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div>
<div class="line"><span class="lineno">  384</span> </div>
<div class="line"><span class="lineno">  385</span>  <span class="keywordtype">char</span> * destPointer = dest;</div>
<div class="line"><span class="lineno">  386</span>  <span class="keywordflow">if</span> (src != <span class="keyword">nullptr</span>) {</div>
<div class="line"><span class="lineno">  387</span>    <span class="keywordtype">char</span> <span class="keyword">const</span> * utf8EndPos = dest + (destSize - 1);</div>
<div class="line"><span class="lineno">  388</span> </div>
<div class="line"><span class="lineno">  389</span>    <span class="keywordflow">while</span> (*src != L<span class="charliteral">&#39;\0&#39;</span> &amp;&amp; destPointer &lt; utf8EndPos) {</div>
<div class="line"><span class="lineno">  390</span>      std::uint32_t symbol = <span class="keyword">static_cast&lt;</span>std::uint32_t<span class="keyword">&gt;</span>(*src++);</div>
<div class="line"><span class="lineno">  391</span>      <span class="keywordflow">if</span> (symbol &lt;= 0x7F) {</div>
<div class="line"><span class="lineno">  392</span>        *destPointer = <span class="keyword">static_cast&lt;</span><span class="keywordtype">char</span><span class="keyword">&gt;</span>(symbol);</div>
<div class="line"><span class="lineno">  393</span>      } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno">  394</span>        <span class="keywordflow">if</span> (symbol &lt;= 0x7FF) {</div>
<div class="line"><span class="lineno">  395</span>          *destPointer = <span class="keyword">static_cast&lt;</span><span class="keywordtype">char</span><span class="keyword">&gt;</span>(((symbol &amp; 0x07C0) &gt;&gt; 6) | 0xC0);</div>
<div class="line"><span class="lineno">  396</span>        } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno">  397</span>          *destPointer = <span class="keyword">static_cast&lt;</span><span class="keywordtype">char</span><span class="keyword">&gt;</span>(((symbol &amp; 0xF000) &gt;&gt; 12) | 0xE0);</div>
<div class="line"><span class="lineno">  398</span>          ++destPointer;</div>
<div class="line"><span class="lineno">  399</span>          *destPointer = <span class="keyword">static_cast&lt;</span><span class="keywordtype">char</span><span class="keyword">&gt;</span>(((symbol &amp; 0x0FC0) &gt;&gt; 6) | 0x80);</div>
<div class="line"><span class="lineno">  400</span>        }</div>
<div class="line"><span class="lineno">  401</span> </div>
<div class="line"><span class="lineno">  402</span>        ++destPointer;</div>
<div class="line"><span class="lineno">  403</span>        *destPointer = <span class="keyword">static_cast&lt;</span><span class="keywordtype">char</span><span class="keyword">&gt;</span>((symbol &amp; 0x003F) | 0x80);</div>
<div class="line"><span class="lineno">  404</span>      }</div>
<div class="line"><span class="lineno">  405</span>      ++destPointer;</div>
<div class="line"><span class="lineno">  406</span>    }</div>
<div class="line"><span class="lineno">  407</span>  }</div>
<div class="line"><span class="lineno">  408</span> </div>
<div class="line"><span class="lineno">  409</span>  *destPointer = <span class="charliteral">&#39;\0&#39;</span>;</div>
<div class="line"><span class="lineno">  410</span> </div>
<div class="line"><span class="lineno">  411</span>  <span class="keywordflow">return</span> dest;</div>
<div class="line"><span class="lineno">  412</span>}</div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a33eb5fc4e7682e297375d2ee2fbb7742" name="a33eb5fc4e7682e297375d2ee2fbb7742"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33eb5fc4e7682e297375d2ee2fbb7742">&#9670;&#160;</a></span>wcharInUtf8MaxSize</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t toygine::wcharInUtf8MaxSize = 3</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maximum UTF-8 bytes for BMP characters (only BMP supported by design) </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../d7/de6/namespacetoygine.html">toygine</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
