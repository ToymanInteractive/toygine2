<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ToyGine2: toy Namespace Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../clipboard.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo.webp" height="52"/></td>
  <td id="projectalign">
   <div id="projectname">ToyGine2<span id="projectnumber">&#160;0.0.1</span>
   </div>
   <div id="projectbrief">Game Engine for retro consoles</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d4/da9/namespacetoy.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#concepts">Concepts</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">toy Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Main engine namespace.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/da2/namespacetoy_1_1assertion.html">assertion</a></td></tr>
<tr class="memdesc:d2/da2/namespacetoy_1_1assertion"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assertion related functions. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html">CStringView</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html">FixedString</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template string class with fixed-size character buffer.  <a href="../../d3/d7a/classtoy_1_1_fixed_string.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="concepts" name="concepts"></a>
Concepts</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d77/concepttoy_1_1_string_like.html">StringLike</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept defining the requirements for string-like types. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a3a8c65476e352b7f64a0bf15ddc87747" id="r_a3a8c65476e352b7f64a0bf15ddc87747"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3a8c65476e352b7f64a0bf15ddc87747">operator==</a> (const <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html">CStringView</a> &amp;lhs, const <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html">CStringView</a> &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a3a8c65476e352b7f64a0bf15ddc87747"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison operator for two <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html">CStringView</a> objects.  <br /></td></tr>
<tr class="separator:a3a8c65476e352b7f64a0bf15ddc87747"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ae46d261b42cdcd0e59b395aebdc834" id="r_a3ae46d261b42cdcd0e59b395aebdc834"><td class="memTemplParams" colspan="2">template&lt;StringLike stringType&gt; </td></tr>
<tr class="memitem:a3ae46d261b42cdcd0e59b395aebdc834"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3ae46d261b42cdcd0e59b395aebdc834">operator==</a> (const <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html">CStringView</a> &amp;lhs, const stringType &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a3ae46d261b42cdcd0e59b395aebdc834"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison operator for <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html">CStringView</a> and <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> object.  <br /></td></tr>
<tr class="separator:a3ae46d261b42cdcd0e59b395aebdc834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0c288d93fdbf4dba71c4309203d9047" id="r_ac0c288d93fdbf4dba71c4309203d9047"><td class="memTemplParams" colspan="2">template&lt;StringLike stringType&gt; </td></tr>
<tr class="memitem:ac0c288d93fdbf4dba71c4309203d9047"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac0c288d93fdbf4dba71c4309203d9047">operator==</a> (const stringType &amp;lhs, const <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html">CStringView</a> &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ac0c288d93fdbf4dba71c4309203d9047"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison operator for <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> object and <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html">CStringView</a>.  <br /></td></tr>
<tr class="separator:ac0c288d93fdbf4dba71c4309203d9047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3761711b53e204a0f2871764d435fd35" id="r_a3761711b53e204a0f2871764d435fd35"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3761711b53e204a0f2871764d435fd35">operator==</a> (const <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html">CStringView</a> &amp;lhs, const char *rhs) noexcept</td></tr>
<tr class="memdesc:a3761711b53e204a0f2871764d435fd35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison operator for <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html">CStringView</a> and C string.  <br /></td></tr>
<tr class="separator:a3761711b53e204a0f2871764d435fd35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71f575fa58def2abe56c129ff51a3696" id="r_a71f575fa58def2abe56c129ff51a3696"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a71f575fa58def2abe56c129ff51a3696">operator==</a> (const char *lhs, const <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html">CStringView</a> &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a71f575fa58def2abe56c129ff51a3696"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison operator for C string and <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html">CStringView</a>.  <br /></td></tr>
<tr class="separator:a71f575fa58def2abe56c129ff51a3696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af959d0dc5fc118ec5c65f27143180021" id="r_af959d0dc5fc118ec5c65f27143180021"><td class="memItemLeft" align="right" valign="top">constexpr std::strong_ordering&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af959d0dc5fc118ec5c65f27143180021">operator&lt;=&gt;</a> (const <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html">CStringView</a> &amp;lhs, const <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html">CStringView</a> &amp;rhs) noexcept</td></tr>
<tr class="memdesc:af959d0dc5fc118ec5c65f27143180021"><td class="mdescLeft">&#160;</td><td class="mdescRight">Three-way comparison operator for <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html">CStringView</a> objects.  <br /></td></tr>
<tr class="separator:af959d0dc5fc118ec5c65f27143180021"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2571fe89aa51139ddbb04bc1fdd0585c" id="r_a2571fe89aa51139ddbb04bc1fdd0585c"><td class="memTemplParams" colspan="2">template&lt;StringLike stringType&gt; </td></tr>
<tr class="memitem:a2571fe89aa51139ddbb04bc1fdd0585c"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::strong_ordering&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2571fe89aa51139ddbb04bc1fdd0585c">operator&lt;=&gt;</a> (const <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html">CStringView</a> &amp;lhs, const stringType &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a2571fe89aa51139ddbb04bc1fdd0585c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Three-way comparison operator for <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html">CStringView</a> and <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> object.  <br /></td></tr>
<tr class="separator:a2571fe89aa51139ddbb04bc1fdd0585c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac327b00da21b55bf3cd1817280a52315" id="r_ac327b00da21b55bf3cd1817280a52315"><td class="memTemplParams" colspan="2">template&lt;StringLike stringType&gt; </td></tr>
<tr class="memitem:ac327b00da21b55bf3cd1817280a52315"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::strong_ordering&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac327b00da21b55bf3cd1817280a52315">operator&lt;=&gt;</a> (const stringType &amp;lhs, const <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html">CStringView</a> &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ac327b00da21b55bf3cd1817280a52315"><td class="mdescLeft">&#160;</td><td class="mdescRight">Three-way comparison operator for <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> object and <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html">CStringView</a>.  <br /></td></tr>
<tr class="separator:ac327b00da21b55bf3cd1817280a52315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9aa91580633549a095c7ba702bee9d9" id="r_ad9aa91580633549a095c7ba702bee9d9"><td class="memItemLeft" align="right" valign="top">constexpr std::strong_ordering&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad9aa91580633549a095c7ba702bee9d9">operator&lt;=&gt;</a> (const <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html">CStringView</a> &amp;lhs, const char *rhs) noexcept</td></tr>
<tr class="memdesc:ad9aa91580633549a095c7ba702bee9d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Three-way comparison operator for <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html">CStringView</a> and C string.  <br /></td></tr>
<tr class="separator:ad9aa91580633549a095c7ba702bee9d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab856389c5db41137391343498eb280a2" id="r_ab856389c5db41137391343498eb280a2"><td class="memItemLeft" align="right" valign="top">constexpr std::strong_ordering&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab856389c5db41137391343498eb280a2">operator&lt;=&gt;</a> (const char *lhs, const <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html">CStringView</a> &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ab856389c5db41137391343498eb280a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Three-way comparison operator for C string and <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html">CStringView</a>.  <br /></td></tr>
<tr class="separator:ab856389c5db41137391343498eb280a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28fad381ee4d8415699e790432777471" id="r_a28fad381ee4d8415699e790432777471"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a28fad381ee4d8415699e790432777471">cstrcmp</a> (const char *lhs, const char *rhs) noexcept</td></tr>
<tr class="memdesc:a28fad381ee4d8415699e790432777471"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two C strings lexicographically.  <br /></td></tr>
<tr class="separator:a28fad381ee4d8415699e790432777471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a591ce52797bb53b8d8ce64a31cabba6b" id="r_a591ce52797bb53b8d8ce64a31cabba6b"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a591ce52797bb53b8d8ce64a31cabba6b">cstrchr</a> (const char *str, int ch) noexcept</td></tr>
<tr class="memdesc:a591ce52797bb53b8d8ce64a31cabba6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first occurrence of a character in a C string.  <br /></td></tr>
<tr class="separator:a591ce52797bb53b8d8ce64a31cabba6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaa16f254dc6bc99679971d96bd87a66" id="r_adaa16f254dc6bc99679971d96bd87a66"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adaa16f254dc6bc99679971d96bd87a66">cstrpbrk</a> (const char *str, const char *accept) noexcept</td></tr>
<tr class="memdesc:adaa16f254dc6bc99679971d96bd87a66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first occurrence of any character from a set in a C string.  <br /></td></tr>
<tr class="separator:adaa16f254dc6bc99679971d96bd87a66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58d00a4a7bbd87ef48d346903b5a8c78" id="r_a58d00a4a7bbd87ef48d346903b5a8c78"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a58d00a4a7bbd87ef48d346903b5a8c78">cstrstr</a> (const char *haystack, const char *needle) noexcept</td></tr>
<tr class="memdesc:a58d00a4a7bbd87ef48d346903b5a8c78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first occurrence of a substring in a C string.  <br /></td></tr>
<tr class="separator:a58d00a4a7bbd87ef48d346903b5a8c78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac789c531cca9ded2d4866edf6d7b9ed5" id="r_ac789c531cca9ded2d4866edf6d7b9ed5"><td class="memTemplParams" colspan="2">template&lt;std::size_t allocatedSize1, std::size_t allocatedSize2&gt; </td></tr>
<tr class="memitem:ac789c531cca9ded2d4866edf6d7b9ed5"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html">FixedString</a>&lt; allocatedSize1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac789c531cca9ded2d4866edf6d7b9ed5">operator+</a> (const <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html">FixedString</a>&lt; allocatedSize1 &gt; &amp;lhs, const <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html">FixedString</a>&lt; allocatedSize2 &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ac789c531cca9ded2d4866edf6d7b9ed5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenation operator for two <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> objects.  <br /></td></tr>
<tr class="separator:ac789c531cca9ded2d4866edf6d7b9ed5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66eecb2acd9da94710c77b796f60cb21" id="r_a66eecb2acd9da94710c77b796f60cb21"><td class="memTemplParams" colspan="2">template&lt;std::size_t allocatedSize, StringLike stringType&gt; </td></tr>
<tr class="memitem:a66eecb2acd9da94710c77b796f60cb21"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html">FixedString</a>&lt; allocatedSize &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a66eecb2acd9da94710c77b796f60cb21">operator+</a> (const <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html">FixedString</a>&lt; allocatedSize &gt; &amp;lhs, const stringType &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a66eecb2acd9da94710c77b796f60cb21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenation operator for <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> and <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> object.  <br /></td></tr>
<tr class="separator:a66eecb2acd9da94710c77b796f60cb21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e935013c7764b31202b25105a86cedd" id="r_a3e935013c7764b31202b25105a86cedd"><td class="memTemplParams" colspan="2">template&lt;StringLike stringType, std::size_t allocatedSize&gt; </td></tr>
<tr class="memitem:a3e935013c7764b31202b25105a86cedd"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html">FixedString</a>&lt; allocatedSize &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3e935013c7764b31202b25105a86cedd">operator+</a> (const stringType &amp;lhs, const <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html">FixedString</a>&lt; allocatedSize &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a3e935013c7764b31202b25105a86cedd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenation operator for <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> object and <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a>.  <br /></td></tr>
<tr class="separator:a3e935013c7764b31202b25105a86cedd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affd1da1d9c8f6ce96223f0321ca1efef" id="r_affd1da1d9c8f6ce96223f0321ca1efef"><td class="memTemplParams" colspan="2">template&lt;std::size_t allocatedSize&gt; </td></tr>
<tr class="memitem:affd1da1d9c8f6ce96223f0321ca1efef"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html">FixedString</a>&lt; allocatedSize &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#affd1da1d9c8f6ce96223f0321ca1efef">operator+</a> (const <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html">FixedString</a>&lt; allocatedSize &gt; &amp;lhs, const char *rhs) noexcept</td></tr>
<tr class="memdesc:affd1da1d9c8f6ce96223f0321ca1efef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenation operator for <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> and C-string.  <br /></td></tr>
<tr class="separator:affd1da1d9c8f6ce96223f0321ca1efef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fef40d514c1a38e96d004926fe183d6" id="r_a2fef40d514c1a38e96d004926fe183d6"><td class="memTemplParams" colspan="2">template&lt;std::size_t allocatedSize&gt; </td></tr>
<tr class="memitem:a2fef40d514c1a38e96d004926fe183d6"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html">FixedString</a>&lt; allocatedSize &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2fef40d514c1a38e96d004926fe183d6">operator+</a> (const char *lhs, const <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html">FixedString</a>&lt; allocatedSize &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a2fef40d514c1a38e96d004926fe183d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenation operator for C-string and <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a>.  <br /></td></tr>
<tr class="separator:a2fef40d514c1a38e96d004926fe183d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a326a560f0c3c0d12d9c7a8642d001e6d" id="r_a326a560f0c3c0d12d9c7a8642d001e6d"><td class="memTemplParams" colspan="2">template&lt;std::size_t allocatedSize&gt; </td></tr>
<tr class="memitem:a326a560f0c3c0d12d9c7a8642d001e6d"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html">FixedString</a>&lt; allocatedSize &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a326a560f0c3c0d12d9c7a8642d001e6d">operator+</a> (const <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html">FixedString</a>&lt; allocatedSize &gt; &amp;lhs, char rhs) noexcept</td></tr>
<tr class="memdesc:a326a560f0c3c0d12d9c7a8642d001e6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenation operator for <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> and character.  <br /></td></tr>
<tr class="separator:a326a560f0c3c0d12d9c7a8642d001e6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a356a3fceab84ce068ff702d19893708b" id="r_a356a3fceab84ce068ff702d19893708b"><td class="memTemplParams" colspan="2">template&lt;std::size_t allocatedSize&gt; </td></tr>
<tr class="memitem:a356a3fceab84ce068ff702d19893708b"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html">FixedString</a>&lt; allocatedSize &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a356a3fceab84ce068ff702d19893708b">operator+</a> (char lhs, const <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html">FixedString</a>&lt; allocatedSize &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a356a3fceab84ce068ff702d19893708b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenation operator for character and <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a>.  <br /></td></tr>
<tr class="separator:a356a3fceab84ce068ff702d19893708b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf758a094d8de5ef108ef3e984c37cf1" id="r_acf758a094d8de5ef108ef3e984c37cf1"><td class="memTemplParams" colspan="2">template&lt;std::size_t allocatedSize1, std::size_t allocatedSize2&gt; </td></tr>
<tr class="memitem:acf758a094d8de5ef108ef3e984c37cf1"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#acf758a094d8de5ef108ef3e984c37cf1">operator==</a> (const <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html">FixedString</a>&lt; allocatedSize1 &gt; &amp;lhs, const <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html">FixedString</a>&lt; allocatedSize2 &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:acf758a094d8de5ef108ef3e984c37cf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison operator for two <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> objects.  <br /></td></tr>
<tr class="separator:acf758a094d8de5ef108ef3e984c37cf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a718df287209b3adb957de9de67f9d863" id="r_a718df287209b3adb957de9de67f9d863"><td class="memTemplParams" colspan="2">template&lt;std::size_t allocatedSize, StringLike stringType&gt; </td></tr>
<tr class="memitem:a718df287209b3adb957de9de67f9d863"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a718df287209b3adb957de9de67f9d863">operator==</a> (const <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html">FixedString</a>&lt; allocatedSize &gt; &amp;lhs, const stringType &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a718df287209b3adb957de9de67f9d863"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison operator for <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> and <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> object.  <br /></td></tr>
<tr class="separator:a718df287209b3adb957de9de67f9d863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a300e65bc1fbafecbcf63f47317198ec4" id="r_a300e65bc1fbafecbcf63f47317198ec4"><td class="memTemplParams" colspan="2">template&lt;StringLike stringType, std::size_t allocatedSize&gt; </td></tr>
<tr class="memitem:a300e65bc1fbafecbcf63f47317198ec4"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a300e65bc1fbafecbcf63f47317198ec4">operator==</a> (const stringType &amp;lhs, const <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html">FixedString</a>&lt; allocatedSize &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a300e65bc1fbafecbcf63f47317198ec4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison operator for <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> object and <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a>.  <br /></td></tr>
<tr class="separator:a300e65bc1fbafecbcf63f47317198ec4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e7299d83e4f5d41d4951f84a44abdf4" id="r_a6e7299d83e4f5d41d4951f84a44abdf4"><td class="memTemplParams" colspan="2">template&lt;std::size_t allocatedSize&gt; </td></tr>
<tr class="memitem:a6e7299d83e4f5d41d4951f84a44abdf4"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6e7299d83e4f5d41d4951f84a44abdf4">operator==</a> (const <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html">FixedString</a>&lt; allocatedSize &gt; &amp;lhs, const char *rhs) noexcept</td></tr>
<tr class="memdesc:a6e7299d83e4f5d41d4951f84a44abdf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison operator for <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> and C string.  <br /></td></tr>
<tr class="separator:a6e7299d83e4f5d41d4951f84a44abdf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5568d083a1e1f805d9a0b9e22d3ea00d" id="r_a5568d083a1e1f805d9a0b9e22d3ea00d"><td class="memTemplParams" colspan="2">template&lt;std::size_t allocatedSize&gt; </td></tr>
<tr class="memitem:a5568d083a1e1f805d9a0b9e22d3ea00d"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5568d083a1e1f805d9a0b9e22d3ea00d">operator==</a> (const char *lhs, const <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html">FixedString</a>&lt; allocatedSize &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a5568d083a1e1f805d9a0b9e22d3ea00d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison operator for C string and <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a>.  <br /></td></tr>
<tr class="separator:a5568d083a1e1f805d9a0b9e22d3ea00d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a3d16e98341489a2ba4e77d76e72e4f" id="r_a3a3d16e98341489a2ba4e77d76e72e4f"><td class="memTemplParams" colspan="2">template&lt;std::size_t allocatedSize1, std::size_t allocatedSize2&gt; </td></tr>
<tr class="memitem:a3a3d16e98341489a2ba4e77d76e72e4f"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::strong_ordering&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3a3d16e98341489a2ba4e77d76e72e4f">operator&lt;=&gt;</a> (const <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html">FixedString</a>&lt; allocatedSize1 &gt; &amp;lhs, const <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html">FixedString</a>&lt; allocatedSize2 &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a3a3d16e98341489a2ba4e77d76e72e4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Three-way comparison operator for <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> objects.  <br /></td></tr>
<tr class="separator:a3a3d16e98341489a2ba4e77d76e72e4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a600f056ee510aa623a7eec926077d0d2" id="r_a600f056ee510aa623a7eec926077d0d2"><td class="memTemplParams" colspan="2">template&lt;std::size_t allocatedSize, StringLike stringType&gt; </td></tr>
<tr class="memitem:a600f056ee510aa623a7eec926077d0d2"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::strong_ordering&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a600f056ee510aa623a7eec926077d0d2">operator&lt;=&gt;</a> (const <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html">FixedString</a>&lt; allocatedSize &gt; &amp;lhs, const stringType &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a600f056ee510aa623a7eec926077d0d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Three-way comparison operator for <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> and <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> object.  <br /></td></tr>
<tr class="separator:a600f056ee510aa623a7eec926077d0d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d95d2f2437840de99f597f291f3d9f9" id="r_a5d95d2f2437840de99f597f291f3d9f9"><td class="memTemplParams" colspan="2">template&lt;StringLike stringType, std::size_t allocatedSize&gt; </td></tr>
<tr class="memitem:a5d95d2f2437840de99f597f291f3d9f9"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::strong_ordering&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5d95d2f2437840de99f597f291f3d9f9">operator&lt;=&gt;</a> (const stringType &amp;lhs, const <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html">FixedString</a>&lt; allocatedSize &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a5d95d2f2437840de99f597f291f3d9f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Three-way comparison operator for <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> object and <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a>.  <br /></td></tr>
<tr class="separator:a5d95d2f2437840de99f597f291f3d9f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46515295e8eafc3e748d0c02ad5ecd70" id="r_a46515295e8eafc3e748d0c02ad5ecd70"><td class="memTemplParams" colspan="2">template&lt;std::size_t allocatedSize&gt; </td></tr>
<tr class="memitem:a46515295e8eafc3e748d0c02ad5ecd70"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::strong_ordering&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a46515295e8eafc3e748d0c02ad5ecd70">operator&lt;=&gt;</a> (const <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html">FixedString</a>&lt; allocatedSize &gt; &amp;lhs, const char *rhs) noexcept</td></tr>
<tr class="memdesc:a46515295e8eafc3e748d0c02ad5ecd70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Three-way comparison operator for <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> and C string.  <br /></td></tr>
<tr class="separator:a46515295e8eafc3e748d0c02ad5ecd70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a876dcc65c97b11b3e32289867cd11a56" id="r_a876dcc65c97b11b3e32289867cd11a56"><td class="memTemplParams" colspan="2">template&lt;std::size_t allocatedSize&gt; </td></tr>
<tr class="memitem:a876dcc65c97b11b3e32289867cd11a56"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::strong_ordering&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a876dcc65c97b11b3e32289867cd11a56">operator&lt;=&gt;</a> (const char *lhs, const <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html">FixedString</a>&lt; allocatedSize &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a876dcc65c97b11b3e32289867cd11a56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Three-way comparison operator for C string and <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a>.  <br /></td></tr>
<tr class="separator:a876dcc65c97b11b3e32289867cd11a56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dbda78acf36cc3d5cf3f59eb80232bc" id="r_a9dbda78acf36cc3d5cf3f59eb80232bc"><td class="memItemLeft" align="right" valign="top">constexpr wchar_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9dbda78acf36cc3d5cf3f59eb80232bc">utf8toWChar</a> (wchar_t *dest, std::size_t destSize, const char *const src) noexcept</td></tr>
<tr class="memdesc:a9dbda78acf36cc3d5cf3f59eb80232bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a Unicode UTF-8 encoded string to a wide character string.  <br /></td></tr>
<tr class="separator:a9dbda78acf36cc3d5cf3f59eb80232bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad81a8970ee6596253140bc264ef6e441" id="r_ad81a8970ee6596253140bc264ef6e441"><td class="memTemplParams" colspan="2">template&lt;StringLike stringType&gt; </td></tr>
<tr class="memitem:ad81a8970ee6596253140bc264ef6e441"><td class="memTemplItemLeft" align="right" valign="top">constexpr wchar_t *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad81a8970ee6596253140bc264ef6e441">utf8toWChar</a> (wchar_t *dest, std::size_t destSize, const stringType &amp;src) noexcept</td></tr>
<tr class="memdesc:ad81a8970ee6596253140bc264ef6e441"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a Unicode UTF-8 encoded string to a wide character string.  <br /></td></tr>
<tr class="separator:ad81a8970ee6596253140bc264ef6e441"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08e2e765a94dee108e646fd69fe7b535" id="r_a08e2e765a94dee108e646fd69fe7b535"><td class="memItemLeft" align="right" valign="top">constexpr char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a08e2e765a94dee108e646fd69fe7b535">reverseString</a> (char *str, std::size_t count=0) noexcept</td></tr>
<tr class="memdesc:a08e2e765a94dee108e646fd69fe7b535"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses a given string in-place.  <br /></td></tr>
<tr class="separator:a08e2e765a94dee108e646fd69fe7b535"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff93fe11056b42f3c929e4739bbad1bf" id="r_aff93fe11056b42f3c929e4739bbad1bf"><td class="memItemLeft" align="right" valign="top">wchar_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aff93fe11056b42f3c929e4739bbad1bf">utf8toWChar</a> (wchar_t *dest, std::size_t destSize, const char *const src, std::size_t count) noexcept</td></tr>
<tr class="memdesc:aff93fe11056b42f3c929e4739bbad1bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a Unicode UTF-8 encoded string to a wide character string with character count limit.  <br /></td></tr>
<tr class="separator:aff93fe11056b42f3c929e4739bbad1bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6f23b1a42f8357ca5341bbe33902d99" id="r_af6f23b1a42f8357ca5341bbe33902d99"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af6f23b1a42f8357ca5341bbe33902d99">wcharToUtf8</a> (char *dest, std::size_t destSize, const wchar_t *src) noexcept</td></tr>
<tr class="memdesc:af6f23b1a42f8357ca5341bbe33902d99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a Unicode wide character string to a UTF-8 encoded string.  <br /></td></tr>
<tr class="separator:af6f23b1a42f8357ca5341bbe33902d99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d645acb64c01923ca7a9ab11c0ae7f0" id="r_a4d645acb64c01923ca7a9ab11c0ae7f0"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4d645acb64c01923ca7a9ab11c0ae7f0">utf8Len</a> (const char *str) noexcept</td></tr>
<tr class="memdesc:a4d645acb64c01923ca7a9ab11c0ae7f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of Unicode characters in a UTF-8 encoded string.  <br /></td></tr>
<tr class="separator:a4d645acb64c01923ca7a9ab11c0ae7f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cbe38a6563b3443fbb3641013c6eef5" id="r_a7cbe38a6563b3443fbb3641013c6eef5"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7cbe38a6563b3443fbb3641013c6eef5">itoa</a> (char *dest, std::size_t destSize, std::int8_t value) noexcept</td></tr>
<tr class="memdesc:a7cbe38a6563b3443fbb3641013c6eef5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an 8-bit signed integer value to a string representation.  <br /></td></tr>
<tr class="separator:a7cbe38a6563b3443fbb3641013c6eef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20e91c14bdc302be0299332e5929908a" id="r_a20e91c14bdc302be0299332e5929908a"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a20e91c14bdc302be0299332e5929908a">itoa</a> (char *dest, std::size_t destSize, std::int16_t value) noexcept</td></tr>
<tr class="memdesc:a20e91c14bdc302be0299332e5929908a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a 16-bit signed integer value to a string representation.  <br /></td></tr>
<tr class="separator:a20e91c14bdc302be0299332e5929908a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a217385ba93808d37d39421712db5b014" id="r_a217385ba93808d37d39421712db5b014"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a217385ba93808d37d39421712db5b014">itoa</a> (char *dest, std::size_t destSize, std::int32_t value) noexcept</td></tr>
<tr class="memdesc:a217385ba93808d37d39421712db5b014"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a 32-bit signed integer value to a string representation.  <br /></td></tr>
<tr class="separator:a217385ba93808d37d39421712db5b014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84db9288148850a414d3253299398e7a" id="r_a84db9288148850a414d3253299398e7a"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a84db9288148850a414d3253299398e7a">itoa</a> (char *dest, std::size_t destSize, std::int64_t value) noexcept</td></tr>
<tr class="memdesc:a84db9288148850a414d3253299398e7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a 64-bit signed integer value to a string representation.  <br /></td></tr>
<tr class="separator:a84db9288148850a414d3253299398e7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23fc801de24bb0daa8db0b2eec615c4d" id="r_a23fc801de24bb0daa8db0b2eec615c4d"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a23fc801de24bb0daa8db0b2eec615c4d">itoa</a> (char *dest, std::size_t destSize, std::uint8_t value, unsigned base) noexcept</td></tr>
<tr class="memdesc:a23fc801de24bb0daa8db0b2eec615c4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an 8-bit unsigned integer to a string representation in the specified base.  <br /></td></tr>
<tr class="separator:a23fc801de24bb0daa8db0b2eec615c4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a782b12f3bae664fb48c63effeeea0357" id="r_a782b12f3bae664fb48c63effeeea0357"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a782b12f3bae664fb48c63effeeea0357">itoa</a> (char *dest, std::size_t destSize, std::uint16_t value, unsigned base) noexcept</td></tr>
<tr class="memdesc:a782b12f3bae664fb48c63effeeea0357"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a 16-bit unsigned integer to a string representation in the specified base.  <br /></td></tr>
<tr class="separator:a782b12f3bae664fb48c63effeeea0357"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ae4e6c5cad6d6db25d552a6254b362d" id="r_a4ae4e6c5cad6d6db25d552a6254b362d"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4ae4e6c5cad6d6db25d552a6254b362d">itoa</a> (char *dest, std::size_t destSize, std::uint32_t value, unsigned base) noexcept</td></tr>
<tr class="memdesc:a4ae4e6c5cad6d6db25d552a6254b362d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a 32-bit unsigned integer to a string representation in the specified base.  <br /></td></tr>
<tr class="separator:a4ae4e6c5cad6d6db25d552a6254b362d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85d2dc4a41dd3f21c08bc7565ca499b2" id="r_a85d2dc4a41dd3f21c08bc7565ca499b2"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a85d2dc4a41dd3f21c08bc7565ca499b2">itoa</a> (char *dest, std::size_t destSize, std::uint64_t value, unsigned base) noexcept</td></tr>
<tr class="memdesc:a85d2dc4a41dd3f21c08bc7565ca499b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a 64-bit unsigned integer to a string representation in the specified base.  <br /></td></tr>
<tr class="separator:a85d2dc4a41dd3f21c08bc7565ca499b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a706d142ecdd8edb11b7aa44416b06e0c" id="r_a706d142ecdd8edb11b7aa44416b06e0c"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a706d142ecdd8edb11b7aa44416b06e0c">ftoa</a> (char *dest, std::size_t destSize, float value, std::size_t precision=7) noexcept</td></tr>
<tr class="memdesc:a706d142ecdd8edb11b7aa44416b06e0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a 32-bit floating-point number to its string representation with specified precision.  <br /></td></tr>
<tr class="separator:a706d142ecdd8edb11b7aa44416b06e0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97f3908f435a8e81f175109e210dac49" id="r_a97f3908f435a8e81f175109e210dac49"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a97f3908f435a8e81f175109e210dac49">ftoa</a> (char *dest, std::size_t destSize, double value, std::size_t precision=15) noexcept</td></tr>
<tr class="memdesc:a97f3908f435a8e81f175109e210dac49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a 64-bit floating-point number to its string representation with specified precision.  <br /></td></tr>
<tr class="separator:a97f3908f435a8e81f175109e210dac49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a213e347d3805faf2aa81abbcffeca92b" id="r_a213e347d3805faf2aa81abbcffeca92b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a213e347d3805faf2aa81abbcffeca92b">formatNumberString</a> (char *buffer, std::size_t bufferSize, const char *separator) noexcept</td></tr>
<tr class="memdesc:a213e347d3805faf2aa81abbcffeca92b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Formats a number string by inserting grouping separators.  <br /></td></tr>
<tr class="separator:a213e347d3805faf2aa81abbcffeca92b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63f823f1d5e638248b10d02d8a1666ba" id="r_a63f823f1d5e638248b10d02d8a1666ba"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a63f823f1d5e638248b10d02d8a1666ba"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a63f823f1d5e638248b10d02d8a1666ba">ArraySize</a> (T(&amp;)[N])</td></tr>
<tr class="memdesc:a63f823f1d5e638248b10d02d8a1666ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of an array at compile-time.  <br /></td></tr>
<tr class="separator:a63f823f1d5e638248b10d02d8a1666ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7d30f3d8737ff13c76ec6b2564b1da6" id="r_ad7d30f3d8737ff13c76ec6b2564b1da6"><td class="memTemplParams" colspan="2">template&lt;typename type &gt; </td></tr>
<tr class="memitem:ad7d30f3d8737ff13c76ec6b2564b1da6"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad7d30f3d8737ff13c76ec6b2564b1da6">integerToSymbols</a> (char *dest, std::size_t destSize, type value, unsigned base)</td></tr>
<tr class="memdesc:ad7d30f3d8737ff13c76ec6b2564b1da6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an integer value to a string representation in a specified base.  <br /></td></tr>
<tr class="separator:ad7d30f3d8737ff13c76ec6b2564b1da6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a325d3850ce833eab7c97a3eac78559a3" id="r_a325d3850ce833eab7c97a3eac78559a3"><td class="memTemplParams" colspan="2">template&lt;typename type &gt; </td></tr>
<tr class="memitem:a325d3850ce833eab7c97a3eac78559a3"><td class="memTemplItemLeft" align="right" valign="top">char *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a325d3850ce833eab7c97a3eac78559a3">itoaImplementation</a> (char *dest, std::size_t destSize, type value)</td></tr>
<tr class="memdesc:a325d3850ce833eab7c97a3eac78559a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an integer value to a string representation.  <br /></td></tr>
<tr class="separator:a325d3850ce833eab7c97a3eac78559a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c19dd984dbb76264f00009b635304f2" id="r_a0c19dd984dbb76264f00009b635304f2"><td class="memTemplParams" colspan="2">template&lt;typename type &gt; </td></tr>
<tr class="memitem:a0c19dd984dbb76264f00009b635304f2"><td class="memTemplItemLeft" align="right" valign="top">char *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0c19dd984dbb76264f00009b635304f2">utoaImplementation</a> (char *dest, std::size_t destSize, type value, unsigned base)</td></tr>
<tr class="memdesc:a0c19dd984dbb76264f00009b635304f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an unsigned integer value to a string representation in a specified base.  <br /></td></tr>
<tr class="separator:a0c19dd984dbb76264f00009b635304f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a1b86c01d1136abd02c4b403630ed222f" id="r_a1b86c01d1136abd02c4b403630ed222f"><td class="memItemLeft" align="right" valign="top">static constexpr std::array&lt; char, 36 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1b86c01d1136abd02c4b403630ed222f">sc_ansiDigits</a></td></tr>
<tr class="separator:a1b86c01d1136abd02c4b403630ed222f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaba2640627e0f36ead0a3844fd35c6a9" id="r_aaba2640627e0f36ead0a3844fd35c6a9"><td class="memItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaba2640627e0f36ead0a3844fd35c6a9">wcharInUtf8MaxSize</a> = 3</td></tr>
<tr class="memdesc:aaba2640627e0f36ead0a3844fd35c6a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum UTF-8 bytes required for BMP characters.  <br /></td></tr>
<tr class="separator:aaba2640627e0f36ead0a3844fd35c6a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Main engine namespace. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a63f823f1d5e638248b10d02d8a1666ba" name="a63f823f1d5e638248b10d02d8a1666ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63f823f1d5e638248b10d02d8a1666ba">&#9670;&#160;</a></span>ArraySize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t toy::ArraySize </td>
          <td>(</td>
          <td class="paramtype">T(&amp;)</td>          <td class="paramname"><span class="paramname"><em></em></span>[N]</td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the size of an array at compile-time. </p>
<p>This is a compile-time helper function that returns the size of an array. The size of the array is inferred from the parameter type, which is a reference to an array of length N. </p>

</div>
</div>
<a id="a591ce52797bb53b8d8ce64a31cabba6b" name="a591ce52797bb53b8d8ce64a31cabba6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a591ce52797bb53b8d8ce64a31cabba6b">&#9670;&#160;</a></span>cstrchr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * toy::cstrchr </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ch</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first occurrence of a character in a C string. </p>
<p>This function searches for the first occurrence of the character <em>ch</em> within the string <em>str</em>. The search is performed character by character from the beginning of the string and returns a pointer to the first occurrence, or nullptr if the character is not found. This function is designed to be constexpr-compatible and provides the same behavior as std::strchr but can be evaluated at compile time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The C string to search in. </td></tr>
    <tr><td class="paramname">ch</td><td>The character to search for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the first occurrence of <em>ch</em> in <em>str</em>, or nullptr if not found.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The <em>str</em> pointer must not be null.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The search is case-sensitive. </dd>
<dd>
The function searches from the beginning of <em>str</em> and returns the first match. </dd>
<dd>
This function is constexpr-compatible and can be used in compile-time contexts.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>std::strchr </dd></dl>

</div>
</div>
<a id="a28fad381ee4d8415699e790432777471" name="a28fad381ee4d8415699e790432777471"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28fad381ee4d8415699e790432777471">&#9670;&#160;</a></span>cstrcmp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int toy::cstrcmp </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two C strings lexicographically. </p>
<p>This function performs a lexicographic comparison between two C strings. The comparison is performed character by character using the character's numeric value. This function is designed to be constexpr-compatible and provides the same behavior as std::strcmp but can be evaluated at compile time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side C string to compare. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side C string to compare.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A negative value if <em>lhs</em> is lexicographically less than <em>rhs</em>, zero if they are equal, or a positive value if <em>lhs</em> is lexicographically greater than <em>rhs</em>.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The <em>lhs</em> pointer must not be null. </dd>
<dd>
The <em>rhs</em> pointer must not be null.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The comparison is case-sensitive. </dd>
<dd>
The comparison stops at the first character that differs between the strings. </dd>
<dd>
If one string is a prefix of another, the shorter string is considered lexicographically smaller. </dd>
<dd>
Return values are -1, 0, or 1 based on lexicographic order using unsigned char comparison; this differs from std::strcmp, which returns the arithmetic difference. </dd>
<dd>
This function is constexpr-compatible and can be used in compile-time contexts.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>std::strcmp </dd></dl>

</div>
</div>
<a id="adaa16f254dc6bc99679971d96bd87a66" name="adaa16f254dc6bc99679971d96bd87a66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaa16f254dc6bc99679971d96bd87a66">&#9670;&#160;</a></span>cstrpbrk()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * toy::cstrpbrk </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>accept</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first occurrence of any character from a set in a C string. </p>
<p>This function searches for the first occurrence of any character from the <em>accept</em> string within the <em>str</em> string. The search is performed character by character from the beginning and returns a pointer to the first character found that matches any character in the accept set, or nullptr if no character from the accept set is found. This function is designed to be constexpr-compatible and provides the same behavior as std::strpbrk but can be evaluated at compile time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The C string to search in. Must be null-terminated. </td></tr>
    <tr><td class="paramname">accept</td><td>The C string containing the set of characters to search for. Must be null-terminated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the first character in <em>str</em> that matches any character in <em>accept</em>, or nullptr if no character from the accept set is found.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The <em>str</em> pointer must not be null. </dd>
<dd>
The <em>accept</em> pointer must not be null.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The search is case-sensitive. </dd>
<dd>
The function searches from the beginning of <em>str</em> and returns the first match. </dd>
<dd>
This function is constexpr-compatible and can be used in compile-time contexts.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>std::strpbrk </dd></dl>

</div>
</div>
<a id="a58d00a4a7bbd87ef48d346903b5a8c78" name="a58d00a4a7bbd87ef48d346903b5a8c78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58d00a4a7bbd87ef48d346903b5a8c78">&#9670;&#160;</a></span>cstrstr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * toy::cstrstr </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>haystack</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>needle</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first occurrence of a substring in a C string. </p>
<p>This function searches for the first occurrence of the <em>needle</em> string within the <em>haystack</em> string. The search is performed character by character from the beginning and returns a pointer to the beginning of the first occurrence, or nullptr if the substring is not found. This function is designed to be constexpr-compatible and provides the same behavior as std::strstr but can be evaluated at compile time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">haystack</td><td>The C string to search in. </td></tr>
    <tr><td class="paramname">needle</td><td>The C string to search for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the first occurrence of <em>needle</em> in <em>haystack</em>, or nullptr if not found. If <em>needle</em> is an empty string, returns <em>haystack</em>.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The <em>haystack</em> pointer must not be null. </dd>
<dd>
The <em>needle</em> pointer must not be null.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The search is case-sensitive. </dd>
<dd>
If <em>needle</em> is an empty string, the function returns <em>haystack</em> immediately. </dd>
<dd>
The function searches from the beginning of <em>haystack</em> and returns the first match. </dd>
<dd>
This function is constexpr-compatible and can be used in compile-time contexts.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>std::strstr </dd></dl>

</div>
</div>
<a id="a213e347d3805faf2aa81abbcffeca92b" name="a213e347d3805faf2aa81abbcffeca92b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a213e347d3805faf2aa81abbcffeca92b">&#9670;&#160;</a></span>formatNumberString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void toy::formatNumberString </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>bufferSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>separator</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Formats a number string by inserting grouping separators. </p>
<p>This function inserts a grouping separator (e.g., comma, space, or dot) into a number string every three digits, starting from the right. This is commonly used for formatting large numbers to improve readability (e.g., "1,234,567").</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>A pointer to the buffer where the formatted string is stored. </td></tr>
    <tr><td class="paramname">bufferSize</td><td>The size of the buffer in characters. </td></tr>
    <tr><td class="paramname">separator</td><td>A pointer to the grouping separator C string to insert (e.g., ",", " ", ".").</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The buffer must be valid and contain a null-terminated number string. </dd>
<dd>
The bufferSize must be sufficient to accommodate the formatted result. </dd>
<dd>
The separator must not be null and should be reasonable in length (≤ 8 characters). </dd>
<dd>
The input string should contain only digits (no decimal points, signs, or other characters).</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The buffer contains the formatted number string with grouping separators. </dd>
<dd>
The function modifies the buffer in-place. </dd>
<dd>
The function returns early if the buffer is too small for the result.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The function validates available capacity before modification. </dd>
<dd>
Grouping separators are inserted every three digits from the right. </dd>
<dd>
The function handles edge cases gracefully (empty string, single digits, etc.). </dd>
<dd>
The function is thread-safe for single-buffer operations. </dd>
<dd>
Performance is optimized for common number string lengths. </dd>
<dd>
The function does not validate that the input is purely numeric. </dd></dl>

</div>
</div>
<a id="a97f3908f435a8e81f175109e210dac49" name="a97f3908f435a8e81f175109e210dac49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97f3908f435a8e81f175109e210dac49">&#9670;&#160;</a></span>ftoa() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char * toy::ftoa </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>destSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>precision</em></span><span class="paramdefsep"> = </span><span class="paramdefval">15</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a 64-bit floating-point number to its string representation with specified precision. </p>
<p>This function converts a given 64-bit floating-point number into its decimal string representation, storing the result in the provided destination buffer. The conversion supports configurable precision and handles special values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>A pointer to the destination buffer where the converted string is stored. </td></tr>
    <tr><td class="paramname">destSize</td><td>The size of the destination buffer in characters. </td></tr>
    <tr><td class="paramname">value</td><td>The 64-bit floating-point number to be converted. </td></tr>
    <tr><td class="paramname">precision</td><td>The precision (digits after the decimal point). Default is 15, practical limit is ~15–17 digits.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the destination buffer containing the converted string.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The destination buffer must be valid and have sufficient capacity. </dd>
<dd>
The precision should be reasonable (typically ≤ 17 for double).</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The destination string is null-terminated. </dd>
<dd>
Special values (inf, -inf, nan) are properly represented. </dd>
<dd>
The result uses fixed-point notation (not scientific).</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The function handles special IEEE-754 values (infinity, NaN). </dd>
<dd>
The function does not support subnormal numbers. </dd>
<dd>
Precision beyond ~15–17 digits may not be meaningful for float. </dd>
<dd>
The function uses efficient bit manipulation for conversion. </dd>
<dd>
The function is thread-safe for single-buffer operations. </dd></dl>
<div id="dynsection-0" onclick="return dynsection.toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="../../closed.png" alt="+"/> Here is the call graph for this function:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="../../d4/da9/namespacetoy_a97f3908f435a8e81f175109e210dac49_cgraph.svg" width="584" height="115"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a706d142ecdd8edb11b7aa44416b06e0c" name="a706d142ecdd8edb11b7aa44416b06e0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a706d142ecdd8edb11b7aa44416b06e0c">&#9670;&#160;</a></span>ftoa() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char * toy::ftoa </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>destSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>precision</em></span><span class="paramdefsep"> = </span><span class="paramdefval">7</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a 32-bit floating-point number to its string representation with specified precision. </p>
<p>This function converts a given 32-bit floating-point number into its decimal string representation, storing the result in the provided destination buffer. The conversion supports configurable precision and handles special values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>A pointer to the destination buffer where the converted string is stored. </td></tr>
    <tr><td class="paramname">destSize</td><td>The size of the destination buffer in characters. </td></tr>
    <tr><td class="paramname">value</td><td>The 32-bit floating-point number to be converted. </td></tr>
    <tr><td class="paramname">precision</td><td>The precision (digits after the decimal point). Default is 7, practical limit is ~7-9 digits.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the destination buffer containing the converted string.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The destination buffer must be valid and have sufficient capacity. </dd>
<dd>
The precision should be reasonable (typically ≤ 9 for float).</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The destination string is null-terminated. </dd>
<dd>
Special values (inf, -inf, nan) are properly represented. </dd>
<dd>
The result uses fixed-point notation (not scientific).</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The function handles special IEEE-754 values (infinity, NaN). </dd>
<dd>
The function does not support subnormal numbers. </dd>
<dd>
Precision beyond ~7-9 digits may not be meaningful for float. </dd>
<dd>
The function uses efficient bit manipulation for conversion. </dd>
<dd>
The function is thread-safe for single-buffer operations. </dd></dl>
<div id="dynsection-1" onclick="return dynsection.toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-1-trigger" src="../../closed.png" alt="+"/> Here is the call graph for this function:</div>
<div id="dynsection-1-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-1-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="../../d4/da9/namespacetoy_a706d142ecdd8edb11b7aa44416b06e0c_cgraph.svg" width="574" height="115"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="ad7d30f3d8737ff13c76ec6b2564b1da6" name="ad7d30f3d8737ff13c76ec6b2564b1da6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7d30f3d8737ff13c76ec6b2564b1da6">&#9670;&#160;</a></span>integerToSymbols()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t toy::integerToSymbols </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>destSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>base</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts an integer value to a string representation in a specified base. </p>
<p>This function converts a given integer value into its string representation in the specified base, storing the result in the provided destination buffer.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">type</td><td>The type of the integer value to be converted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>The destination buffer where the converted string is stored. </td></tr>
    <tr><td class="paramname">destSize</td><td>The size of the destination buffer. </td></tr>
    <tr><td class="paramname">value</td><td>The integer value to be converted. </td></tr>
    <tr><td class="paramname">base</td><td>The numerical base for the conversion, e.g., 10 for decimal, 16 for hexadecimal.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of characters written to the destination buffer.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The function assumes that the destination buffer is large enough to hold the converted string. The function does not null-terminate the string. The base must be between 2 and 36 inclusive. </dd></dl>

</div>
</div>
<a id="a20e91c14bdc302be0299332e5929908a" name="a20e91c14bdc302be0299332e5929908a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20e91c14bdc302be0299332e5929908a">&#9670;&#160;</a></span>itoa() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char * toy::itoa </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>destSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int16_t</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a 16-bit signed integer value to a string representation. </p>
<p>This function converts a given 16-bit signed integer value into its decimal string representation, storing the result in the provided destination buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>A pointer to the destination buffer where the converted string is stored. </td></tr>
    <tr><td class="paramname">destSize</td><td>The size of the destination buffer in characters. </td></tr>
    <tr><td class="paramname">value</td><td>The 16-bit signed integer value to be converted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the destination buffer containing the converted string.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The destination buffer must be valid and have sufficient capacity (at least 7 characters for worst case -32768). </dd>
<dd>
The buffer should account for the sign, digits, and null terminator.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The destination string is null-terminated. </dd>
<dd>
Negative values are properly prefixed with a minus sign.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The function handles negative values correctly. </dd>
<dd>
The function is thread-safe for single-buffer operations. </dd>
<dd>
Performance is optimized for common integer ranges. </dd></dl>

</div>
</div>
<a id="a217385ba93808d37d39421712db5b014" name="a217385ba93808d37d39421712db5b014"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a217385ba93808d37d39421712db5b014">&#9670;&#160;</a></span>itoa() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char * toy::itoa </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>destSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int32_t</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a 32-bit signed integer value to a string representation. </p>
<p>This function converts a given 32-bit signed integer value into its decimal string representation, storing the result in the provided destination buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>A pointer to the destination buffer where the converted string is stored. </td></tr>
    <tr><td class="paramname">destSize</td><td>The size of the destination buffer in characters. </td></tr>
    <tr><td class="paramname">value</td><td>The 32-bit signed integer value to be converted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the destination buffer containing the converted string.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The destination buffer must be valid and have sufficient capacity (at least 12 characters for worst case -2147483648). </dd>
<dd>
The buffer should account for the sign, digits, and null terminator.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The destination string is null-terminated. </dd>
<dd>
Negative values are properly prefixed with a minus sign.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The function handles negative values correctly. </dd>
<dd>
The function is thread-safe for single-buffer operations. </dd>
<dd>
Performance is optimized for common integer ranges. </dd></dl>

</div>
</div>
<a id="a84db9288148850a414d3253299398e7a" name="a84db9288148850a414d3253299398e7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84db9288148850a414d3253299398e7a">&#9670;&#160;</a></span>itoa() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char * toy::itoa </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>destSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int64_t</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a 64-bit signed integer value to a string representation. </p>
<p>This function converts a given 64-bit signed integer value into its decimal string representation, storing the result in the provided destination buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>A pointer to the destination buffer where the converted string is stored. </td></tr>
    <tr><td class="paramname">destSize</td><td>The size of the destination buffer in characters. </td></tr>
    <tr><td class="paramname">value</td><td>The 64-bit signed integer value to be converted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the destination buffer containing the converted string.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The destination buffer must be valid and have sufficient capacity (at least 21 characters for worst case -9223372036854775808). </dd>
<dd>
The buffer should account for the sign, digits, and null terminator.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The destination string is null-terminated. </dd>
<dd>
Negative values are properly prefixed with a minus sign.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The function handles negative values correctly. </dd>
<dd>
The function is thread-safe for single-buffer operations. </dd>
<dd>
Performance is optimized for common integer ranges. </dd></dl>

</div>
</div>
<a id="a7cbe38a6563b3443fbb3641013c6eef5" name="a7cbe38a6563b3443fbb3641013c6eef5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cbe38a6563b3443fbb3641013c6eef5">&#9670;&#160;</a></span>itoa() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char * toy::itoa </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>destSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int8_t</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts an 8-bit signed integer value to a string representation. </p>
<p>This function converts a given 8-bit signed integer value into its decimal string representation, storing the result in the provided destination buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>A pointer to the destination buffer where the converted string is stored. </td></tr>
    <tr><td class="paramname">destSize</td><td>The size of the destination buffer in characters. </td></tr>
    <tr><td class="paramname">value</td><td>The 8-bit signed integer value to be converted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the destination buffer containing the converted string.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The destination buffer must be valid and have sufficient capacity (at least 5 characters for worst case -128). </dd>
<dd>
The buffer should account for the sign, digits, and null terminator.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The destination string is null-terminated. </dd>
<dd>
Negative values are properly prefixed with a minus sign.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The function handles negative values correctly. </dd>
<dd>
The function is thread-safe for single-buffer operations. </dd>
<dd>
Performance is optimized for common integer ranges. </dd></dl>

</div>
</div>
<a id="a782b12f3bae664fb48c63effeeea0357" name="a782b12f3bae664fb48c63effeeea0357"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a782b12f3bae664fb48c63effeeea0357">&#9670;&#160;</a></span>itoa() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char * toy::itoa </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>destSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint16_t</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>base</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a 16-bit unsigned integer to a string representation in the specified base. </p>
<p>This function converts a given 16-bit unsigned integer value into its string representation in the specified numerical base, storing the result in the provided destination buffer. Supports bases from 2 to 36.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>A pointer to the destination buffer where the converted string is stored. </td></tr>
    <tr><td class="paramname">destSize</td><td>The size of the destination buffer in characters. </td></tr>
    <tr><td class="paramname">value</td><td>The 16-bit unsigned integer value to be converted. </td></tr>
    <tr><td class="paramname">base</td><td>The numerical base for the conversion (2-36). Common values: 2 (binary), 10 (decimal), 16 (hex).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the destination buffer containing the converted string.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The destination buffer must be valid and have sufficient capacity. </dd>
<dd>
The base must be between 2 and 36 inclusive.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The destination string is null-terminated. </dd>
<dd>
Hexadecimal values use uppercase letters (A-F).</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The function supports bases 2-36 with digits 0-9 and letters A-Z. </dd>
<dd>
The function is thread-safe for single-buffer operations. </dd></dl>

</div>
</div>
<a id="a4ae4e6c5cad6d6db25d552a6254b362d" name="a4ae4e6c5cad6d6db25d552a6254b362d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ae4e6c5cad6d6db25d552a6254b362d">&#9670;&#160;</a></span>itoa() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char * toy::itoa </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>destSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>base</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a 32-bit unsigned integer to a string representation in the specified base. </p>
<p>This function converts a given 32-bit unsigned integer value into its string representation in the specified numerical base, storing the result in the provided destination buffer. Supports bases from 2 to 36.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>A pointer to the destination buffer where the converted string is stored. </td></tr>
    <tr><td class="paramname">destSize</td><td>The size of the destination buffer in characters. </td></tr>
    <tr><td class="paramname">value</td><td>The 32-bit unsigned integer value to be converted. </td></tr>
    <tr><td class="paramname">base</td><td>The numerical base for the conversion (2-36). Common values: 2 (binary), 10 (decimal), 16 (hex).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the destination buffer containing the converted string.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The destination buffer must be valid and have sufficient capacity. </dd>
<dd>
The base must be between 2 and 36 inclusive.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The destination string is null-terminated. </dd>
<dd>
Hexadecimal values use uppercase letters (A-F).</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The function supports bases 2-36 with digits 0-9 and letters A-Z. </dd>
<dd>
The function is thread-safe for single-buffer operations. </dd></dl>

</div>
</div>
<a id="a85d2dc4a41dd3f21c08bc7565ca499b2" name="a85d2dc4a41dd3f21c08bc7565ca499b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85d2dc4a41dd3f21c08bc7565ca499b2">&#9670;&#160;</a></span>itoa() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char * toy::itoa </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>destSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint64_t</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>base</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a 64-bit unsigned integer to a string representation in the specified base. </p>
<p>This function converts a given 64-bit unsigned integer value into its string representation in the specified numerical base, storing the result in the provided destination buffer. Supports bases from 2 to 36.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>A pointer to the destination buffer where the converted string is stored. </td></tr>
    <tr><td class="paramname">destSize</td><td>The size of the destination buffer in characters. </td></tr>
    <tr><td class="paramname">value</td><td>The 64-bit unsigned integer value to be converted. </td></tr>
    <tr><td class="paramname">base</td><td>The numerical base for the conversion (2-36). Common values: 2 (binary), 10 (decimal), 16 (hex).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the destination buffer containing the converted string.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The destination buffer must be valid and have sufficient capacity. </dd>
<dd>
The base must be between 2 and 36 inclusive.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The destination string is null-terminated. </dd>
<dd>
Hexadecimal values use uppercase letters (A-F).</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The function supports bases 2-36 with digits 0-9 and letters A-Z. </dd>
<dd>
The function is thread-safe for single-buffer operations. </dd></dl>

</div>
</div>
<a id="a23fc801de24bb0daa8db0b2eec615c4d" name="a23fc801de24bb0daa8db0b2eec615c4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23fc801de24bb0daa8db0b2eec615c4d">&#9670;&#160;</a></span>itoa() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char * toy::itoa </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>destSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>base</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts an 8-bit unsigned integer to a string representation in the specified base. </p>
<p>This function converts a given 8-bit unsigned integer value into its string representation in the specified numerical base, storing the result in the provided destination buffer. Supports bases from 2 to 36.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>A pointer to the destination buffer where the converted string is stored. </td></tr>
    <tr><td class="paramname">destSize</td><td>The size of the destination buffer in characters. </td></tr>
    <tr><td class="paramname">value</td><td>The 8-bit unsigned integer value to be converted. </td></tr>
    <tr><td class="paramname">base</td><td>The numerical base for the conversion (2-36). Common values: 2 (binary), 10 (decimal), 16 (hex).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the destination buffer containing the converted string.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The destination buffer must be valid and have sufficient capacity. </dd>
<dd>
The base must be between 2 and 36 inclusive.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The destination string is null-terminated. </dd>
<dd>
Hexadecimal values use uppercase letters (A-F).</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The function supports bases 2-36 with digits 0-9 and letters A-Z. </dd>
<dd>
The function is thread-safe for single-buffer operations. </dd></dl>

</div>
</div>
<a id="a325d3850ce833eab7c97a3eac78559a3" name="a325d3850ce833eab7c97a3eac78559a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a325d3850ce833eab7c97a3eac78559a3">&#9670;&#160;</a></span>itoaImplementation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char * toy::itoaImplementation </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>destSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts an integer value to a string representation. </p>
<p>This function converts a given integer value into its string representation, storing the result in the provided destination buffer.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">type</td><td>The type of the integer value to be converted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>The destination buffer where the converted string is stored. </td></tr>
    <tr><td class="paramname">destSize</td><td>The size of the destination buffer. </td></tr>
    <tr><td class="paramname">value</td><td>The integer value to be converted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the destination buffer containing the converted string.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The function assumes that the destination buffer is large enough to hold the converted string. If the destination buffer size is 1, only a null terminator is written. The function reverses the string in-place. </dd></dl>

</div>
</div>
<a id="a356a3fceab84ce068ff702d19893708b" name="a356a3fceab84ce068ff702d19893708b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a356a3fceab84ce068ff702d19893708b">&#9670;&#160;</a></span>operator+() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t allocatedSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html">FixedString</a>&lt; allocatedSize &gt; toy::operator+ </td>
          <td>(</td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html">FixedString</a>&lt; allocatedSize &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenation operator for character and <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a>. </p>
<p>This operator creates a new <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> object by concatenating a single character with a <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a>. The result will contain the character from the left-hand side followed by the characters from the right-hand side.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The character to prepend to the <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a>. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> object containing the concatenated result.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The result size will be the sum of both input sizes, must not exceed the allocated size. </dd></dl>

</div>
</div>
<a id="a2fef40d514c1a38e96d004926fe183d6" name="a2fef40d514c1a38e96d004926fe183d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fef40d514c1a38e96d004926fe183d6">&#9670;&#160;</a></span>operator+() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t allocatedSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html">FixedString</a>&lt; allocatedSize &gt; toy::operator+ </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html">FixedString</a>&lt; allocatedSize &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenation operator for C-string and <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a>. </p>
<p>This operator creates a new <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> object by concatenating a C-string with a <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a>. The result will contain the characters from the left-hand side followed by the characters from the right-hand side.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">allocatedSize</td><td>The size of the <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a>'s internal buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side C-string (null-terminated). </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> object containing the concatenated result.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The result size will be the sum of both input sizes, must not exceed the allocated size. </dd>
<dd>
The C-string must be null-terminated. </dd></dl>

</div>
</div>
<a id="a326a560f0c3c0d12d9c7a8642d001e6d" name="a326a560f0c3c0d12d9c7a8642d001e6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a326a560f0c3c0d12d9c7a8642d001e6d">&#9670;&#160;</a></span>operator+() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t allocatedSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html">FixedString</a>&lt; allocatedSize &gt; toy::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html">FixedString</a>&lt; allocatedSize &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenation operator for <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> and character. </p>
<p>This operator creates a new <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> object by concatenating a <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> with a single character. The result will contain the characters from the left-hand side followed by the character from the right-hand side.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> object. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side character.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> object containing the concatenated result.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The result size will be the sum of both input sizes, must not exceed the allocated size. </dd></dl>

</div>
</div>
<a id="affd1da1d9c8f6ce96223f0321ca1efef" name="affd1da1d9c8f6ce96223f0321ca1efef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affd1da1d9c8f6ce96223f0321ca1efef">&#9670;&#160;</a></span>operator+() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t allocatedSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html">FixedString</a>&lt; allocatedSize &gt; toy::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html">FixedString</a>&lt; allocatedSize &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenation operator for <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> and C-string. </p>
<p>This operator creates a new <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> object by concatenating a <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> with a C-string. The result will contain the characters from the left-hand side followed by the characters from the right-hand side.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">allocatedSize</td><td>The size of the <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a>'s internal buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> object. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side C-string (null-terminated).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> object containing the concatenated result.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The result size will be the sum of both input sizes, must not exceed the allocated size. </dd>
<dd>
The C-string must be null-terminated. </dd></dl>

</div>
</div>
<a id="a66eecb2acd9da94710c77b796f60cb21" name="a66eecb2acd9da94710c77b796f60cb21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66eecb2acd9da94710c77b796f60cb21">&#9670;&#160;</a></span>operator+() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t allocatedSize, StringLike stringType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html">FixedString</a>&lt; allocatedSize &gt; toy::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html">FixedString</a>&lt; allocatedSize &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const stringType &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenation operator for <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> and <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> object. </p>
<p>This operator creates a new <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> object by concatenating a <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> with any <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> object. The result will contain the characters from the left-hand side followed by the characters from the right-hand side.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">allocatedSize</td><td>The size of the <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a>'s internal buffer. </td></tr>
    <tr><td class="paramname">stringType</td><td>The type of the <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> object. Must satisfy the <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> concept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> object. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> object containing the concatenated result.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The result size will be the sum of both input sizes, must not exceed the allocated size. </dd></dl>

</div>
</div>
<a id="ac789c531cca9ded2d4866edf6d7b9ed5" name="ac789c531cca9ded2d4866edf6d7b9ed5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac789c531cca9ded2d4866edf6d7b9ed5">&#9670;&#160;</a></span>operator+() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t allocatedSize1, std::size_t allocatedSize2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html">FixedString</a>&lt; allocatedSize1 &gt; toy::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html">FixedString</a>&lt; allocatedSize1 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html">FixedString</a>&lt; allocatedSize2 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenation operator for two <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> objects. </p>
<p>This operator creates a new <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> object by concatenating the contents of two <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> objects. The result will contain the characters from the left-hand side followed by the characters from the right-hand side.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">allocatedSize1</td><td>The size of the first <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a>'s internal buffer. </td></tr>
    <tr><td class="paramname">allocatedSize2</td><td>The size of the second <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a>'s internal buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> object. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> object containing the concatenated result.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The result size will be the sum of both input sizes, must not exceed the allocated size. </dd></dl>

</div>
</div>
<a id="a3e935013c7764b31202b25105a86cedd" name="a3e935013c7764b31202b25105a86cedd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e935013c7764b31202b25105a86cedd">&#9670;&#160;</a></span>operator+() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;StringLike stringType, std::size_t allocatedSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html">FixedString</a>&lt; allocatedSize &gt; toy::operator+ </td>
          <td>(</td>
          <td class="paramtype">const stringType &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html">FixedString</a>&lt; allocatedSize &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenation operator for <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> object and <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a>. </p>
<p>This operator creates a new <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> object by concatenating any <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> object with a <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a>. The result will contain the characters from the left-hand side followed by the characters from the right-hand side.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">stringType</td><td>The type of the <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> object. Must satisfy the <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> concept. </td></tr>
    <tr><td class="paramname">allocatedSize</td><td>The size of the <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a>'s internal buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> object. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> object containing the concatenated result.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The result size will be the sum of both input sizes, must not exceed the allocated size. </dd></dl>

</div>
</div>
<a id="ab856389c5db41137391343498eb280a2" name="ab856389c5db41137391343498eb280a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab856389c5db41137391343498eb280a2">&#9670;&#160;</a></span>operator&lt;=&gt;() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::strong_ordering toy::operator&lt;=&gt; </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html">CStringView</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Three-way comparison operator for C string and <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html">CStringView</a>. </p>
<p>This operator provides a three-way comparison between a C string and a <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html">CStringView</a> object. It returns a std::strong_ordering value that indicates the relationship between the strings.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The C string to compare. </td></tr>
    <tr><td class="paramname">rhs</td><td>The <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html">CStringView</a> object to compare.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::strong_ordering::less if <em>lhs</em> is lexicographically less than <em>rhs</em>, std::strong_ordering::equal if they are equal, or std::strong_ordering::greater if <em>lhs</em> is lexicographically greater than <em>rhs</em>.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The <em>lhs</em> pointer must not be null.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The comparison is case-sensitive. </dd>
<dd>
The comparison is performed lexicographically character by character. </dd>
<dd>
Empty strings are considered equal.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>std::strong_ordering </dd>
<dd>
<a class="el" href="#a71f575fa58def2abe56c129ff51a3696" title="Equality comparison operator for C string and CStringView.">operator==(const char *, const CStringView &amp;)</a> </dd></dl>

</div>
</div>
<a id="a876dcc65c97b11b3e32289867cd11a56" name="a876dcc65c97b11b3e32289867cd11a56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a876dcc65c97b11b3e32289867cd11a56">&#9670;&#160;</a></span>operator&lt;=&gt;() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t allocatedSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::strong_ordering toy::operator&lt;=&gt; </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html">FixedString</a>&lt; allocatedSize &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Three-way comparison operator for C string and <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a>. </p>
<p>This operator provides a three-way comparison between a C string and a <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> object. It returns a std::strong_ordering value that indicates the relationship between the strings.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">allocatedSize</td><td>The size of the <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a>'s internal buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The C string to compare. </td></tr>
    <tr><td class="paramname">rhs</td><td>The <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> object to compare.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::strong_ordering::less if <em>lhs</em> is lexicographically less than <em>rhs</em>, std::strong_ordering::equal if they are equal, or std::strong_ordering::greater if <em>lhs</em> is lexicographically greater than <em>rhs</em>.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The <em>lhs</em> pointer must not be null.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The comparison is case-sensitive. </dd>
<dd>
The comparison is performed lexicographically character by character. </dd>
<dd>
Empty strings are considered equal.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>std::strong_ordering </dd>
<dd>
<a class="el" href="#a5568d083a1e1f805d9a0b9e22d3ea00d" title="Equality comparison operator for C string and FixedString.">operator==(const char *, const FixedString&lt;allocatedSize&gt; &amp;)</a> </dd></dl>

</div>
</div>
<a id="ad9aa91580633549a095c7ba702bee9d9" name="ad9aa91580633549a095c7ba702bee9d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9aa91580633549a095c7ba702bee9d9">&#9670;&#160;</a></span>operator&lt;=&gt;() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::strong_ordering toy::operator&lt;=&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html">CStringView</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Three-way comparison operator for <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html">CStringView</a> and C string. </p>
<p>This operator provides a three-way comparison between a <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html">CStringView</a> object and a C string. It returns a std::strong_ordering value that indicates the relationship between the strings.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html">CStringView</a> object to compare. </td></tr>
    <tr><td class="paramname">rhs</td><td>The C string to compare.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::strong_ordering::less if <em>lhs</em> is lexicographically less than <em>rhs</em>, std::strong_ordering::equal if they are equal, or std::strong_ordering::greater if <em>lhs</em> is lexicographically greater than <em>rhs</em>.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The <em>rhs</em> pointer must not be null.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The comparison is case-sensitive. </dd>
<dd>
The comparison is performed lexicographically character by character. </dd>
<dd>
Empty strings are considered equal.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>std::strong_ordering </dd>
<dd>
<a class="el" href="#a3761711b53e204a0f2871764d435fd35" title="Equality comparison operator for CStringView and C string.">operator==(const CStringView &amp;, const char *)</a> </dd></dl>

</div>
</div>
<a id="af959d0dc5fc118ec5c65f27143180021" name="af959d0dc5fc118ec5c65f27143180021"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af959d0dc5fc118ec5c65f27143180021">&#9670;&#160;</a></span>operator&lt;=&gt;() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::strong_ordering toy::operator&lt;=&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html">CStringView</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html">CStringView</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Three-way comparison operator for <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html">CStringView</a> objects. </p>
<p>This operator provides a three-way comparison between two <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html">CStringView</a> objects. It returns a std::strong_ordering value that indicates the relationship between the string views.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html">CStringView</a> object to compare. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html">CStringView</a> object to compare.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::strong_ordering::less if <em>lhs</em> is lexicographically less than <em>rhs</em>, std::strong_ordering::equal if they are equal, or std::strong_ordering::greater if <em>lhs</em> is lexicographically greater than <em>rhs</em>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The comparison is case-sensitive. </dd>
<dd>
The comparison is performed lexicographically character by character. </dd>
<dd>
Empty string views are considered equal.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>std::strong_ordering </dd>
<dd>
<a class="el" href="#a3a8c65476e352b7f64a0bf15ddc87747" title="Equality comparison operator for two CStringView objects.">operator==(const CStringView &amp;, const CStringView &amp;)</a> </dd></dl>

</div>
</div>
<a id="a2571fe89aa51139ddbb04bc1fdd0585c" name="a2571fe89aa51139ddbb04bc1fdd0585c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2571fe89aa51139ddbb04bc1fdd0585c">&#9670;&#160;</a></span>operator&lt;=&gt;() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;StringLike stringType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::strong_ordering toy::operator&lt;=&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html">CStringView</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const stringType &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Three-way comparison operator for <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html">CStringView</a> and <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> object. </p>
<p>This operator provides a three-way comparison between a <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html">CStringView</a> object and a <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> object. It returns a std::strong_ordering value that indicates the relationship between the strings.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">stringType</td><td>The type of the <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> object. Must satisfy the <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> concept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html">CStringView</a> object to compare. </td></tr>
    <tr><td class="paramname">rhs</td><td>The <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> object to compare.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::strong_ordering::less if <em>lhs</em> is lexicographically less than <em>rhs</em>, std::strong_ordering::equal if they are equal, or std::strong_ordering::greater if <em>lhs</em> is lexicographically greater than <em>rhs</em>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The comparison is case-sensitive. </dd>
<dd>
The comparison is performed lexicographically character by character. </dd>
<dd>
Empty strings are considered equal.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>std::strong_ordering </dd>
<dd>
<a class="el" href="#a3ae46d261b42cdcd0e59b395aebdc834" title="Equality comparison operator for CStringView and StringLike object.">operator==(const CStringView &amp;, const stringType &amp;)</a> </dd></dl>

</div>
</div>
<a id="a46515295e8eafc3e748d0c02ad5ecd70" name="a46515295e8eafc3e748d0c02ad5ecd70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46515295e8eafc3e748d0c02ad5ecd70">&#9670;&#160;</a></span>operator&lt;=&gt;() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t allocatedSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::strong_ordering toy::operator&lt;=&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html">FixedString</a>&lt; allocatedSize &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Three-way comparison operator for <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> and C string. </p>
<p>This operator provides a three-way comparison between a <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> object and a C string. It returns a std::strong_ordering value that indicates the relationship between the strings.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">allocatedSize</td><td>The size of the <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a>'s internal buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> object to compare. </td></tr>
    <tr><td class="paramname">rhs</td><td>The C string to compare.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::strong_ordering::less if <em>lhs</em> is lexicographically less than <em>rhs</em>, std::strong_ordering::equal if they are equal, or std::strong_ordering::greater if <em>lhs</em> is lexicographically greater than <em>rhs</em>.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The <em>rhs</em> pointer must not be null.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The comparison is case-sensitive. </dd>
<dd>
The comparison is performed lexicographically character by character. </dd>
<dd>
Empty strings are considered equal.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>std::strong_ordering </dd>
<dd>
<a class="el" href="#a6e7299d83e4f5d41d4951f84a44abdf4" title="Equality comparison operator for FixedString and C string.">operator==(const FixedString&lt;allocatedSize&gt; &amp;, const char *)</a> </dd></dl>

</div>
</div>
<a id="a600f056ee510aa623a7eec926077d0d2" name="a600f056ee510aa623a7eec926077d0d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a600f056ee510aa623a7eec926077d0d2">&#9670;&#160;</a></span>operator&lt;=&gt;() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t allocatedSize, StringLike stringType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::strong_ordering toy::operator&lt;=&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html">FixedString</a>&lt; allocatedSize &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const stringType &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Three-way comparison operator for <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> and <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> object. </p>
<p>This operator provides a three-way comparison between a <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> object and a <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> object. It returns a std::strong_ordering value that indicates the relationship between the strings.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">allocatedSize</td><td>The size of the <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a>'s internal buffer. </td></tr>
    <tr><td class="paramname">stringType</td><td>The type of the <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> object. Must satisfy the <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> concept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> object to compare. </td></tr>
    <tr><td class="paramname">rhs</td><td>The <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> object to compare.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::strong_ordering::less if <em>lhs</em> is lexicographically less than <em>rhs</em>, std::strong_ordering::equal if they are equal, or std::strong_ordering::greater if <em>lhs</em> is lexicographically greater than <em>rhs</em>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The comparison is case-sensitive. </dd>
<dd>
The comparison is performed lexicographically character by character. </dd>
<dd>
Empty strings are considered equal.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>std::strong_ordering </dd>
<dd>
<a class="el" href="#a718df287209b3adb957de9de67f9d863" title="Equality comparison operator for FixedString and StringLike object.">operator==(const FixedString&lt;allocatedSize&gt; &amp;, const stringType &amp;)</a> </dd></dl>

</div>
</div>
<a id="a3a3d16e98341489a2ba4e77d76e72e4f" name="a3a3d16e98341489a2ba4e77d76e72e4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a3d16e98341489a2ba4e77d76e72e4f">&#9670;&#160;</a></span>operator&lt;=&gt;() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t allocatedSize1, std::size_t allocatedSize2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::strong_ordering toy::operator&lt;=&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html">FixedString</a>&lt; allocatedSize1 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html">FixedString</a>&lt; allocatedSize2 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Three-way comparison operator for <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> objects. </p>
<p>This operator provides a three-way comparison between two <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> objects. It returns a std::strong_ordering value that indicates the relationship between the strings.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">allocatedSize1</td><td>The size of the first <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a>'s internal buffer. </td></tr>
    <tr><td class="paramname">allocatedSize2</td><td>The size of the second <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a>'s internal buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> object to compare. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> object to compare.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::strong_ordering::less if <em>lhs</em> is lexicographically less than <em>rhs</em>, std::strong_ordering::equal if they are equal, or std::strong_ordering::greater if <em>lhs</em> is lexicographically greater than <em>rhs</em>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The comparison is case-sensitive. </dd>
<dd>
The comparison is performed lexicographically character by character. </dd>
<dd>
Empty strings are considered equal.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>std::strong_ordering </dd>
<dd>
<a class="el" href="#acf758a094d8de5ef108ef3e984c37cf1" title="Equality comparison operator for two FixedString objects.">operator==(const FixedString&lt;allocatedSize1&gt; &amp;, const FixedString&lt;allocatedSize2&gt; &amp;)</a> </dd></dl>

</div>
</div>
<a id="ac327b00da21b55bf3cd1817280a52315" name="ac327b00da21b55bf3cd1817280a52315"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac327b00da21b55bf3cd1817280a52315">&#9670;&#160;</a></span>operator&lt;=&gt;() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;StringLike stringType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::strong_ordering toy::operator&lt;=&gt; </td>
          <td>(</td>
          <td class="paramtype">const stringType &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html">CStringView</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Three-way comparison operator for <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> object and <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html">CStringView</a>. </p>
<p>This operator provides a three-way comparison between a <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> object and a <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html">CStringView</a> object. It returns a std::strong_ordering value that indicates the relationship between the strings.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">stringType</td><td>The type of the <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> object. Must satisfy the <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> concept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> object to compare. </td></tr>
    <tr><td class="paramname">rhs</td><td>The <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html">CStringView</a> object to compare.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::strong_ordering::less if <em>lhs</em> is lexicographically less than <em>rhs</em>, std::strong_ordering::equal if they are equal, or std::strong_ordering::greater if <em>lhs</em> is lexicographically greater than <em>rhs</em>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The comparison is case-sensitive. </dd>
<dd>
The comparison is performed lexicographically character by character. </dd>
<dd>
Empty strings are considered equal.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>std::strong_ordering </dd>
<dd>
<a class="el" href="#ac0c288d93fdbf4dba71c4309203d9047" title="Equality comparison operator for StringLike object and CStringView.">operator==(const stringType &amp;, const CStringView &amp;)</a> </dd></dl>

</div>
</div>
<a id="a5d95d2f2437840de99f597f291f3d9f9" name="a5d95d2f2437840de99f597f291f3d9f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d95d2f2437840de99f597f291f3d9f9">&#9670;&#160;</a></span>operator&lt;=&gt;() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;StringLike stringType, std::size_t allocatedSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::strong_ordering toy::operator&lt;=&gt; </td>
          <td>(</td>
          <td class="paramtype">const stringType &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html">FixedString</a>&lt; allocatedSize &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Three-way comparison operator for <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> object and <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a>. </p>
<p>This operator provides a three-way comparison between a <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> object and a <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> object. It returns a std::strong_ordering value that indicates the relationship between the strings.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">stringType</td><td>The type of the <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> object. Must satisfy the <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> concept. </td></tr>
    <tr><td class="paramname">allocatedSize</td><td>The size of the <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a>'s internal buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> object to compare. </td></tr>
    <tr><td class="paramname">rhs</td><td>The <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> object to compare.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::strong_ordering::less if <em>lhs</em> is lexicographically less than <em>rhs</em>, std::strong_ordering::equal if they are equal, or std::strong_ordering::greater if <em>lhs</em> is lexicographically greater than <em>rhs</em>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The comparison is case-sensitive. </dd>
<dd>
The comparison is performed lexicographically character by character. </dd>
<dd>
Empty strings are considered equal.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>std::strong_ordering </dd>
<dd>
<a class="el" href="#a300e65bc1fbafecbcf63f47317198ec4" title="Equality comparison operator for StringLike object and FixedString.">operator==(const stringType &amp;, const FixedString&lt;allocatedSize&gt; &amp;)</a> </dd></dl>

</div>
</div>
<a id="a71f575fa58def2abe56c129ff51a3696" name="a71f575fa58def2abe56c129ff51a3696"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71f575fa58def2abe56c129ff51a3696">&#9670;&#160;</a></span>operator==() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool toy::operator== </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html">CStringView</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison operator for C string and <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html">CStringView</a>. </p>
<p>This operator compares a C string with a <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html">CStringView</a> object for equality.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The C string. </td></tr>
    <tr><td class="paramname">rhs</td><td>The <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html">CStringView</a> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if both strings have the same content, false otherwise.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The <em>lhs</em> pointer must not be null.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The comparison is case-sensitive. </dd>
<dd>
Empty strings are considered equal.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ab856389c5db41137391343498eb280a2" title="Three-way comparison operator for C string and CStringView.">operator&lt;=&gt;(const char *, const CStringView &amp;)</a> </dd></dl>

</div>
</div>
<a id="a5568d083a1e1f805d9a0b9e22d3ea00d" name="a5568d083a1e1f805d9a0b9e22d3ea00d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5568d083a1e1f805d9a0b9e22d3ea00d">&#9670;&#160;</a></span>operator==() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t allocatedSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool toy::operator== </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html">FixedString</a>&lt; allocatedSize &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison operator for C string and <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a>. </p>
<p>This operator compares a C string with a <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> object for equality.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">allocatedSize</td><td>The size of the <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a>'s internal buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The C string. </td></tr>
    <tr><td class="paramname">rhs</td><td>The <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if both strings have the same content, false otherwise.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The <em>lhs</em> pointer must not be null.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The comparison is case-sensitive. </dd>
<dd>
Empty strings are considered equal.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a876dcc65c97b11b3e32289867cd11a56" title="Three-way comparison operator for C string and FixedString.">operator&lt;=&gt;(const char *, const FixedString&lt;allocatedSize&gt; &amp;)</a> </dd></dl>

</div>
</div>
<a id="a3761711b53e204a0f2871764d435fd35" name="a3761711b53e204a0f2871764d435fd35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3761711b53e204a0f2871764d435fd35">&#9670;&#160;</a></span>operator==() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool toy::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html">CStringView</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison operator for <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html">CStringView</a> and C string. </p>
<p>This operator compares a <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html">CStringView</a> object with a C string for equality.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html">CStringView</a> object. </td></tr>
    <tr><td class="paramname">rhs</td><td>The C string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if both strings have the same content, false otherwise.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The <em>rhs</em> pointer must not be null.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The comparison is case-sensitive. </dd>
<dd>
Empty strings are considered equal.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ad9aa91580633549a095c7ba702bee9d9" title="Three-way comparison operator for CStringView and C string.">operator&lt;=&gt;(const CStringView &amp;, const char *)</a> </dd></dl>

</div>
</div>
<a id="a3a8c65476e352b7f64a0bf15ddc87747" name="a3a8c65476e352b7f64a0bf15ddc87747"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a8c65476e352b7f64a0bf15ddc87747">&#9670;&#160;</a></span>operator==() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool toy::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html">CStringView</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html">CStringView</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison operator for two <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html">CStringView</a> objects. </p>
<p>This operator compares two <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html">CStringView</a> objects for equality. The comparison is performed character by character.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html">CStringView</a> object. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html">CStringView</a> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if both strings view have the same content, false otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The comparison is case-sensitive. </dd>
<dd>
Empty string views are considered equal.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#af959d0dc5fc118ec5c65f27143180021" title="Three-way comparison operator for CStringView objects.">operator&lt;=&gt;(const CStringView &amp;, const CStringView &amp;)</a> </dd></dl>

</div>
</div>
<a id="a3ae46d261b42cdcd0e59b395aebdc834" name="a3ae46d261b42cdcd0e59b395aebdc834"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ae46d261b42cdcd0e59b395aebdc834">&#9670;&#160;</a></span>operator==() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;StringLike stringType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool toy::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html">CStringView</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const stringType &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison operator for <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html">CStringView</a> and <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> object. </p>
<p>This operator compares a <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html">CStringView</a> object with a <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> object for equality.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">stringType</td><td>The type of the <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> object. Must satisfy the <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> concept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html">CStringView</a> object. </td></tr>
    <tr><td class="paramname">rhs</td><td>The <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if both strings have the same content, false otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The comparison is case-sensitive. </dd>
<dd>
Empty strings are considered equal.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a2571fe89aa51139ddbb04bc1fdd0585c" title="Three-way comparison operator for CStringView and StringLike object.">operator&lt;=&gt;(const CStringView &amp;, const stringType &amp;)</a> </dd></dl>

</div>
</div>
<a id="a6e7299d83e4f5d41d4951f84a44abdf4" name="a6e7299d83e4f5d41d4951f84a44abdf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e7299d83e4f5d41d4951f84a44abdf4">&#9670;&#160;</a></span>operator==() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t allocatedSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool toy::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html">FixedString</a>&lt; allocatedSize &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison operator for <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> and C string. </p>
<p>This operator compares a <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> object with a C string for equality.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">allocatedSize</td><td>The size of the <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a>'s internal buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> object. </td></tr>
    <tr><td class="paramname">rhs</td><td>The C string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if both strings have the same content, false otherwise.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The <em>rhs</em> pointer must not be null.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The comparison is case-sensitive. </dd>
<dd>
Empty strings are considered equal.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a46515295e8eafc3e748d0c02ad5ecd70" title="Three-way comparison operator for FixedString and C string.">operator&lt;=&gt;(const FixedString&lt;allocatedSize&gt; &amp;, const char *)</a> </dd></dl>

</div>
</div>
<a id="a718df287209b3adb957de9de67f9d863" name="a718df287209b3adb957de9de67f9d863"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a718df287209b3adb957de9de67f9d863">&#9670;&#160;</a></span>operator==() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t allocatedSize, StringLike stringType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool toy::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html">FixedString</a>&lt; allocatedSize &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const stringType &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison operator for <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> and <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> object. </p>
<p>This operator compares a <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> object with a <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> object for equality.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">allocatedSize</td><td>The size of the <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a>'s internal buffer. </td></tr>
    <tr><td class="paramname">stringType</td><td>The type of the <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> object. Must satisfy the <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> concept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> object. </td></tr>
    <tr><td class="paramname">rhs</td><td>The <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if both strings have the same content, false otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The comparison is case-sensitive. </dd>
<dd>
Empty strings are considered equal.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a600f056ee510aa623a7eec926077d0d2" title="Three-way comparison operator for FixedString and StringLike object.">operator&lt;=&gt;(const FixedString&lt;allocatedSize&gt; &amp;, const stringType &amp;)</a> </dd></dl>

</div>
</div>
<a id="acf758a094d8de5ef108ef3e984c37cf1" name="acf758a094d8de5ef108ef3e984c37cf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf758a094d8de5ef108ef3e984c37cf1">&#9670;&#160;</a></span>operator==() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t allocatedSize1, std::size_t allocatedSize2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool toy::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html">FixedString</a>&lt; allocatedSize1 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html">FixedString</a>&lt; allocatedSize2 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison operator for two <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> objects. </p>
<p>This operator compares two <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> objects for equality. The comparison is performed character by character.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">allocatedSize1</td><td>The size of the first <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a>'s internal buffer. </td></tr>
    <tr><td class="paramname">allocatedSize2</td><td>The size of the second <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a>'s internal buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> object. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if both strings have the same content, false otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The comparison is case-sensitive. </dd>
<dd>
Empty strings are considered equal.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a3a3d16e98341489a2ba4e77d76e72e4f" title="Three-way comparison operator for FixedString objects.">operator&lt;=&gt;(const FixedString&lt;allocatedSize1&gt; &amp;, const FixedString&lt;allocatedSize2&gt; &amp;)</a> </dd></dl>

</div>
</div>
<a id="ac0c288d93fdbf4dba71c4309203d9047" name="ac0c288d93fdbf4dba71c4309203d9047"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0c288d93fdbf4dba71c4309203d9047">&#9670;&#160;</a></span>operator==() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;StringLike stringType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool toy::operator== </td>
          <td>(</td>
          <td class="paramtype">const stringType &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html">CStringView</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison operator for <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> object and <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html">CStringView</a>. </p>
<p>This operator compares a <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> object with a <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html">CStringView</a> object for equality.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">stringType</td><td>The type of the <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> object. Must satisfy the <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> concept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> object. </td></tr>
    <tr><td class="paramname">rhs</td><td>The <a class="el" href="../../d5/d03/classtoy_1_1_c_string_view.html">CStringView</a> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if both strings have the same content, false otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The comparison is case-sensitive. </dd>
<dd>
Empty strings are considered equal.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ac327b00da21b55bf3cd1817280a52315" title="Three-way comparison operator for StringLike object and CStringView.">operator&lt;=&gt;(const stringType &amp;, const CStringView &amp;)</a> </dd></dl>

</div>
</div>
<a id="a300e65bc1fbafecbcf63f47317198ec4" name="a300e65bc1fbafecbcf63f47317198ec4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a300e65bc1fbafecbcf63f47317198ec4">&#9670;&#160;</a></span>operator==() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;StringLike stringType, std::size_t allocatedSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool toy::operator== </td>
          <td>(</td>
          <td class="paramtype">const stringType &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html">FixedString</a>&lt; allocatedSize &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison operator for <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> object and <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a>. </p>
<p>This operator compares a <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> object with a <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> object for equality.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">stringType</td><td>The type of the <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> object. Must satisfy the <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> concept. </td></tr>
    <tr><td class="paramname">allocatedSize</td><td>The size of the <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a>'s internal buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> object. </td></tr>
    <tr><td class="paramname">rhs</td><td>The <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if both strings have the same content, false otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The comparison is case-sensitive. </dd>
<dd>
Empty strings are considered equal.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a5d95d2f2437840de99f597f291f3d9f9" title="Three-way comparison operator for StringLike object and FixedString.">operator&lt;=&gt;(const stringType &amp;, const FixedString&lt;allocatedSize&gt; &amp;)</a> </dd></dl>

</div>
</div>
<a id="a08e2e765a94dee108e646fd69fe7b535" name="a08e2e765a94dee108e646fd69fe7b535"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08e2e765a94dee108e646fd69fe7b535">&#9670;&#160;</a></span>reverseString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char * toy::reverseString </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>count</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reverses a given string in-place. </p>
<p>This function reverses a given string in-place by swapping characters from both ends towards the center. It can be used to reverse a string of a specified length, or to reverse a null-terminated string when count is 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>A pointer to the string to reverse. </td></tr>
    <tr><td class="paramname">count</td><td>The length of the string to reverse. If 0, the function determines the length automatically.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the reversed string (same as input pointer).</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The input string pointer must be valid. </dd>
<dd>
If count &gt; 0, the string must have at least count characters. </dd>
<dd>
If count = 0, the string must be null-terminated.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The string is modified in-place with characters in reverse order. </dd>
<dd>
The function returns the same pointer that was passed in.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The function modifies the original string directly. </dd>
<dd>
When count = 0, the function calls strlen() to determine the string length. </dd>
<dd>
The function is efficient with O(n/2) character swaps. </dd>
<dd>
The function is thread-safe for single-string operations. </dd>
<dd>
Performance is optimized for common string lengths. </dd></dl>

</div>
</div>
<a id="a4d645acb64c01923ca7a9ab11c0ae7f0" name="a4d645acb64c01923ca7a9ab11c0ae7f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d645acb64c01923ca7a9ab11c0ae7f0">&#9670;&#160;</a></span>utf8Len()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t toy::utf8Len </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of Unicode characters in a UTF-8 encoded string. </p>
<p>This function counts the number of Unicode characters in a UTF-8 encoded string by parsing UTF-8 sequences. It stops counting when the null character is encountered.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>A pointer to the UTF-8 encoded string to count characters in.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of Unicode characters in the string, or 0 if the string is invalid or null.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The input string must be a valid UTF-8 encoded string. </dd>
<dd>
The string must be null-terminated.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The function returns 0 for null pointers or invalid UTF-8 sequences. </dd>
<dd>
The function correctly counts multi-byte UTF-8 sequences as single characters.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The function validates UTF-8 sequences during counting. </dd>
<dd>
Multi-byte sequences (2-3 bytes) are counted as single Unicode characters. </dd>
<dd>
The function is thread-safe for read operations. </dd>
<dd>
Performance is optimized for common UTF-8 patterns. </dd>
<dd>
Invalid UTF-8 sequences cause the function to return 0. </dd></dl>

</div>
</div>
<a id="a9dbda78acf36cc3d5cf3f59eb80232bc" name="a9dbda78acf36cc3d5cf3f59eb80232bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dbda78acf36cc3d5cf3f59eb80232bc">&#9670;&#160;</a></span>utf8toWChar() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">wchar_t * toy::utf8toWChar </td>
          <td>(</td>
          <td class="paramtype">wchar_t *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>destSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const</td>          <td class="paramname"><span class="paramname"><em>src</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a Unicode UTF-8 encoded string to a wide character string. </p>
<p>This function translates a null-terminated UTF-8 encoded source string into a wide character string. The conversion stops when the source string ends or the destination buffer is filled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>A pointer to the destination buffer where the converted wide character string will be stored. </td></tr>
    <tr><td class="paramname">destSize</td><td>The size of the destination buffer in wide characters (not bytes). </td></tr>
    <tr><td class="paramname">src</td><td>A pointer to the null-terminated source UTF-8 encoded string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the destination wide character string, or nullptr if the destination buffer is invalid.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The destination buffer must be valid and have sufficient capacity. </dd>
<dd>
The source string must be a valid null-terminated UTF-8 encoded string.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The destination string is null-terminated. </dd>
<dd>
The function returns nullptr on buffer overflow or invalid input.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Only BMP (≤ 0xFFFF) characters are supported by design; 4-byte UTF-8 sequences are not produced. </dd>
<dd>
This is an inline wrapper around the main utf8toWChar function. </dd>
<dd>
The function automatically determines the source string length. </dd>
<dd>
Performance is optimized for common UTF-8 sequences. </dd></dl>

</div>
</div>
<a id="aff93fe11056b42f3c929e4739bbad1bf" name="aff93fe11056b42f3c929e4739bbad1bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff93fe11056b42f3c929e4739bbad1bf">&#9670;&#160;</a></span>utf8toWChar() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">wchar_t * toy::utf8toWChar </td>
          <td>(</td>
          <td class="paramtype">wchar_t *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>destSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a Unicode UTF-8 encoded string to a wide character string with character count limit. </p>
<p>This function translates a UTF-8 encoded source string into a wide character string stored in the destination buffer. The conversion stops when the specified number of characters have been converted, the destination buffer is filled, or the source string ends.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>A pointer to the destination buffer where the converted wide character string will be stored. </td></tr>
    <tr><td class="paramname">destSize</td><td>The size of the destination buffer in wide characters (not bytes). </td></tr>
    <tr><td class="paramname">src</td><td>A pointer to the source UTF-8 encoded string. </td></tr>
    <tr><td class="paramname">count</td><td>The maximum number of characters to convert from the source string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the destination wide character string, or nullptr if the destination buffer is invalid.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The destination buffer must be valid and have sufficient capacity. </dd>
<dd>
The source string must be a valid UTF-8 encoded string. </dd>
<dd>
The count parameter must be reasonable (typically ≤ source string length).</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The destination string is null-terminated. </dd>
<dd>
The function returns nullptr on buffer overflow or invalid input.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Only BMP (≤ 0xFFFF) characters are supported by design; 4-byte UTF-8 sequences are not produced. </dd>
<dd>
The function handles UTF-8 validation and skips invalid sequences. </dd>
<dd>
If count exceeds the available characters, conversion stops at the end of the source string. </dd>
<dd>
The function is thread-safe for read operations. </dd>
<dd>
Performance is optimized for common UTF-8 sequences. </dd></dl>

</div>
</div>
<a id="ad81a8970ee6596253140bc264ef6e441" name="ad81a8970ee6596253140bc264ef6e441"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad81a8970ee6596253140bc264ef6e441">&#9670;&#160;</a></span>utf8toWChar() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;StringLike stringType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">wchar_t * toy::utf8toWChar </td>
          <td>(</td>
          <td class="paramtype">wchar_t *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>destSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const stringType &amp;</td>          <td class="paramname"><span class="paramname"><em>src</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a Unicode UTF-8 encoded string to a wide character string. </p>
<p>This template function translates a UTF-8 encoded source string from any string-like type into a wide character string. The conversion stops when the source string ends or the destination buffer is filled.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">stringType</td><td>The type of the source string. Must satisfy the <a class="el" href="../../df/d77/concepttoy_1_1_string_like.html" title="Concept defining the requirements for string-like types.">StringLike</a> concept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>A pointer to the destination buffer where the converted wide character string will be stored. </td></tr>
    <tr><td class="paramname">destSize</td><td>The size of the destination buffer in wide characters (not bytes). </td></tr>
    <tr><td class="paramname">src</td><td>A reference to a string-like object with UTF-8 encoded content.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the destination wide character string, or nullptr if the destination buffer is invalid.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The destination buffer must be valid and have sufficient capacity. </dd>
<dd>
The source object must provide UTF-8 encoded string data via c_str().</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The destination string is null-terminated. </dd>
<dd>
The function returns nullptr on buffer overflow or invalid input.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Only BMP (≤ 0xFFFF) characters are supported by design; 4-byte UTF-8 sequences are not produced. </dd>
<dd>
This template works with std::string, <a class="el" href="../../d3/d7a/classtoy_1_1_fixed_string.html" title="Template string class with fixed-size character buffer.">FixedString</a>, and other string-like types. </dd>
<dd>
The function automatically determines the source string length. </dd>
<dd>
Performance is optimized for common UTF-8 sequences. </dd></dl>

</div>
</div>
<a id="a0c19dd984dbb76264f00009b635304f2" name="a0c19dd984dbb76264f00009b635304f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c19dd984dbb76264f00009b635304f2">&#9670;&#160;</a></span>utoaImplementation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char * toy::utoaImplementation </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>destSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>base</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts an unsigned integer value to a string representation in a specified base. </p>
<p>This function converts a given unsigned integer value into its string representation in the specified numerical base, storing the result in the provided destination buffer. The resulting string is reversed in place and null-terminated.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">type</td><td>The type of the unsigned integer value to be converted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>The destination buffer where the converted string is stored. </td></tr>
    <tr><td class="paramname">destSize</td><td>The size of the destination buffer. </td></tr>
    <tr><td class="paramname">value</td><td>The unsigned integer value to be converted. </td></tr>
    <tr><td class="paramname">base</td><td>The numerical base for the conversion, e.g., 10 for decimal, 16 for hexadecimal.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the destination buffer containing the converted string.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The function assumes that the destination buffer is large enough to hold the converted string. If the destination buffer size is 1, only a null terminator is written. The base must be between 2 and 36 inclusive. </dd></dl>

</div>
</div>
<a id="af6f23b1a42f8357ca5341bbe33902d99" name="af6f23b1a42f8357ca5341bbe33902d99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6f23b1a42f8357ca5341bbe33902d99">&#9670;&#160;</a></span>wcharToUtf8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char * toy::wcharToUtf8 </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>destSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wchar_t *</td>          <td class="paramname"><span class="paramname"><em>src</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a Unicode wide character string to a UTF-8 encoded string. </p>
<p>This function translates a source wide character string into a UTF-8 encoded string stored in the destination buffer. The conversion stops when the source string ends or the destination buffer is filled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>A pointer to the destination buffer where the converted UTF-8 encoded string will be stored. </td></tr>
    <tr><td class="paramname">destSize</td><td>The size of the destination buffer in bytes (not wide characters). </td></tr>
    <tr><td class="paramname">src</td><td>A pointer to the source wide character string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the destination UTF-8 encoded string, or nullptr if the destination buffer is invalid.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The destination buffer must be valid and have sufficient capacity. </dd>
<dd>
The source string must be a valid wide character string. </dd>
<dd>
The destination buffer size should account for potential UTF-8 expansion.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The destination string is null-terminated. </dd>
<dd>
The function returns nullptr on buffer overflow or invalid input.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The function handles wide character to UTF-8 conversion efficiently. </dd>
<dd>
UTF-8 sequences may require 1-3 bytes per wide character. </dd>
<dd>
The function is thread-safe for read operations. </dd>
<dd>
Performance is optimized for common wide character ranges. </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a1b86c01d1136abd02c4b403630ed222f" name="a1b86c01d1136abd02c4b403630ed222f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b86c01d1136abd02c4b403630ed222f">&#9670;&#160;</a></span>sc_ansiDigits</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr std::array&lt; char, 36 &gt; toy::sc_ansiDigits</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{{<span class="charliteral">&#39;0&#39;</span>, <span class="charliteral">&#39;1&#39;</span>, <span class="charliteral">&#39;2&#39;</span>, <span class="charliteral">&#39;3&#39;</span>, <span class="charliteral">&#39;4&#39;</span>, <span class="charliteral">&#39;5&#39;</span>, <span class="charliteral">&#39;6&#39;</span>, <span class="charliteral">&#39;7&#39;</span>, <span class="charliteral">&#39;8&#39;</span>, <span class="charliteral">&#39;9&#39;</span>, <span class="charliteral">&#39;A&#39;</span>, <span class="charliteral">&#39;B&#39;</span>,</div>
<div class="line">                                                     <span class="charliteral">&#39;C&#39;</span>, <span class="charliteral">&#39;D&#39;</span>, <span class="charliteral">&#39;E&#39;</span>, <span class="charliteral">&#39;F&#39;</span>, <span class="charliteral">&#39;G&#39;</span>, <span class="charliteral">&#39;H&#39;</span>, <span class="charliteral">&#39;I&#39;</span>, <span class="charliteral">&#39;J&#39;</span>, <span class="charliteral">&#39;K&#39;</span>, <span class="charliteral">&#39;L&#39;</span>, <span class="charliteral">&#39;M&#39;</span>, <span class="charliteral">&#39;N&#39;</span>,</div>
<div class="line">                                                     <span class="charliteral">&#39;O&#39;</span>, <span class="charliteral">&#39;P&#39;</span>, <span class="charliteral">&#39;Q&#39;</span>, <span class="charliteral">&#39;R&#39;</span>, <span class="charliteral">&#39;S&#39;</span>, <span class="charliteral">&#39;T&#39;</span>, <span class="charliteral">&#39;U&#39;</span>, <span class="charliteral">&#39;V&#39;</span>, <span class="charliteral">&#39;W&#39;</span>, <span class="charliteral">&#39;X&#39;</span>, <span class="charliteral">&#39;Y&#39;</span>, <span class="charliteral">&#39;Z&#39;</span>}}</div>
</div><!-- fragment -->
</div>
</div>
<a id="aaba2640627e0f36ead0a3844fd35c6a9" name="aaba2640627e0f36ead0a3844fd35c6a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaba2640627e0f36ead0a3844fd35c6a9">&#9670;&#160;</a></span>wcharInUtf8MaxSize</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t toy::wcharInUtf8MaxSize = 3</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maximum UTF-8 bytes required for BMP characters. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../d4/da9/namespacetoy.html">toy</a></li>
    <li class="footer">Generated on Mon Sep 22 2025 for ToyGine2 by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
